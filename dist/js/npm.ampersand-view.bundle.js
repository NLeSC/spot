(window.webpackJsonp=window.webpackJsonp||[]).push([["npm.ampersand-view"],{2883:function(module,exports,__webpack_require__){eval("/*$AMPERSAND_VERSION*/\nvar State = __webpack_require__(/*! ampersand-state */ \"ef45\");\nvar CollectionView = __webpack_require__(/*! ampersand-collection-view */ \"694e\");\nvar domify = __webpack_require__(/*! domify */ \"2d1c\");\nvar uniqueId = __webpack_require__(/*! lodash/uniqueId */ \"6d0d\");\nvar pick = __webpack_require__(/*! lodash/pick */ \"2c5f\");\nvar assign = __webpack_require__(/*! lodash/assign */ \"5ad5\");\nvar forEach = __webpack_require__(/*! lodash/forEach */ \"3cfa\");\nvar result = __webpack_require__(/*! lodash/result */ \"80c9\");\nvar last = __webpack_require__(/*! lodash/last */ \"c3bf\");\nvar isString = __webpack_require__(/*! lodash/isString */ \"5fa3\");\nvar bind = __webpack_require__(/*! lodash/bind */ \"742b\");\nvar flatten = __webpack_require__(/*! lodash/flatten */ \"272e\");\nvar invokeMap = __webpack_require__(/*! lodash/invokeMap */ \"b7e5\");\nvar events = __webpack_require__(/*! events-mixin */ \"0b7d\");\nvar matches = __webpack_require__(/*! matches-selector */ \"6a4f\");\nvar bindings = __webpack_require__(/*! ampersand-dom-bindings */ \"f795\");\nvar getPath = __webpack_require__(/*! lodash/get */ \"ff28\");\n\nfunction View(attrs) {\n    this.cid = uniqueId('view');\n    attrs || (attrs = {});\n    var parent = attrs.parent;\n    delete attrs.parent;\n    BaseState.call(this, attrs, {init: false, parent: parent});\n    this.on('change:el', this._handleElementChange, this);\n    this._upsertBindings();\n    this.template = attrs.template || this.template;\n    this._cache.rendered = false; // prep `rendered` derived cache immediately\n    this.initialize.apply(this, arguments);\n    if (this.autoRender && this.template) {\n        this.render();\n    }\n}\n\nvar BaseState = State.extend({\n    dataTypes: {\n        element: {\n            set: function (newVal) {\n                return {\n                    val: newVal,\n                    type: newVal instanceof Element ? 'element' : typeof newVal\n                };\n            },\n            compare: function (el1, el2) {\n                return el1 === el2;\n            }\n        },\n        collection: {\n            set: function (newVal) {\n                return {\n                    val: newVal,\n                    type: newVal && newVal.isCollection ? 'collection' : typeof newVal\n                };\n            },\n            compare: function (currentVal, newVal) {\n                return currentVal === newVal;\n            }\n        }\n    },\n    props: {\n        model: 'state',\n        el: 'element',\n        collection: 'collection',\n    },\n    session: {\n        _rendered: ['boolean', true, false]\n    },\n    derived: {\n        hasData: {\n            deps: ['model'],\n            fn: function () {\n                return !!this.model;\n            }\n        },\n        rendered: {\n            deps: ['_rendered'],\n            fn: function() {\n                if (this._rendered) {\n                    this.trigger('render', this);\n                    return true;\n                }\n                this.trigger('remove', this);\n                return false;\n            }\n        }\n    }\n});\n\nView.prototype = Object.create(BaseState.prototype);\n\nvar queryNoElMsg = 'Query cannot be performed as this.el is not defined. Ensure that the view has been rendered.';\n\n// Set up all inheritable properties and methods.\nassign(View.prototype, {\n    // ## query\n    // Get an single element based on CSS selector scoped to this.el\n    // if you pass an empty string it return `this.el`.\n    // If you pass an element we just return it back.\n    // This lets us use `get` to handle cases where users\n    // can pass a selector or an already selected element.\n    query: function (selector) {\n        if (!this.el) {\n            throw new Error(queryNoElMsg);\n        }\n        if (!selector) return this.el;\n        if (typeof selector === 'string') {\n            if (matches(this.el, selector)) return this.el;\n            return this.el.querySelector(selector) || undefined;\n        }\n        return selector;\n    },\n\n    // ## queryAll\n    // Returns an array of elements based on CSS selector scoped to this.el\n    // if you pass an empty string it return `this.el`. Also includes root\n    // element.\n    queryAll: function (selector) {\n        if (!this.el) {\n            throw new Error(queryNoElMsg);\n        }\n        if (!selector) return [this.el];\n        var res = [];\n        if (matches(this.el, selector)) res.push(this.el);\n        return res.concat(Array.prototype.slice.call(this.el.querySelectorAll(selector)));\n    },\n\n    // ## queryByHook\n    // Convenience method for fetching element by it's `data-hook` attribute.\n    // Also tries to match against root element.\n    // Also supports matching 'one' of several space separated hooks.\n    queryByHook: function (hook) {\n        return this.query('[data-hook~=\"' + hook + '\"]');\n    },\n\n    // ## queryAllByHook\n    // Convenience method for fetching all elements by their's `data-hook` attribute.\n    queryAllByHook: function (hook) {\n        return this.queryAll('[data-hook~=\"' + hook + '\"]');\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function () {},\n\n    // **render** is the core function that your view can override. Its job is\n    // to populate its element (`this.el`), with the appropriate HTML.\n    _render: function () {\n        this._upsertBindings();\n        this.renderWithTemplate(this);\n        this._rendered = true;\n        return this;\n    },\n\n    // Removes this view by taking the element out of the DOM, and removing any\n    // applicable events listeners.\n    _remove: function () {\n        if (this.el && this.el.parentNode) this.el.parentNode.removeChild(this.el);\n        this._rendered = false;\n        this._downsertBindings();\n        return this;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    _handleElementChange: function (element, delegate) {\n        if (this.eventManager) this.eventManager.unbind();\n        this.eventManager = events(this.el, this);\n        this.delegateEvents();\n        this._applyBindingsForKey();\n        return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function (e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function (events) {\n        if (!(events || (events = result(this, 'events')))) return this;\n        this.undelegateEvents();\n        for (var key in events) {\n            this.eventManager.bind(key, events[key]);\n        }\n        return this;\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function () {\n        this.eventManager.unbind();\n        return this;\n    },\n\n    // ## registerSubview\n    // Pass it a view. This can be anything with a `remove` method\n    registerSubview: function (view) {\n        // Storage for our subviews.\n        this._subviews = this._subviews || [];\n        this._subviews.push(view);\n        // set the parent reference if it has not been set\n        if (!view.parent) view.parent = this;\n        return view;\n    },\n\n    // ## renderSubview\n    // Pass it a view instance and a container element\n    // to render it in. It's `remove` method will be called\n    // when the parent view is destroyed.\n    renderSubview: function (view, container) {\n        if (typeof container === 'string') {\n            container = this.query(container);\n        }\n        if (!container) container = this.el;\n        this.registerSubview(view);\n        view.render();\n        container.appendChild(view.el);\n        return view;\n    },\n\n    _applyBindingsForKey: function (name) {\n        if (!this.el) return;\n        var fns = this._parsedBindings.getGrouped(name);\n        var item;\n        for (item in fns) {\n            fns[item].forEach(function (fn) {\n                fn(this.el, getPath(this, item), last(item.split('.')));\n            }, this);\n        }\n    },\n\n    _initializeBindings: function () {\n        if (!this.bindings) return;\n        this.on('all', function (eventName) {\n            if (eventName.slice(0, 7) === 'change:') {\n                this._applyBindingsForKey(eventName.split(':')[1]);\n            }\n        }, this);\n    },\n\n    // ## _initializeSubviews\n    // this is called at setup and grabs declared subviews\n    _initializeSubviews: function () {\n        if (!this.subviews) return;\n        for (var item in this.subviews) {\n            this._parseSubview(this.subviews[item], item);\n        }\n    },\n\n    // ## _parseSubview\n    // helper for parsing out the subview declaration and registering\n    // the `waitFor` if need be.\n    _parseSubview: function (subview, name) {\n        //backwards compatibility with older versions, when `container` was a valid property (#114)\n        if (subview.container) {\n            subview.selector = subview.container;\n        }\n        var opts = this._parseSubviewOpts(subview);\n\n        function action() {\n            var el, subview;\n            // if not rendered or we can't find our element, stop here.\n            if (!this.el || !(el = this.query(opts.selector))) return;\n            if (!opts.waitFor || getPath(this, opts.waitFor)) {\n                subview = this[name] = opts.prepareView.call(this, el);\n                if (!subview.el) {\n                    this.renderSubview(subview, el);\n                } else {\n                    subview.render();\n                    this.registerSubview(subview);\n                }\n                this.off('change', action);\n            }\n        }\n        // we listen for main `change` items\n        this.on('change', action, this);\n    },\n\n    // Parses the declarative subview definition.\n    // You may overload this method to create your own declarative subview style.\n    // You must return an object with members 'selector', 'waitFor' and 'prepareView'.\n    // waitFor is trigged on the view 'change' event and so one way to extend the deferred view\n    // construction is to add an additional property (props) to the view. Then setting this property\n    // will satisfy the waitFor condition. You can then extend the prepareView function to pass in\n    // additional data from the parent view. This can allow you to have multi-stage rendering of\n    // custom data formats and to declaratively define.\n    _parseSubviewOpts: function (subview) {\n        var self = this;\n        var opts = {\n            selector: subview.selector || '[data-hook=\"' + subview.hook + '\"]',\n            waitFor: subview.waitFor || '',\n            prepareView: subview.prepareView || function () {\n                return new subview.constructor({\n                    parent: self\n                });\n            }\n        };\n        return opts;\n    },\n\n    // Shortcut for doing everything we need to do to\n    // render and fully replace current root element.\n    // Either define a `template` property of your view\n    // or pass in a template directly.\n    // The template can either be a string or a function.\n    // If it's a function it will be passed the `context`\n    // argument.\n    renderWithTemplate: function (context, templateArg) {\n        var template = templateArg || this.template;\n        if (!template) throw new Error('Template string or function needed.');\n        var newDom = isString(template) ? template : template.call(this, context || this);\n        if (isString(newDom)) newDom = domify(newDom);\n        var parent = this.el && this.el.parentNode;\n        if (parent) parent.replaceChild(newDom, this.el);\n        if (newDom.nodeName === '#document-fragment') throw new Error('Views can only have one root element, including comment nodes.');\n        this.el = newDom;\n        return this;\n    },\n\n    // ## cacheElements\n    // This is a shortcut for adding reference to specific elements within your view for\n    // access later. This avoids excessive DOM queries and makes it easier to update\n    // your view if your template changes.\n    //\n    // In your `render` method. Use it like so:\n    //\n    //     render: function () {\n    //       this.basicRender();\n    //       this.cacheElements({\n    //         pages: '#pages',\n    //         chat: '#teamChat',\n    //         nav: 'nav#views ul',\n    //         me: '#me',\n    //         cheatSheet: '#cheatSheet',\n    //         omniBox: '#awesomeSauce'\n    //       });\n    //     }\n    //\n    // Then later you can access elements by reference like so: `this.pages`, or `this.chat`.\n    cacheElements: function (hash) {\n        for (var item in hash) {\n            this[item] = this.query(hash[item]);\n        }\n        return this;\n    },\n\n    // ## animateRemove\n    // Placeholder for if you want to do something special when they're removed.\n    // For example fade it out, etc.\n    // Any override here should call `.remove()` when done.\n    animateRemove: function () {\n        this.remove();\n    },\n\n    // ## renderCollection\n    // Method for rendering a collections with individual views.\n    // Just pass it the collection, and the view to use for the items in the\n    // collection. The collectionView is returned.\n    renderCollection: function (collection, ViewClass, container, opts) {\n        var containerEl = (typeof container === 'string') ? this.query(container) : container;\n        var config = assign({\n            collection: collection,\n            el: containerEl || this.el,\n            view: ViewClass,\n            parent: this,\n            viewOptions: {\n                parent: this\n            }\n        }, opts);\n        var collectionView = new CollectionView(config);\n        collectionView.render();\n        return this.registerSubview(collectionView);\n    },\n\n    _setRender: function(obj) {\n        Object.defineProperty(obj, 'render', {\n            get: function() {\n                return this._render;\n            },\n            set: function(fn) {\n                this._render = function() {\n                    fn.apply(this, arguments);\n                    this._rendered = true;\n                    return this;\n                };\n            }\n        });\n    },\n\n    _setRemove: function(obj) {\n        Object.defineProperty(obj, 'remove', {\n            get: function() {\n                return this._remove;\n            },\n            set: function(fn) {\n                this._remove = function() {\n                    fn.apply(this, arguments);\n                    this._rendered = false;\n                    return this;\n                };\n            }\n        });\n    },\n\n    _downsertBindings: function() {\n        var parsedBindings = this._parsedBindings;\n        if (!this.bindingsSet) return;\n        if (this._subviews){\n          invokeMap(flatten(this._subviews), 'remove');\n          this._subviews = [];\n        }\n        this.stopListening();\n        this.bindingsSet = false;\n    },\n\n    _upsertBindings: function(attrs) {\n        attrs = attrs || this;\n        if (this.bindingsSet) return;\n        this._parsedBindings = bindings(this.bindings, this);\n        this._initializeBindings();\n        if (attrs.el && !this.autoRender) {\n            this._handleElementChange();\n        }\n        this._initializeSubviews();\n        this.bindingsSet = true;\n    }\n});\n\nView.prototype._setRender(View.prototype);\nView.prototype._setRemove(View.prototype);\nView.extend = BaseState.extend;\nmodule.exports = View;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg4My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbXBlcnNhbmQtdmlldy9hbXBlcnNhbmQtdmlldy5qcz9jZTg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qJEFNUEVSU0FORF9WRVJTSU9OKi9cbnZhciBTdGF0ZSA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1zdGF0ZScpO1xudmFyIENvbGxlY3Rpb25WaWV3ID0gcmVxdWlyZSgnYW1wZXJzYW5kLWNvbGxlY3Rpb24tdmlldycpO1xudmFyIGRvbWlmeSA9IHJlcXVpcmUoJ2RvbWlmeScpO1xudmFyIHVuaXF1ZUlkID0gcmVxdWlyZShcImxvZGFzaC91bmlxdWVJZFwiKTtcbnZhciBwaWNrID0gcmVxdWlyZShcImxvZGFzaC9waWNrXCIpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIik7XG52YXIgcmVzdWx0ID0gcmVxdWlyZShcImxvZGFzaC9yZXN1bHRcIik7XG52YXIgbGFzdCA9IHJlcXVpcmUoXCJsb2Rhc2gvbGFzdFwiKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIik7XG52YXIgYmluZCA9IHJlcXVpcmUoXCJsb2Rhc2gvYmluZFwiKTtcbnZhciBmbGF0dGVuID0gcmVxdWlyZShcImxvZGFzaC9mbGF0dGVuXCIpO1xudmFyIGludm9rZU1hcCA9IHJlcXVpcmUoXCJsb2Rhc2gvaW52b2tlTWFwXCIpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cy1taXhpbicpO1xudmFyIG1hdGNoZXMgPSByZXF1aXJlKCdtYXRjaGVzLXNlbGVjdG9yJyk7XG52YXIgYmluZGluZ3MgPSByZXF1aXJlKCdhbXBlcnNhbmQtZG9tLWJpbmRpbmdzJyk7XG52YXIgZ2V0UGF0aCA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcblxuZnVuY3Rpb24gVmlldyhhdHRycykge1xuICAgIHRoaXMuY2lkID0gdW5pcXVlSWQoJ3ZpZXcnKTtcbiAgICBhdHRycyB8fCAoYXR0cnMgPSB7fSk7XG4gICAgdmFyIHBhcmVudCA9IGF0dHJzLnBhcmVudDtcbiAgICBkZWxldGUgYXR0cnMucGFyZW50O1xuICAgIEJhc2VTdGF0ZS5jYWxsKHRoaXMsIGF0dHJzLCB7aW5pdDogZmFsc2UsIHBhcmVudDogcGFyZW50fSk7XG4gICAgdGhpcy5vbignY2hhbmdlOmVsJywgdGhpcy5faGFuZGxlRWxlbWVudENoYW5nZSwgdGhpcyk7XG4gICAgdGhpcy5fdXBzZXJ0QmluZGluZ3MoKTtcbiAgICB0aGlzLnRlbXBsYXRlID0gYXR0cnMudGVtcGxhdGUgfHwgdGhpcy50ZW1wbGF0ZTtcbiAgICB0aGlzLl9jYWNoZS5yZW5kZXJlZCA9IGZhbHNlOyAvLyBwcmVwIGByZW5kZXJlZGAgZGVyaXZlZCBjYWNoZSBpbW1lZGlhdGVseVxuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLmF1dG9SZW5kZXIgJiYgdGhpcy50ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbn1cblxudmFyIEJhc2VTdGF0ZSA9IFN0YXRlLmV4dGVuZCh7XG4gICAgZGF0YVR5cGVzOiB7XG4gICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbDogbmV3VmFsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXdWYWwgaW5zdGFuY2VvZiBFbGVtZW50ID8gJ2VsZW1lbnQnIDogdHlwZW9mIG5ld1ZhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGFyZTogZnVuY3Rpb24gKGVsMSwgZWwyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsMSA9PT0gZWwyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWw6IG5ld1ZhbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbmV3VmFsICYmIG5ld1ZhbC5pc0NvbGxlY3Rpb24gPyAnY29sbGVjdGlvbicgOiB0eXBlb2YgbmV3VmFsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudFZhbCwgbmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWwgPT09IG5ld1ZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgbW9kZWw6ICdzdGF0ZScsXG4gICAgICAgIGVsOiAnZWxlbWVudCcsXG4gICAgICAgIGNvbGxlY3Rpb246ICdjb2xsZWN0aW9uJyxcbiAgICB9LFxuICAgIHNlc3Npb246IHtcbiAgICAgICAgX3JlbmRlcmVkOiBbJ2Jvb2xlYW4nLCB0cnVlLCBmYWxzZV1cbiAgICB9LFxuICAgIGRlcml2ZWQ6IHtcbiAgICAgICAgaGFzRGF0YToge1xuICAgICAgICAgICAgZGVwczogWydtb2RlbCddLFxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW5kZXJlZDoge1xuICAgICAgICAgICAgZGVwczogWydfcmVuZGVyZWQnXSxcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZW5kZXInLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVtb3ZlJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cblZpZXcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlU3RhdGUucHJvdG90eXBlKTtcblxudmFyIHF1ZXJ5Tm9FbE1zZyA9ICdRdWVyeSBjYW5ub3QgYmUgcGVyZm9ybWVkIGFzIHRoaXMuZWwgaXMgbm90IGRlZmluZWQuIEVuc3VyZSB0aGF0IHRoZSB2aWV3IGhhcyBiZWVuIHJlbmRlcmVkLic7XG5cbi8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbmFzc2lnbihWaWV3LnByb3RvdHlwZSwge1xuICAgIC8vICMjIHF1ZXJ5XG4gICAgLy8gR2V0IGFuIHNpbmdsZSBlbGVtZW50IGJhc2VkIG9uIENTUyBzZWxlY3RvciBzY29wZWQgdG8gdGhpcy5lbFxuICAgIC8vIGlmIHlvdSBwYXNzIGFuIGVtcHR5IHN0cmluZyBpdCByZXR1cm4gYHRoaXMuZWxgLlxuICAgIC8vIElmIHlvdSBwYXNzIGFuIGVsZW1lbnQgd2UganVzdCByZXR1cm4gaXQgYmFjay5cbiAgICAvLyBUaGlzIGxldHMgdXMgdXNlIGBnZXRgIHRvIGhhbmRsZSBjYXNlcyB3aGVyZSB1c2Vyc1xuICAgIC8vIGNhbiBwYXNzIGEgc2VsZWN0b3Igb3IgYW4gYWxyZWFkeSBzZWxlY3RlZCBlbGVtZW50LlxuICAgIHF1ZXJ5OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocXVlcnlOb0VsTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gdGhpcy5lbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKHRoaXMuZWwsIHNlbGVjdG9yKSkgcmV0dXJuIHRoaXMuZWw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH0sXG5cbiAgICAvLyAjIyBxdWVyeUFsbFxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgZWxlbWVudHMgYmFzZWQgb24gQ1NTIHNlbGVjdG9yIHNjb3BlZCB0byB0aGlzLmVsXG4gICAgLy8gaWYgeW91IHBhc3MgYW4gZW1wdHkgc3RyaW5nIGl0IHJldHVybiBgdGhpcy5lbGAuIEFsc28gaW5jbHVkZXMgcm9vdFxuICAgIC8vIGVsZW1lbnQuXG4gICAgcXVlcnlBbGw6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihxdWVyeU5vRWxNc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZWN0b3IpIHJldHVybiBbdGhpcy5lbF07XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgaWYgKG1hdGNoZXModGhpcy5lbCwgc2VsZWN0b3IpKSByZXMucHVzaCh0aGlzLmVsKTtcbiAgICAgICAgcmV0dXJuIHJlcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpO1xuICAgIH0sXG5cbiAgICAvLyAjIyBxdWVyeUJ5SG9va1xuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgZmV0Y2hpbmcgZWxlbWVudCBieSBpdCdzIGBkYXRhLWhvb2tgIGF0dHJpYnV0ZS5cbiAgICAvLyBBbHNvIHRyaWVzIHRvIG1hdGNoIGFnYWluc3Qgcm9vdCBlbGVtZW50LlxuICAgIC8vIEFsc28gc3VwcG9ydHMgbWF0Y2hpbmcgJ29uZScgb2Ygc2V2ZXJhbCBzcGFjZSBzZXBhcmF0ZWQgaG9va3MuXG4gICAgcXVlcnlCeUhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KCdbZGF0YS1ob29rfj1cIicgKyBob29rICsgJ1wiXScpO1xuICAgIH0sXG5cbiAgICAvLyAjIyBxdWVyeUFsbEJ5SG9va1xuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgZmV0Y2hpbmcgYWxsIGVsZW1lbnRzIGJ5IHRoZWlyJ3MgYGRhdGEtaG9va2AgYXR0cmlidXRlLlxuICAgIHF1ZXJ5QWxsQnlIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeUFsbCgnW2RhdGEtaG9va349XCInICsgaG9vayArICdcIl0nKTtcbiAgICB9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgICAvLyAqKnJlbmRlcioqIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IGNhbiBvdmVycmlkZS4gSXRzIGpvYiBpc1xuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLlxuICAgIF9yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdXBzZXJ0QmluZGluZ3MoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJXaXRoVGVtcGxhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZXMgdGhpcyB2aWV3IGJ5IHRha2luZyB0aGUgZWxlbWVudCBvdXQgb2YgdGhlIERPTSwgYW5kIHJlbW92aW5nIGFueVxuICAgIC8vIGFwcGxpY2FibGUgZXZlbnRzIGxpc3RlbmVycy5cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kb3duc2VydEJpbmRpbmdzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDaGFuZ2UgdGhlIHZpZXcncyBlbGVtZW50IChgdGhpcy5lbGAgcHJvcGVydHkpLCBpbmNsdWRpbmcgZXZlbnRcbiAgICAvLyByZS1kZWxlZ2F0aW9uLlxuICAgIF9oYW5kbGVFbGVtZW50Q2hhbmdlOiBmdW5jdGlvbiAoZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRNYW5hZ2VyKSB0aGlzLmV2ZW50TWFuYWdlci51bmJpbmQoKTtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudHModGhpcy5lbCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlCaW5kaW5nc0ZvcktleSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uIChlKSB7IC4uLiB9XG4gICAgLy8gICAgIH1cbiAgICAvL1xuICAgIC8vIHBhaXJzLiBDYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGUgdmlldywgd2l0aCBgdGhpc2Agc2V0IHByb3Blcmx5LlxuICAgIC8vIFVzZXMgZXZlbnQgZGVsZWdhdGlvbiBmb3IgZWZmaWNpZW5jeS5cbiAgICAvLyBPbWl0dGluZyB0aGUgc2VsZWN0b3IgYmluZHMgdGhlIGV2ZW50IHRvIGB0aGlzLmVsYC5cbiAgICAvLyBUaGlzIG9ubHkgd29ya3MgZm9yIGRlbGVnYXRlLWFibGUgZXZlbnRzOiBub3QgYGZvY3VzYCwgYGJsdXJgLCBhbmRcbiAgICAvLyBub3QgYGNoYW5nZWAsIGBzdWJtaXRgLCBhbmQgYHJlc2V0YCBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgICAgICBpZiAoIShldmVudHMgfHwgKGV2ZW50cyA9IHJlc3VsdCh0aGlzLCAnZXZlbnRzJykpKSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5iaW5kKGtleSwgZXZlbnRzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhcnMgYWxsIGNhbGxiYWNrcyBwcmV2aW91c2x5IGJvdW5kIHRvIHRoZSB2aWV3IHdpdGggYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnVuYmluZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIyMgcmVnaXN0ZXJTdWJ2aWV3XG4gICAgLy8gUGFzcyBpdCBhIHZpZXcuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHdpdGggYSBgcmVtb3ZlYCBtZXRob2RcbiAgICByZWdpc3RlclN1YnZpZXc6IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIC8vIFN0b3JhZ2UgZm9yIG91ciBzdWJ2aWV3cy5cbiAgICAgICAgdGhpcy5fc3Vidmlld3MgPSB0aGlzLl9zdWJ2aWV3cyB8fCBbXTtcbiAgICAgICAgdGhpcy5fc3Vidmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgLy8gc2V0IHRoZSBwYXJlbnQgcmVmZXJlbmNlIGlmIGl0IGhhcyBub3QgYmVlbiBzZXRcbiAgICAgICAgaWYgKCF2aWV3LnBhcmVudCkgdmlldy5wYXJlbnQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9LFxuXG4gICAgLy8gIyMgcmVuZGVyU3Vidmlld1xuICAgIC8vIFBhc3MgaXQgYSB2aWV3IGluc3RhbmNlIGFuZCBhIGNvbnRhaW5lciBlbGVtZW50XG4gICAgLy8gdG8gcmVuZGVyIGl0IGluLiBJdCdzIGByZW1vdmVgIG1ldGhvZCB3aWxsIGJlIGNhbGxlZFxuICAgIC8vIHdoZW4gdGhlIHBhcmVudCB2aWV3IGlzIGRlc3Ryb3llZC5cbiAgICByZW5kZXJTdWJ2aWV3OiBmdW5jdGlvbiAodmlldywgY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5xdWVyeShjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGFpbmVyKSBjb250YWluZXIgPSB0aGlzLmVsO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyU3Vidmlldyh2aWV3KTtcbiAgICAgICAgdmlldy5yZW5kZXIoKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZpZXcuZWwpO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9LFxuXG4gICAgX2FwcGx5QmluZGluZ3NGb3JLZXk6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5lbCkgcmV0dXJuO1xuICAgICAgICB2YXIgZm5zID0gdGhpcy5fcGFyc2VkQmluZGluZ3MuZ2V0R3JvdXBlZChuYW1lKTtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIGZvciAoaXRlbSBpbiBmbnMpIHtcbiAgICAgICAgICAgIGZuc1tpdGVtXS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKHRoaXMuZWwsIGdldFBhdGgodGhpcywgaXRlbSksIGxhc3QoaXRlbS5zcGxpdCgnLicpKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdGlhbGl6ZUJpbmRpbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5iaW5kaW5ncykgcmV0dXJuO1xuICAgICAgICB0aGlzLm9uKCdhbGwnLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lLnNsaWNlKDAsIDcpID09PSAnY2hhbmdlOicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUJpbmRpbmdzRm9yS2V5KGV2ZW50TmFtZS5zcGxpdCgnOicpWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vICMjIF9pbml0aWFsaXplU3Vidmlld3NcbiAgICAvLyB0aGlzIGlzIGNhbGxlZCBhdCBzZXR1cCBhbmQgZ3JhYnMgZGVjbGFyZWQgc3Vidmlld3NcbiAgICBfaW5pdGlhbGl6ZVN1YnZpZXdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJ2aWV3cykgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpdGVtIGluIHRoaXMuc3Vidmlld3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlU3Vidmlldyh0aGlzLnN1YnZpZXdzW2l0ZW1dLCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAjIyBfcGFyc2VTdWJ2aWV3XG4gICAgLy8gaGVscGVyIGZvciBwYXJzaW5nIG91dCB0aGUgc3VidmlldyBkZWNsYXJhdGlvbiBhbmQgcmVnaXN0ZXJpbmdcbiAgICAvLyB0aGUgYHdhaXRGb3JgIGlmIG5lZWQgYmUuXG4gICAgX3BhcnNlU3VidmlldzogZnVuY3Rpb24gKHN1YnZpZXcsIG5hbWUpIHtcbiAgICAgICAgLy9iYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIHZlcnNpb25zLCB3aGVuIGBjb250YWluZXJgIHdhcyBhIHZhbGlkIHByb3BlcnR5ICgjMTE0KVxuICAgICAgICBpZiAoc3Vidmlldy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHN1YnZpZXcuc2VsZWN0b3IgPSBzdWJ2aWV3LmNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX3BhcnNlU3Vidmlld09wdHMoc3Vidmlldyk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsLCBzdWJ2aWV3O1xuICAgICAgICAgICAgLy8gaWYgbm90IHJlbmRlcmVkIG9yIHdlIGNhbid0IGZpbmQgb3VyIGVsZW1lbnQsIHN0b3AgaGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5lbCB8fCAhKGVsID0gdGhpcy5xdWVyeShvcHRzLnNlbGVjdG9yKSkpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghb3B0cy53YWl0Rm9yIHx8IGdldFBhdGgodGhpcywgb3B0cy53YWl0Rm9yKSkge1xuICAgICAgICAgICAgICAgIHN1YnZpZXcgPSB0aGlzW25hbWVdID0gb3B0cy5wcmVwYXJlVmlldy5jYWxsKHRoaXMsIGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnZpZXcuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTdWJ2aWV3KHN1YnZpZXcsIGVsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWJ2aWV3LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyU3VidmlldyhzdWJ2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2NoYW5nZScsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbGlzdGVuIGZvciBtYWluIGBjaGFuZ2VgIGl0ZW1zXG4gICAgICAgIHRoaXMub24oJ2NoYW5nZScsIGFjdGlvbiwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFBhcnNlcyB0aGUgZGVjbGFyYXRpdmUgc3VidmlldyBkZWZpbml0aW9uLlxuICAgIC8vIFlvdSBtYXkgb3ZlcmxvYWQgdGhpcyBtZXRob2QgdG8gY3JlYXRlIHlvdXIgb3duIGRlY2xhcmF0aXZlIHN1YnZpZXcgc3R5bGUuXG4gICAgLy8gWW91IG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIG1lbWJlcnMgJ3NlbGVjdG9yJywgJ3dhaXRGb3InIGFuZCAncHJlcGFyZVZpZXcnLlxuICAgIC8vIHdhaXRGb3IgaXMgdHJpZ2dlZCBvbiB0aGUgdmlldyAnY2hhbmdlJyBldmVudCBhbmQgc28gb25lIHdheSB0byBleHRlbmQgdGhlIGRlZmVycmVkIHZpZXdcbiAgICAvLyBjb25zdHJ1Y3Rpb24gaXMgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcHJvcGVydHkgKHByb3BzKSB0byB0aGUgdmlldy4gVGhlbiBzZXR0aW5nIHRoaXMgcHJvcGVydHlcbiAgICAvLyB3aWxsIHNhdGlzZnkgdGhlIHdhaXRGb3IgY29uZGl0aW9uLiBZb3UgY2FuIHRoZW4gZXh0ZW5kIHRoZSBwcmVwYXJlVmlldyBmdW5jdGlvbiB0byBwYXNzIGluXG4gICAgLy8gYWRkaXRpb25hbCBkYXRhIGZyb20gdGhlIHBhcmVudCB2aWV3LiBUaGlzIGNhbiBhbGxvdyB5b3UgdG8gaGF2ZSBtdWx0aS1zdGFnZSByZW5kZXJpbmcgb2ZcbiAgICAvLyBjdXN0b20gZGF0YSBmb3JtYXRzIGFuZCB0byBkZWNsYXJhdGl2ZWx5IGRlZmluZS5cbiAgICBfcGFyc2VTdWJ2aWV3T3B0czogZnVuY3Rpb24gKHN1YnZpZXcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzdWJ2aWV3LnNlbGVjdG9yIHx8ICdbZGF0YS1ob29rPVwiJyArIHN1YnZpZXcuaG9vayArICdcIl0nLFxuICAgICAgICAgICAgd2FpdEZvcjogc3Vidmlldy53YWl0Rm9yIHx8ICcnLFxuICAgICAgICAgICAgcHJlcGFyZVZpZXc6IHN1YnZpZXcucHJlcGFyZVZpZXcgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3Vidmlldy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogc2VsZlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9LFxuXG4gICAgLy8gU2hvcnRjdXQgZm9yIGRvaW5nIGV2ZXJ5dGhpbmcgd2UgbmVlZCB0byBkbyB0b1xuICAgIC8vIHJlbmRlciBhbmQgZnVsbHkgcmVwbGFjZSBjdXJyZW50IHJvb3QgZWxlbWVudC5cbiAgICAvLyBFaXRoZXIgZGVmaW5lIGEgYHRlbXBsYXRlYCBwcm9wZXJ0eSBvZiB5b3VyIHZpZXdcbiAgICAvLyBvciBwYXNzIGluIGEgdGVtcGxhdGUgZGlyZWN0bHkuXG4gICAgLy8gVGhlIHRlbXBsYXRlIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi5cbiAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb24gaXQgd2lsbCBiZSBwYXNzZWQgdGhlIGBjb250ZXh0YFxuICAgIC8vIGFyZ3VtZW50LlxuICAgIHJlbmRlcldpdGhUZW1wbGF0ZTogZnVuY3Rpb24gKGNvbnRleHQsIHRlbXBsYXRlQXJnKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRlbXBsYXRlQXJnIHx8IHRoaXMudGVtcGxhdGU7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHRocm93IG5ldyBFcnJvcignVGVtcGxhdGUgc3RyaW5nIG9yIGZ1bmN0aW9uIG5lZWRlZC4nKTtcbiAgICAgICAgdmFyIG5ld0RvbSA9IGlzU3RyaW5nKHRlbXBsYXRlKSA/IHRlbXBsYXRlIDogdGVtcGxhdGUuY2FsbCh0aGlzLCBjb250ZXh0IHx8IHRoaXMpO1xuICAgICAgICBpZiAoaXNTdHJpbmcobmV3RG9tKSkgbmV3RG9tID0gZG9taWZ5KG5ld0RvbSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdEb20sIHRoaXMuZWwpO1xuICAgICAgICBpZiAobmV3RG9tLm5vZGVOYW1lID09PSAnI2RvY3VtZW50LWZyYWdtZW50JykgdGhyb3cgbmV3IEVycm9yKCdWaWV3cyBjYW4gb25seSBoYXZlIG9uZSByb290IGVsZW1lbnQsIGluY2x1ZGluZyBjb21tZW50IG5vZGVzLicpO1xuICAgICAgICB0aGlzLmVsID0gbmV3RG9tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIyMgY2FjaGVFbGVtZW50c1xuICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgYWRkaW5nIHJlZmVyZW5jZSB0byBzcGVjaWZpYyBlbGVtZW50cyB3aXRoaW4geW91ciB2aWV3IGZvclxuICAgIC8vIGFjY2VzcyBsYXRlci4gVGhpcyBhdm9pZHMgZXhjZXNzaXZlIERPTSBxdWVyaWVzIGFuZCBtYWtlcyBpdCBlYXNpZXIgdG8gdXBkYXRlXG4gICAgLy8geW91ciB2aWV3IGlmIHlvdXIgdGVtcGxhdGUgY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIEluIHlvdXIgYHJlbmRlcmAgbWV0aG9kLiBVc2UgaXQgbGlrZSBzbzpcbiAgICAvL1xuICAgIC8vICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAgICAgICB0aGlzLmJhc2ljUmVuZGVyKCk7XG4gICAgLy8gICAgICAgdGhpcy5jYWNoZUVsZW1lbnRzKHtcbiAgICAvLyAgICAgICAgIHBhZ2VzOiAnI3BhZ2VzJyxcbiAgICAvLyAgICAgICAgIGNoYXQ6ICcjdGVhbUNoYXQnLFxuICAgIC8vICAgICAgICAgbmF2OiAnbmF2I3ZpZXdzIHVsJyxcbiAgICAvLyAgICAgICAgIG1lOiAnI21lJyxcbiAgICAvLyAgICAgICAgIGNoZWF0U2hlZXQ6ICcjY2hlYXRTaGVldCcsXG4gICAgLy8gICAgICAgICBvbW5pQm94OiAnI2F3ZXNvbWVTYXVjZSdcbiAgICAvLyAgICAgICB9KTtcbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gVGhlbiBsYXRlciB5b3UgY2FuIGFjY2VzcyBlbGVtZW50cyBieSByZWZlcmVuY2UgbGlrZSBzbzogYHRoaXMucGFnZXNgLCBvciBgdGhpcy5jaGF0YC5cbiAgICBjYWNoZUVsZW1lbnRzOiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICBmb3IgKHZhciBpdGVtIGluIGhhc2gpIHtcbiAgICAgICAgICAgIHRoaXNbaXRlbV0gPSB0aGlzLnF1ZXJ5KGhhc2hbaXRlbV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyAjIyBhbmltYXRlUmVtb3ZlXG4gICAgLy8gUGxhY2Vob2xkZXIgZm9yIGlmIHlvdSB3YW50IHRvIGRvIHNvbWV0aGluZyBzcGVjaWFsIHdoZW4gdGhleSdyZSByZW1vdmVkLlxuICAgIC8vIEZvciBleGFtcGxlIGZhZGUgaXQgb3V0LCBldGMuXG4gICAgLy8gQW55IG92ZXJyaWRlIGhlcmUgc2hvdWxkIGNhbGwgYC5yZW1vdmUoKWAgd2hlbiBkb25lLlxuICAgIGFuaW1hdGVSZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gIyMgcmVuZGVyQ29sbGVjdGlvblxuICAgIC8vIE1ldGhvZCBmb3IgcmVuZGVyaW5nIGEgY29sbGVjdGlvbnMgd2l0aCBpbmRpdmlkdWFsIHZpZXdzLlxuICAgIC8vIEp1c3QgcGFzcyBpdCB0aGUgY29sbGVjdGlvbiwgYW5kIHRoZSB2aWV3IHRvIHVzZSBmb3IgdGhlIGl0ZW1zIGluIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24uIFRoZSBjb2xsZWN0aW9uVmlldyBpcyByZXR1cm5lZC5cbiAgICByZW5kZXJDb2xsZWN0aW9uOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgVmlld0NsYXNzLCBjb250YWluZXIsIG9wdHMpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lckVsID0gKHR5cGVvZiBjb250YWluZXIgPT09ICdzdHJpbmcnKSA/IHRoaXMucXVlcnkoY29udGFpbmVyKSA6IGNvbnRhaW5lcjtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGFzc2lnbih7XG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgZWw6IGNvbnRhaW5lckVsIHx8IHRoaXMuZWwsXG4gICAgICAgICAgICB2aWV3OiBWaWV3Q2xhc3MsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICB2aWV3T3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb25WaWV3ID0gbmV3IENvbGxlY3Rpb25WaWV3KGNvbmZpZyk7XG4gICAgICAgIGNvbGxlY3Rpb25WaWV3LnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN1YnZpZXcoY29sbGVjdGlvblZpZXcpO1xuICAgIH0sXG5cbiAgICBfc2V0UmVuZGVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3JlbmRlcicsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9zZXRSZW1vdmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAncmVtb3ZlJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9kb3duc2VydEJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcnNlZEJpbmRpbmdzID0gdGhpcy5fcGFyc2VkQmluZGluZ3M7XG4gICAgICAgIGlmICghdGhpcy5iaW5kaW5nc1NldCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fc3Vidmlld3Mpe1xuICAgICAgICAgIGludm9rZU1hcChmbGF0dGVuKHRoaXMuX3N1YnZpZXdzKSwgJ3JlbW92ZScpO1xuICAgICAgICAgIHRoaXMuX3N1YnZpZXdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHRoaXMuYmluZGluZ3NTZXQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX3Vwc2VydEJpbmRpbmdzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgICBhdHRycyA9IGF0dHJzIHx8IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzU2V0KSByZXR1cm47XG4gICAgICAgIHRoaXMuX3BhcnNlZEJpbmRpbmdzID0gYmluZGluZ3ModGhpcy5iaW5kaW5ncywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVCaW5kaW5ncygpO1xuICAgICAgICBpZiAoYXR0cnMuZWwgJiYgIXRoaXMuYXV0b1JlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRWxlbWVudENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVTdWJ2aWV3cygpO1xuICAgICAgICB0aGlzLmJpbmRpbmdzU2V0ID0gdHJ1ZTtcbiAgICB9XG59KTtcblxuVmlldy5wcm90b3R5cGUuX3NldFJlbmRlcihWaWV3LnByb3RvdHlwZSk7XG5WaWV3LnByb3RvdHlwZS5fc2V0UmVtb3ZlKFZpZXcucHJvdG90eXBlKTtcblZpZXcuZXh0ZW5kID0gQmFzZVN0YXRlLmV4dGVuZDtcbm1vZHVsZS5leHBvcnRzID0gVmlldztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2883\n")}}]);