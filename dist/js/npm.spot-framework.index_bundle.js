(window.webpackJsonp=window.webpackJsonp||[]).push([["npm.spot-framework"],{"0056":function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Group = __webpack_require__(/*! ./group */ \"9083\");\n\nfunction setOrdering (groups, ordering) {\n  if (ordering === 'count') {\n    groups.comparator = function (a, b) {\n      if (a.count === b.count) {\n        return a.value < b.value ? -1 : 1;\n      } else {\n        return b.count - a.count;\n      }\n    };\n  } else if (ordering === 'value') {\n    groups.comparator = 'value';\n  } else {\n    console.error('Ordering not implemented for partition: ', ordering);\n  }\n  groups.sort();\n}\n\nmodule.exports = Collection.extend({\n  indexes: ['value', 'label', 'group', 'groupIndex'],\n  model: Group,\n  comparator: 'label',\n  initialize: function (models, options) {\n    var groups = this;\n    var partition = options.parent;\n\n    // update group index on resort\n    this.on('sort', function () {\n      this.forEach(function (group, i) {\n        group.groupIndex = i;\n      });\n    }, this);\n\n    // this.parent := partition\n    if (partition) {\n      setOrdering(groups, partition.ordering);\n\n      partition.on('change ordering', function () {\n        setOrdering(groups, partition.ordering);\n      });\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDA1Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uL2dyb3VwLWNvbGxlY3Rpb24uanM/OGM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuL2dyb3VwJyk7XG5cbmZ1bmN0aW9uIHNldE9yZGVyaW5nIChncm91cHMsIG9yZGVyaW5nKSB7XG4gIGlmIChvcmRlcmluZyA9PT0gJ2NvdW50Jykge1xuICAgIGdyb3Vwcy5jb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhLmNvdW50ID09PSBiLmNvdW50KSB7XG4gICAgICAgIHJldHVybiBhLnZhbHVlIDwgYi52YWx1ZSA/IC0xIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmNvdW50IC0gYS5jb3VudDtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKG9yZGVyaW5nID09PSAndmFsdWUnKSB7XG4gICAgZ3JvdXBzLmNvbXBhcmF0b3IgPSAndmFsdWUnO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoJ09yZGVyaW5nIG5vdCBpbXBsZW1lbnRlZCBmb3IgcGFydGl0aW9uOiAnLCBvcmRlcmluZyk7XG4gIH1cbiAgZ3JvdXBzLnNvcnQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uLmV4dGVuZCh7XG4gIGluZGV4ZXM6IFsndmFsdWUnLCAnbGFiZWwnLCAnZ3JvdXAnLCAnZ3JvdXBJbmRleCddLFxuICBtb2RlbDogR3JvdXAsXG4gIGNvbXBhcmF0b3I6ICdsYWJlbCcsXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgZ3JvdXBzID0gdGhpcztcbiAgICB2YXIgcGFydGl0aW9uID0gb3B0aW9ucy5wYXJlbnQ7XG5cbiAgICAvLyB1cGRhdGUgZ3JvdXAgaW5kZXggb24gcmVzb3J0XG4gICAgdGhpcy5vbignc29ydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXAsIGkpIHtcbiAgICAgICAgZ3JvdXAuZ3JvdXBJbmRleCA9IGk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHRoaXMucGFyZW50IDo9IHBhcnRpdGlvblxuICAgIGlmIChwYXJ0aXRpb24pIHtcbiAgICAgIHNldE9yZGVyaW5nKGdyb3VwcywgcGFydGl0aW9uLm9yZGVyaW5nKTtcblxuICAgICAgcGFydGl0aW9uLm9uKCdjaGFuZ2Ugb3JkZXJpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldE9yZGVyaW5nKGdyb3VwcywgcGFydGl0aW9uLm9yZGVyaW5nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0056\n")},"0112":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar transports = __webpack_require__(/*! ./transports/index */ \"834b\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:socket');\nvar index = __webpack_require__(/*! indexof */ \"3294\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar parseuri = __webpack_require__(/*! parseuri */ \"64a0\");\nvar parsejson = __webpack_require__(/*! parsejson */ \"185c\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"914f\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket (uri, opts) {\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure\n    : (global.location && 'https:' === location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port\n      ? location.port\n      : (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.prevBufferLen = 0;\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;\n  this.forceNode = !!opts.forceNode;\n\n  // other options for Node.js client\n  var freeGlobal = typeof global === 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n\n    if (opts.localAddress) {\n      this.localAddress = opts.localAddress;\n    }\n  }\n\n  // set on handshake\n  this.id = null;\n  this.upgrades = null;\n  this.pingInterval = null;\n  this.pingTimeout = null;\n\n  // set on heartbeat\n  this.pingIntervalTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = __webpack_require__(/*! ./transport */ \"0d97\");\nSocket.transports = __webpack_require__(/*! ./transports/index */ \"834b\");\nSocket.parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    agent: this.agent,\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    jsonp: this.jsonp,\n    forceBase64: this.forceBase64,\n    enablesXDR: this.enablesXDR,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    policyPort: this.policyPort,\n    socket: this,\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    rejectUnauthorized: this.rejectUnauthorized,\n    perMessageDeflate: this.perMessageDeflate,\n    extraHeaders: this.extraHeaders,\n    forceNode: this.forceNode,\n    localAddress: this.localAddress\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function () {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function () {\n    self.onDrain();\n  })\n  .on('packet', function (packet) {\n    self.onPacket(packet);\n  })\n  .on('error', function (e) {\n    self.onError(e);\n  })\n  .on('close', function () {\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 });\n  var failed = false;\n  var self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen () {\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' === msg.type && 'probe' === msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' === self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport () {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  // Handle any error that happens while probing\n  function onerror (err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose () {\n    onerror('transport closed');\n  }\n\n  // When the socket is closed while we're probing\n  function onclose () {\n    onerror('socket closed');\n  }\n\n  // When the socket is upgraded while we're probing\n  function onupgrade (to) {\n    if (transport && to.name !== transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  // Remove all listeners on the transport and on self\n  function cleanup () {\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' === this.readyState || 'open' === this.readyState ||\n      'closing' === this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(parsejson(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if ('closed' === this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' === self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function () {\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function () {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if ('function' === typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function () {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close () {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose () {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade () {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i < j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDExMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzPzM1YjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiB0aGlzLmxvY2FsQWRkcmVzc1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG4gIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0112\n")},"02ef":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar crossfilter_identity = __webpack_require__(/*! ./identity */ "55a3");\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nmodule.exports = bisect_by(crossfilter_identity);\nmodule.exports.by = bisect_by; // assign the raw function to the export as well\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDJlZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9iaXNlY3QuanM/MDgyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjcm9zc2ZpbHRlcl9pZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuZnVuY3Rpb24gYmlzZWN0X2J5KGYpIHtcblxuICAvLyBMb2NhdGUgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgeCBpbiBhIHRvIG1haW50YWluIHNvcnRlZCBvcmRlci4gVGhlXG4gIC8vIGFyZ3VtZW50cyBsbyBhbmQgaGkgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeSBhIHN1YnNldCBvZiB0aGUgYXJyYXkgd2hpY2hcbiAgLy8gc2hvdWxkIGJlIGNvbnNpZGVyZWQ7IGJ5IGRlZmF1bHQgdGhlIGVudGlyZSBhcnJheSBpcyB1c2VkLiBJZiB4IGlzIGFscmVhZHlcbiAgLy8gcHJlc2VudCBpbiBhLCB0aGUgaW5zZXJ0aW9uIHBvaW50IHdpbGwgYmUgYmVmb3JlICh0byB0aGUgbGVmdCBvZikgYW55XG4gIC8vIGV4aXN0aW5nIGVudHJpZXMuIFRoZSByZXR1cm4gdmFsdWUgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgZmlyc3RcbiAgLy8gYXJndW1lbnQgdG8gYGFycmF5LnNwbGljZWAgYXNzdW1pbmcgdGhhdCBhIGlzIGFscmVhZHkgc29ydGVkLlxuICAvL1xuICAvLyBUaGUgcmV0dXJuZWQgaW5zZXJ0aW9uIHBvaW50IGkgcGFydGl0aW9ucyB0aGUgYXJyYXkgYSBpbnRvIHR3byBoYWx2ZXMgc29cbiAgLy8gdGhhdCBhbGwgdiA8IHggZm9yIHYgaW4gYVtsbzppXSBmb3IgdGhlIGxlZnQgc2lkZSBhbmQgYWxsIHYgPj0geCBmb3IgdiBpblxuICAvLyBhW2k6aGldIGZvciB0aGUgcmlnaHQgc2lkZS5cbiAgZnVuY3Rpb24gYmlzZWN0TGVmdChhLCB4LCBsbywgaGkpIHtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICBpZiAoZihhW21pZF0pIDwgeCkgbG8gPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgLy8gU2ltaWxhciB0byBiaXNlY3RMZWZ0LCBidXQgcmV0dXJucyBhbiBpbnNlcnRpb24gcG9pbnQgd2hpY2ggY29tZXMgYWZ0ZXIgKHRvXG4gIC8vIHRoZSByaWdodCBvZikgYW55IGV4aXN0aW5nIGVudHJpZXMgb2YgeCBpbiBhLlxuICAvL1xuICAvLyBUaGUgcmV0dXJuZWQgaW5zZXJ0aW9uIHBvaW50IGkgcGFydGl0aW9ucyB0aGUgYXJyYXkgaW50byB0d28gaGFsdmVzIHNvIHRoYXRcbiAgLy8gYWxsIHYgPD0geCBmb3IgdiBpbiBhW2xvOmldIGZvciB0aGUgbGVmdCBzaWRlIGFuZCBhbGwgdiA+IHggZm9yIHYgaW5cbiAgLy8gYVtpOmhpXSBmb3IgdGhlIHJpZ2h0IHNpZGUuXG4gIGZ1bmN0aW9uIGJpc2VjdFJpZ2h0KGEsIHgsIGxvLCBoaSkge1xuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgIGlmICh4IDwgZihhW21pZF0pKSBoaSA9IG1pZDtcbiAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBiaXNlY3RSaWdodC5yaWdodCA9IGJpc2VjdFJpZ2h0O1xuICBiaXNlY3RSaWdodC5sZWZ0ID0gYmlzZWN0TGVmdDtcbiAgcmV0dXJuIGJpc2VjdFJpZ2h0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJpc2VjdF9ieShjcm9zc2ZpbHRlcl9pZGVudGl0eSk7XG5tb2R1bGUuZXhwb3J0cy5ieSA9IGJpc2VjdF9ieTsgLy8gYXNzaWduIHRoZSByYXcgZnVuY3Rpb24gdG8gdGhlIGV4cG9ydCBhcyB3ZWxsXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///02ef\n')},"072d":function(module,exports){eval("/**\n * Server side filtering\n *\n * Implementation of a dataset backed by a server, which in turn uses fi. postgreSQL\n * Fully asynchronous, based on socketIO.\n *\n * Most methods below result in a message with the methodName and a data object, containing:\n *  * `datasets` and `dataview`, or `dataset`\n *  * `filterId` or `facetId`\n *\n * Data can be requested using the dataview.getData() method\n * responds with a `newData` message containing `filterId` and `data`.\n *\n * @module driver/server\n */\n\n/**\n * Autoconfigure a dataset\n *\n * @param {Dataset} dataset\n */\nfunction scan (dataset) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  if (spot.isLockedDown) {\n    // spot-server will not respond so no use requesting a scan\n    return;\n  }\n\n  spot.socket.emit('scanData', {\n    dataset: dataset.toJSON()\n  });\n}\n\n/**\n * setMinMax sets the range of a continuous or time facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setMinMax (dataset, facet) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  if (spot.isLockedDown) {\n    spot.socket.emit('setMinMax', {\n      datasetId: dataset.getId(),\n      facetId: facet.getId()\n    });\n  } else {\n    spot.socket.emit('setMinMax', {\n      datasetId: dataset.getId(),\n      dataset: dataset.toJSON(),\n      facetId: facet.getId()\n    });\n  }\n}\n\n/**\n * setCategories finds finds all values on an ordinal (categorial) axis\n * Updates the categorialTransform of the facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setCategories (dataset, facet) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  facet.categorialTransform.rules.reset();\n  if (spot.isLockedDown) {\n    spot.socket.emit('setCategories', {\n      datasetId: dataset.getId(),\n      facetId: facet.getId()\n    });\n  } else {\n    spot.socket.emit('setCategories', {\n      datasetId: dataset.getId(),\n      dataset: dataset.toJSON(),\n      facetId: facet.getId()\n    });\n  }\n}\n\n/**\n * Calculate 100 percentiles (ie. 1,2,3,4 etc.), and initialize the `facet.continuousTransform`\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setPercentiles (dataset, facet) {\n  // Dataset -> Datasets -> Spot\n  var spot = dataset.collection.parent;\n\n  if (spot.isLockedDown) {\n    spot.socket.emit('setPercentiles', {\n      datasetId: dataset.getId(),\n      facetId: facet.getId()\n    });\n  } else {\n    spot.socket.emit('setPercentiles', {\n      datasetId: dataset.getId(),\n      dataset: dataset.toJSON(),\n      facetId: facet.getId()\n    });\n  }\n}\n\n/**\n * Initialize the data filter, and construct the getData callback function on the filter.\n * @param {Dataview} dataview\n * @param {Filter} filter\n */\nfunction initDataFilter (dataview, filter) {\n  // as the SQL server implementation is stateless, nothing to do here\n}\n\n/**\n * The opposite or initDataFilter, it should remove the filter and deallocate other configuration\n * related to the filter.\n * @param {Filter} filter\n */\nfunction releaseDataFilter (filter) {\n  // as the SQL server implementation is stateless, nothing to do here\n}\n\n/**\n * Change the filter parameters for an initialized filter\n * @param {Filter} filter\n */\nfunction updateDataFilter (filter) {\n  // as the SQL server implementation is stateless, nothing to do here\n}\n\n/**\n * Get data for every filter, and trigger a 'newData' event\n *\n * Returns a Promise that resolves to the dataview when all data and metadata has been updated\n *\n * @param {Dataview} dataview\n * @returns {Promise}\n */\nfunction getData (dataview) {\n  var spot = dataview.parent;\n\n  return new Promise(function (resolve, reject) {\n    if (spot.isLockedDown) {\n      spot.socket.emit('getData', {\n        dataview: dataview.toJSON()\n      });\n    } else {\n      spot.socket.emit('getData', {\n        datasets: spot.cachedDatasets,\n        dataview: dataview.toJSON()\n      });\n    }\n\n    dataview.once('newMetaData', function () {\n      resolve(dataview);\n    });\n  });\n}\n\nmodule.exports = {\n  driverType: 'server',\n  scan: scan,\n  setMinMax: setMinMax,\n  setCategories: setCategories,\n  setPercentiles: setPercentiles,\n  initDataFilter: initDataFilter,\n  releaseDataFilter: releaseDataFilter,\n  updateDataFilter: updateDataFilter,\n  getData: getData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDcyZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZHJpdmVyL3NlcnZlci5qcz9lMzc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2VydmVyIHNpZGUgZmlsdGVyaW5nXG4gKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBkYXRhc2V0IGJhY2tlZCBieSBhIHNlcnZlciwgd2hpY2ggaW4gdHVybiB1c2VzIGZpLiBwb3N0Z3JlU1FMXG4gKiBGdWxseSBhc3luY2hyb25vdXMsIGJhc2VkIG9uIHNvY2tldElPLlxuICpcbiAqIE1vc3QgbWV0aG9kcyBiZWxvdyByZXN1bHQgaW4gYSBtZXNzYWdlIHdpdGggdGhlIG1ldGhvZE5hbWUgYW5kIGEgZGF0YSBvYmplY3QsIGNvbnRhaW5pbmc6XG4gKiAgKiBgZGF0YXNldHNgIGFuZCBgZGF0YXZpZXdgLCBvciBgZGF0YXNldGBcbiAqICAqIGBmaWx0ZXJJZGAgb3IgYGZhY2V0SWRgXG4gKlxuICogRGF0YSBjYW4gYmUgcmVxdWVzdGVkIHVzaW5nIHRoZSBkYXRhdmlldy5nZXREYXRhKCkgbWV0aG9kXG4gKiByZXNwb25kcyB3aXRoIGEgYG5ld0RhdGFgIG1lc3NhZ2UgY29udGFpbmluZyBgZmlsdGVySWRgIGFuZCBgZGF0YWAuXG4gKlxuICogQG1vZHVsZSBkcml2ZXIvc2VydmVyXG4gKi9cblxuLyoqXG4gKiBBdXRvY29uZmlndXJlIGEgZGF0YXNldFxuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICovXG5mdW5jdGlvbiBzY2FuIChkYXRhc2V0KSB7XG4gIC8vIERhdGFzZXQgLT4gRGF0YXNldHMgLT4gU3BvdFxuICB2YXIgc3BvdCA9IGRhdGFzZXQuY29sbGVjdGlvbi5wYXJlbnQ7XG5cbiAgaWYgKHNwb3QuaXNMb2NrZWREb3duKSB7XG4gICAgLy8gc3BvdC1zZXJ2ZXIgd2lsbCBub3QgcmVzcG9uZCBzbyBubyB1c2UgcmVxdWVzdGluZyBhIHNjYW5cbiAgICByZXR1cm47XG4gIH1cblxuICBzcG90LnNvY2tldC5lbWl0KCdzY2FuRGF0YScsIHtcbiAgICBkYXRhc2V0OiBkYXRhc2V0LnRvSlNPTigpXG4gIH0pO1xufVxuXG4vKipcbiAqIHNldE1pbk1heCBzZXRzIHRoZSByYW5nZSBvZiBhIGNvbnRpbnVvdXMgb3IgdGltZSBmYWNldFxuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqL1xuZnVuY3Rpb24gc2V0TWluTWF4IChkYXRhc2V0LCBmYWNldCkge1xuICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgdmFyIHNwb3QgPSBkYXRhc2V0LmNvbGxlY3Rpb24ucGFyZW50O1xuXG4gIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldE1pbk1heCcsIHtcbiAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5nZXRJZCgpLFxuICAgICAgZmFjZXRJZDogZmFjZXQuZ2V0SWQoKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldE1pbk1heCcsIHtcbiAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5nZXRJZCgpLFxuICAgICAgZGF0YXNldDogZGF0YXNldC50b0pTT04oKSxcbiAgICAgIGZhY2V0SWQ6IGZhY2V0LmdldElkKClcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIHNldENhdGVnb3JpZXMgZmluZHMgZmluZHMgYWxsIHZhbHVlcyBvbiBhbiBvcmRpbmFsIChjYXRlZ29yaWFsKSBheGlzXG4gKiBVcGRhdGVzIHRoZSBjYXRlZ29yaWFsVHJhbnNmb3JtIG9mIHRoZSBmYWNldFxuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqL1xuZnVuY3Rpb24gc2V0Q2F0ZWdvcmllcyAoZGF0YXNldCwgZmFjZXQpIHtcbiAgLy8gRGF0YXNldCAtPiBEYXRhc2V0cyAtPiBTcG90XG4gIHZhciBzcG90ID0gZGF0YXNldC5jb2xsZWN0aW9uLnBhcmVudDtcblxuICBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJ1bGVzLnJlc2V0KCk7XG4gIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldENhdGVnb3JpZXMnLCB7XG4gICAgICBkYXRhc2V0SWQ6IGRhdGFzZXQuZ2V0SWQoKSxcbiAgICAgIGZhY2V0SWQ6IGZhY2V0LmdldElkKClcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzcG90LnNvY2tldC5lbWl0KCdzZXRDYXRlZ29yaWVzJywge1xuICAgICAgZGF0YXNldElkOiBkYXRhc2V0LmdldElkKCksXG4gICAgICBkYXRhc2V0OiBkYXRhc2V0LnRvSlNPTigpLFxuICAgICAgZmFjZXRJZDogZmFjZXQuZ2V0SWQoKVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIDEwMCBwZXJjZW50aWxlcyAoaWUuIDEsMiwzLDQgZXRjLiksIGFuZCBpbml0aWFsaXplIHRoZSBgZmFjZXQuY29udGludW91c1RyYW5zZm9ybWBcbiAqXG4gKiBAcGFyYW0ge0RhdGFzZXR9IGRhdGFzZXRcbiAqIEBwYXJhbSB7RmFjZXR9IGZhY2V0XG4gKi9cbmZ1bmN0aW9uIHNldFBlcmNlbnRpbGVzIChkYXRhc2V0LCBmYWNldCkge1xuICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgdmFyIHNwb3QgPSBkYXRhc2V0LmNvbGxlY3Rpb24ucGFyZW50O1xuXG4gIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgIHNwb3Quc29ja2V0LmVtaXQoJ3NldFBlcmNlbnRpbGVzJywge1xuICAgICAgZGF0YXNldElkOiBkYXRhc2V0LmdldElkKCksXG4gICAgICBmYWNldElkOiBmYWNldC5nZXRJZCgpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3BvdC5zb2NrZXQuZW1pdCgnc2V0UGVyY2VudGlsZXMnLCB7XG4gICAgICBkYXRhc2V0SWQ6IGRhdGFzZXQuZ2V0SWQoKSxcbiAgICAgIGRhdGFzZXQ6IGRhdGFzZXQudG9KU09OKCksXG4gICAgICBmYWNldElkOiBmYWNldC5nZXRJZCgpXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBkYXRhIGZpbHRlciwgYW5kIGNvbnN0cnVjdCB0aGUgZ2V0RGF0YSBjYWxsYmFjayBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyLlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gaW5pdERhdGFGaWx0ZXIgKGRhdGF2aWV3LCBmaWx0ZXIpIHtcbiAgLy8gYXMgdGhlIFNRTCBzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaXMgc3RhdGVsZXNzLCBub3RoaW5nIHRvIGRvIGhlcmVcbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb3IgaW5pdERhdGFGaWx0ZXIsIGl0IHNob3VsZCByZW1vdmUgdGhlIGZpbHRlciBhbmQgZGVhbGxvY2F0ZSBvdGhlciBjb25maWd1cmF0aW9uXG4gKiByZWxhdGVkIHRvIHRoZSBmaWx0ZXIuXG4gKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VEYXRhRmlsdGVyIChmaWx0ZXIpIHtcbiAgLy8gYXMgdGhlIFNRTCBzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaXMgc3RhdGVsZXNzLCBub3RoaW5nIHRvIGRvIGhlcmVcbn1cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGZpbHRlciBwYXJhbWV0ZXJzIGZvciBhbiBpbml0aWFsaXplZCBmaWx0ZXJcbiAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGF0YUZpbHRlciAoZmlsdGVyKSB7XG4gIC8vIGFzIHRoZSBTUUwgc2VydmVyIGltcGxlbWVudGF0aW9uIGlzIHN0YXRlbGVzcywgbm90aGluZyB0byBkbyBoZXJlXG59XG5cbi8qKlxuICogR2V0IGRhdGEgZm9yIGV2ZXJ5IGZpbHRlciwgYW5kIHRyaWdnZXIgYSAnbmV3RGF0YScgZXZlbnRcbiAqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkYXRhdmlldyB3aGVuIGFsbCBkYXRhIGFuZCBtZXRhZGF0YSBoYXMgYmVlbiB1cGRhdGVkXG4gKlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhdmlldykge1xuICB2YXIgc3BvdCA9IGRhdGF2aWV3LnBhcmVudDtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChzcG90LmlzTG9ja2VkRG93bikge1xuICAgICAgc3BvdC5zb2NrZXQuZW1pdCgnZ2V0RGF0YScsIHtcbiAgICAgICAgZGF0YXZpZXc6IGRhdGF2aWV3LnRvSlNPTigpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BvdC5zb2NrZXQuZW1pdCgnZ2V0RGF0YScsIHtcbiAgICAgICAgZGF0YXNldHM6IHNwb3QuY2FjaGVkRGF0YXNldHMsXG4gICAgICAgIGRhdGF2aWV3OiBkYXRhdmlldy50b0pTT04oKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGF0YXZpZXcub25jZSgnbmV3TWV0YURhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKGRhdGF2aWV3KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcml2ZXJUeXBlOiAnc2VydmVyJyxcbiAgc2Nhbjogc2NhbixcbiAgc2V0TWluTWF4OiBzZXRNaW5NYXgsXG4gIHNldENhdGVnb3JpZXM6IHNldENhdGVnb3JpZXMsXG4gIHNldFBlcmNlbnRpbGVzOiBzZXRQZXJjZW50aWxlcyxcbiAgaW5pdERhdGFGaWx0ZXI6IGluaXREYXRhRmlsdGVyLFxuICByZWxlYXNlRGF0YUZpbHRlcjogcmVsZWFzZURhdGFGaWx0ZXIsXG4gIHVwZGF0ZURhdGFGaWx0ZXI6IHVwZGF0ZURhdGFGaWx0ZXIsXG4gIGdldERhdGE6IGdldERhdGFcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///072d\n")},"09c5":function(module,exports,__webpack_require__){eval("/**\n * A single control point for a continuous transform\n *\n * @class ControlPoint\n */\nvar BaseModel = __webpack_require__(/*! ../util/base */ \"3902\");\n\n// Data structure for mapping categorial (and textual) data on groups\nmodule.exports = BaseModel.extend({\n  props: {\n    /**\n     * Value\n     * @type {number}\n     * @memberof! ContinuousRule\n     */\n    x: 'number',\n\n    /**\n     * Transformed value\n     * @type {number}\n     * @memberof! ContinuousRule\n     */\n    fx: 'number'\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDljNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY29udHJvbC1wb2ludC5qcz82OTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzaW5nbGUgY29udHJvbCBwb2ludCBmb3IgYSBjb250aW51b3VzIHRyYW5zZm9ybVxuICpcbiAqIEBjbGFzcyBDb250cm9sUG9pbnRcbiAqL1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4uL3V0aWwvYmFzZScpO1xuXG4vLyBEYXRhIHN0cnVjdHVyZSBmb3IgbWFwcGluZyBjYXRlZ29yaWFsIChhbmQgdGV4dHVhbCkgZGF0YSBvbiBncm91cHNcbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogVmFsdWVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1J1bGVcbiAgICAgKi9cbiAgICB4OiAnbnVtYmVyJyxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybWVkIHZhbHVlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIENvbnRpbnVvdXNSdWxlXG4gICAgICovXG4gICAgZng6ICdudW1iZXInXG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///09c5\n")},"0b10":function(module,exports){eval("/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGIxMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/YjZlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwXG52YXIgbSA9IHMgKiA2MFxudmFyIGggPSBtICogNjBcbnZhciBkID0gaCAqIDI0XG52YXIgeSA9IGQgKiAzNjUuMjVcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0b10\n")},"0d97":function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n  this.forceNode = opts.forceNode;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n  this.localAddress = opts.localAddress;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' === this.readyState || '' === this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function (packets) {\n  if ('open' === this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGQ5Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzPzMxMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0d97\n")},"0fc4":function(module,exports){eval('if (typeof Uint8Array !== "undefined") {\n  var crossfilter_array8 = function(n) { return new Uint8Array(n); };\n  var crossfilter_array16 = function(n) { return new Uint16Array(n); };\n  var crossfilter_array32 = function(n) { return new Uint32Array(n); };\n\n  var crossfilter_arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  var crossfilter_arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = crossfilter_array16(array.length); break;\n      case 32: copy = crossfilter_array32(array.length); break;\n      default: throw new Error("invalid array width!");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction crossfilter_arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error("invalid array width!");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction crossfilter_bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = crossfilter_array8(n);\n}\n\ncrossfilter_bitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = crossfilter_arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\ncrossfilter_bitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    one = ~m & -~m;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = crossfilter_arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = crossfilter_array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\ncrossfilter_bitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\ncrossfilter_bitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n    this[i].length = n;\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\ncrossfilter_bitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\ncrossfilter_bitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given indez are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\ncrossfilter_bitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\ncrossfilter_bitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\ncrossfilter_bitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask &= zero;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = {\n  array8: crossfilter_arrayUntyped,\n  array16: crossfilter_arrayUntyped,\n  array32: crossfilter_arrayUntyped,\n  arrayLengthen: crossfilter_arrayLengthenUntyped,\n  arrayWiden: crossfilter_arrayWidenUntyped,\n  bitarray: crossfilter_bitarray\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGZjNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9hcnJheS5qcz9iNjc0Il0sInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgY3Jvc3NmaWx0ZXJfYXJyYXk4ID0gZnVuY3Rpb24obikgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobik7IH07XG4gIHZhciBjcm9zc2ZpbHRlcl9hcnJheTE2ID0gZnVuY3Rpb24obikgeyByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG4pOyB9O1xuICB2YXIgY3Jvc3NmaWx0ZXJfYXJyYXkzMiA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG5ldyBVaW50MzJBcnJheShuKTsgfTtcblxuICB2YXIgY3Jvc3NmaWx0ZXJfYXJyYXlMZW5ndGhlbiA9IGZ1bmN0aW9uKGFycmF5LCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID49IGxlbmd0aCkgcmV0dXJuIGFycmF5O1xuICAgIHZhciBjb3B5ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG4gICAgY29weS5zZXQoYXJyYXkpO1xuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIHZhciBjcm9zc2ZpbHRlcl9hcnJheVdpZGVuID0gZnVuY3Rpb24oYXJyYXksIHdpZHRoKSB7XG4gICAgdmFyIGNvcHk7XG4gICAgc3dpdGNoICh3aWR0aCkge1xuICAgICAgY2FzZSAxNjogY29weSA9IGNyb3NzZmlsdGVyX2FycmF5MTYoYXJyYXkubGVuZ3RoKTsgYnJlYWs7XG4gICAgICBjYXNlIDMyOiBjb3B5ID0gY3Jvc3NmaWx0ZXJfYXJyYXkzMihhcnJheS5sZW5ndGgpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgd2lkdGghXCIpO1xuICAgIH1cbiAgICBjb3B5LnNldChhcnJheSk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2FycmF5VW50eXBlZChuKSB7XG4gIHZhciBhcnJheSA9IG5ldyBBcnJheShuKSwgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgbikgYXJyYXlbaV0gPSAwO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2FycmF5TGVuZ3RoZW5VbnR5cGVkKGFycmF5LCBsZW5ndGgpIHtcbiAgdmFyIG4gPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChuIDwgbGVuZ3RoKSBhcnJheVtuKytdID0gMDtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9hcnJheVdpZGVuVW50eXBlZChhcnJheSwgd2lkdGgpIHtcbiAgaWYgKHdpZHRoID4gMzIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgd2lkdGghXCIpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIEFuIGFyYml0cmFyaWx5LXdpZGUgYXJyYXkgb2YgYml0bWFza3NcbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2JpdGFycmF5KG4pIHtcbiAgdGhpcy5sZW5ndGggPSBuO1xuICB0aGlzLnN1YmFycmF5cyA9IDE7XG4gIHRoaXMud2lkdGggPSA4O1xuICB0aGlzLm1hc2tzID0ge1xuICAgIDA6IDBcbiAgfVxuXG4gIHRoaXNbMF0gPSBjcm9zc2ZpbHRlcl9hcnJheTgobik7XG59XG5cbmNyb3NzZmlsdGVyX2JpdGFycmF5LnByb3RvdHlwZS5sZW5ndGhlbiA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5zdWJhcnJheXM7IGkgPCBsZW47ICsraSkge1xuICAgIHRoaXNbaV0gPSBjcm9zc2ZpbHRlcl9hcnJheUxlbmd0aGVuKHRoaXNbaV0sIG4pO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gbjtcbn07XG5cbi8vIFJlc2VydmUgYSBuZXcgYml0IGluZGV4IGluIHRoZSBhcnJheSwgcmV0dXJucyB7b2Zmc2V0LCBvbmV9XG5jcm9zc2ZpbHRlcl9iaXRhcnJheS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtLCB3LCBvbmUsIGksIGxlbjtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnN1YmFycmF5czsgaSA8IGxlbjsgKytpKSB7XG4gICAgbSA9IHRoaXMubWFza3NbaV07XG4gICAgdyA9IHRoaXMud2lkdGggLSAoMzIgKiBpKTtcbiAgICBvbmUgPSB+bSAmIC1+bTtcblxuICAgIGlmICh3ID49IDMyICYmICFvbmUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh3IDwgMzIgJiYgKG9uZSAmICgxIDw8IHcpKSkge1xuICAgICAgLy8gd2lkZW4gdGhpcyBzdWJhcnJheVxuICAgICAgdGhpc1tpXSA9IGNyb3NzZmlsdGVyX2FycmF5V2lkZW4odGhpc1tpXSwgdyA8PD0gMSk7XG4gICAgICB0aGlzLndpZHRoID0gMzIgKiBpICsgdztcbiAgICB9XG5cbiAgICB0aGlzLm1hc2tzW2ldIHw9IG9uZTtcblxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IGksXG4gICAgICBvbmU6IG9uZVxuICAgIH07XG4gIH1cblxuICAvLyBhZGQgYSBuZXcgc3ViYXJyYXlcbiAgdGhpc1t0aGlzLnN1YmFycmF5c10gPSBjcm9zc2ZpbHRlcl9hcnJheTgodGhpcy5sZW5ndGgpO1xuICB0aGlzLm1hc2tzW3RoaXMuc3ViYXJyYXlzXSA9IDE7XG4gIHRoaXMud2lkdGggKz0gODtcbiAgcmV0dXJuIHtcbiAgICBvZmZzZXQ6IHRoaXMuc3ViYXJyYXlzKyssXG4gICAgb25lOiAxXG4gIH07XG59O1xuXG4vLyBDb3B5IHJlY29yZCBmcm9tIGluZGV4IHNyYyB0byBpbmRleCBkZXN0XG5jcm9zc2ZpbHRlcl9iaXRhcnJheS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGRlc3QsIHNyYykge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnN1YmFycmF5czsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGhpc1tpXVtkZXN0XSA9IHRoaXNbaV1bc3JjXTtcbiAgfVxufTtcblxuLy8gVHJ1bmNhdGUgdGhlIGFycmF5IHRvIHRoZSBnaXZlbiBsZW5ndGhcbmNyb3NzZmlsdGVyX2JpdGFycmF5LnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5zdWJhcnJheXM7IGkgPCBsZW47ICsraSkge1xuICAgIGZvciAodmFyIGogPSB0aGlzLmxlbmd0aCAtIDE7IGogPj0gbjsgai0tKSB7XG4gICAgICB0aGlzW2ldW2pdID0gMDtcbiAgICB9XG4gICAgdGhpc1tpXS5sZW5ndGggPSBuO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gbjtcbn07XG5cbi8vIENoZWNrcyB0aGF0IGFsbCBiaXRzIGZvciB0aGUgZ2l2ZW4gaW5kZXggYXJlIDBcbmNyb3NzZmlsdGVyX2JpdGFycmF5LnByb3RvdHlwZS56ZXJvID0gZnVuY3Rpb24obikge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnN1YmFycmF5czsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNbaV1bbl0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBDaGVja3MgdGhhdCBhbGwgYml0cyBmb3IgdGhlIGdpdmVuIGluZGV4IGFyZSAwIGV4Y2VwdCBmb3IgcG9zc2libHkgb25lXG5jcm9zc2ZpbHRlcl9iaXRhcnJheS5wcm90b3R5cGUuemVyb0V4Y2VwdCA9IGZ1bmN0aW9uKG4sIG9mZnNldCwgemVybykge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnN1YmFycmF5czsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGkgPT09IG9mZnNldCA/IHRoaXNbaV1bbl0gJiB6ZXJvIDogdGhpc1tpXVtuXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIENoZWNrcyB0aGF0IGFsbCBiaXRzIGZvciB0aGUgZ2l2ZW4gaW5kZXogYXJlIDAgZXhjZXB0IGZvciB0aGUgc3BlY2lmaWVkIG1hc2suXG4vLyBUaGUgbWFzayBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZmlsdGVyIHN1YmFycmF5cyB3aWR0aC5cbmNyb3NzZmlsdGVyX2JpdGFycmF5LnByb3RvdHlwZS56ZXJvRXhjZXB0TWFzayA9IGZ1bmN0aW9uKG4sIG1hc2spIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5zdWJhcnJheXM7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzW2ldW25dICYgbWFza1tpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgb25seSB0aGUgc3BlY2lmaWVkIGJpdCBpcyBzZXQgZm9yIHRoZSBnaXZlbiBpbmRleFxuY3Jvc3NmaWx0ZXJfYml0YXJyYXkucHJvdG90eXBlLm9ubHkgPSBmdW5jdGlvbihuLCBvZmZzZXQsIG9uZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnN1YmFycmF5czsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNbaV1bbl0gIT0gKGkgPT09IG9mZnNldCA/IG9uZSA6IDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQ2hlY2tzIHRoYXQgb25seSB0aGUgc3BlY2lmaWVkIGJpdCBpcyBzZXQgZm9yIHRoZSBnaXZlbiBpbmRleCBleGNlcHQgZm9yIHBvc3NpYmx5IG9uZSBvdGhlclxuY3Jvc3NmaWx0ZXJfYml0YXJyYXkucHJvdG90eXBlLm9ubHlFeGNlcHQgPSBmdW5jdGlvbihuLCBvZmZzZXQsIHplcm8sIG9ubHlPZmZzZXQsIG9ubHlPbmUpIHtcbiAgdmFyIG1hc2s7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuc3ViYXJyYXlzOyBpIDwgbGVuOyArK2kpIHtcbiAgICBtYXNrID0gdGhpc1tpXVtuXTtcbiAgICBpZiAoaSA9PT0gb2Zmc2V0KVxuICAgICAgbWFzayAmPSB6ZXJvO1xuICAgIGlmIChtYXNrICE9IChpID09PSBvbmx5T2Zmc2V0ID8gb25seU9uZSA6IDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5ODogY3Jvc3NmaWx0ZXJfYXJyYXlVbnR5cGVkLFxuICBhcnJheTE2OiBjcm9zc2ZpbHRlcl9hcnJheVVudHlwZWQsXG4gIGFycmF5MzI6IGNyb3NzZmlsdGVyX2FycmF5VW50eXBlZCxcbiAgYXJyYXlMZW5ndGhlbjogY3Jvc3NmaWx0ZXJfYXJyYXlMZW5ndGhlblVudHlwZWQsXG4gIGFycmF5V2lkZW46IGNyb3NzZmlsdGVyX2FycmF5V2lkZW5VbnR5cGVkLFxuICBiaXRhcnJheTogY3Jvc3NmaWx0ZXJfYml0YXJyYXlcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0fc4\n')},"108d":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"86e3\");\nvar Polling = __webpack_require__(/*! ./polling */ \"181d\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty () {}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR (opts) {\n  Polling.call(this, opts);\n  this.requestTimeout = opts.requestTimeout;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname !== global.location.hostname ||\n      port !== opts.port;\n    this.xs = opts.secure !== isSSL;\n  } else {\n    this.extraHeaders = opts.extraHeaders;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function (opts) {\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  opts.requestTimeout = this.requestTimeout;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function (data, fn) {\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function (err) {\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function () {\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function (data) {\n    self.onData(data);\n  });\n  req.on('error', function (err) {\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request (opts) {\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined !== opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n  this.requestTimeout = opts.requestTimeout;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function () {\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n    if (this.supportsBinary) {\n      // This has to be done after open because Firefox is stupid\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n      xhr.responseType = 'arraybuffer';\n    }\n\n    if ('POST' === this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    try {\n      xhr.setRequestHeader('Accept', '*/*');\n    } catch (e) {}\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.requestTimeout) {\n      xhr.timeout = this.requestTimeout;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function () {\n        self.onLoad();\n      };\n      xhr.onerror = function () {\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        if (4 !== xhr.readyState) return;\n        if (200 === xhr.status || 1223 === xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function () {\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function () {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function () {\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function (data) {\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function (err) {\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function (fromError) {\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch (e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function () {\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response || this.xhr.responseText;\n    } else {\n      if (!this.supportsBinary) {\n        data = this.xhr.responseText;\n      } else {\n        try {\n          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n        } catch (e) {\n          var ui8Arr = new Uint8Array(this.xhr.response);\n          var dataArray = [];\n          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {\n            dataArray.push(ui8Arr[idx]);\n          }\n\n          data = String.fromCharCode.apply(null, dataArray);\n        }\n      }\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function () {\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function () {\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nRequest.requestsCount = 0;\nRequest.requests = {};\n\nif (global.document) {\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler () {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4ZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcz9mYmY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChmcm9tRXJyb3IpIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdmFyIHVpOEFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gdWk4QXJyLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2godWk4QXJyW2lkeF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGFBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///108d\n")},1278:function(module,exports,__webpack_require__){eval("/**\n * Selection\n * @module client/util-selection\n */\nvar misval = __webpack_require__(/*! ./misval */ \"bff6\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\n/*\n * Set a categorial 1D filter function\n * @param {Partition} partition\n */\nfunction filterFunctionCategorial1D (partition) {\n  var haystack = {};\n\n  if (!partition.selected || !partition.selected.length) {\n    partition.groups.forEach(function (group) {\n      haystack[group.value] = true;\n    });\n  } else {\n    partition.selected.forEach(function (h) {\n      haystack[h] = true;\n    });\n  }\n\n  return function (d) {\n    var needle = d;\n    if (!(needle instanceof Array)) {\n      needle = [d];\n    }\n\n    var selected = false;\n    needle.forEach(function (s) {\n      selected = selected | haystack[s];\n    });\n    return !!selected;\n  };\n}\n\n/*\n * Set a text filter function\n * @param {Partition} partition\n */\nfunction filterFunctionText (partition) {\n  var haystack = {};\n\n  // nothing selected, so all selected\n  if (partition.selected.length === 0) {\n    return function () {\n      return true;\n    };\n  }\n\n  partition.selected.forEach(function (h) {\n    haystack[h] = true;\n  });\n\n  return function (d) {\n    var needle = d;\n    if (!(needle instanceof Array)) {\n      needle = [d];\n    }\n\n    var selected = false;\n    needle.forEach(function (s) {\n      selected = selected | haystack[s];\n    });\n    return !!selected;\n  };\n}\n\n/*\n * Set a continuous 1D filter function\n * @param {Partition} partition\n */\nfunction filterFunctionContinuous1D (partition) {\n  var edge = partition.maxval;\n  var min;\n  var max;\n\n  if (!partition.selected || !partition.selected.length) {\n    min = partition.minval;\n    max = partition.maxval;\n    return function (d) {\n      return ((d >= min && d <= max) && (d !== misval));\n    };\n  } else {\n    min = partition.selected[0];\n    max = partition.selected[1];\n    return function (d) {\n      return ((d >= min && d < max) || ((d === edge) && (max === edge))) && (d !== misval);\n    };\n  }\n}\n\n/*\n * Set a continuous 1D filter function on a datetime dimension\n * @param {Partition} partition\n */\nfunction filterFunctionDatetime1D (partition) {\n  var edge = moment(partition.maxval);\n  var min;\n  var max;\n\n  if (!partition.selected || !partition.selected.length) {\n    min = moment(partition.minval);\n    max = moment(partition.maxval);\n\n    return function (d) {\n      var m = moment(d);\n      return (m !== misval) && !m.isBefore(min) && !m.isAfter(max);\n    };\n  } else {\n    min = moment(partition.selected[0]);\n    max = moment(partition.selected[1]);\n    return function (d) {\n      var m = moment(d);\n      return (m !== misval) && !min.isAfter(m) && (m.isBefore(max) || (max.isSame(edge) && max.isSame(m)));\n    };\n  }\n}\n\n/*\n * Set a continuous 1D filter function on a duration dimension\n * @param {Partition} partition\n */\nfunction filterFunctionDuration1D (partition) {\n  var edge = partition.maxval;\n  var min;\n  var max;\n\n  if (!partition.selected || !partition.selected.length) {\n    min = partition.minval;\n    max = partition.maxval;\n\n    return function (d) {\n      if (d === misval) {\n        return false;\n      }\n      var m = moment.duration(d);\n      return moment.isDuration(m) && m >= min && m <= max;\n    };\n  } else {\n    min = moment.duration(partition.selected[0]);\n    max = moment.duration(partition.selected[1]);\n    return function (d) {\n      if (d === misval) {\n        return false;\n      }\n      var m = moment.duration(d);\n      return moment.isDuration(m) && m >= min && (m < max || (m <= max && max >= edge));\n    };\n  }\n}\n\n/**\n * A filter function based for a single partition\n * @function\n * @returns {boolean} selected True if the datapoint is currently selected\n * @param {Partition} partition\n * @param {Object} datapoint\n * @memberof! Selection\n */\nfunction filterFunction (partition) {\n  if (partition.isCategorial || partition.isConstant) {\n    return filterFunctionCategorial1D(partition);\n  } else if (partition.isContinuous) {\n    return filterFunctionContinuous1D(partition);\n  } else if (partition.isDatetime) {\n    return filterFunctionDatetime1D(partition);\n  } else if (partition.isDuration) {\n    return filterFunctionDuration1D(partition);\n  } else if (partition.isText) {\n    return filterFunctionText(partition);\n  } else {\n    console.error('Cannot make filterfunction for partition', partition);\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateCategorial1D (partition, group) {\n  var selected = partition.selected;\n\n  if (selected.length === 0) {\n    // 1. none selected:\n    selected.push(group.value);\n  } else if (selected.length === 1) {\n    if (selected[0] === group.value) {\n      // 2. one selected and the group is the same:\n      selected.splice(0, selected.length);\n      partition.groups.forEach(function (g) {\n        if (g.value !== group.value) {\n          selected.push(g.value);\n        }\n      });\n    } else {\n      // 3. one selected and the group is different:\n      selected.push(group.value);\n    }\n  } else {\n    var i;\n    i = selected.indexOf(group.value);\n    if (i > -1) {\n      // 4. more than one selected and the group is in the selection:\n      selected.splice(i, 1);\n    } else {\n      // 5. more than one selected and the group is not in the selection:\n      selected.push(group.value);\n    }\n  }\n\n  // after add: if filters == groups, reset and dont filter\n  if (selected.length === partition.groups.length) {\n    selected.splice(0, selected.length);\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateText (partition, group) {\n  var selected = partition.selected;\n\n  var i;\n  i = selected.indexOf(group.value);\n  if (i > -1) {\n    // 1. in the selection, remove it\n    selected.splice(i, 1);\n  } else {\n    // 2. not in the selection, add it\n    selected.push(group.value);\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateContinuous1D (partition, group) {\n  var selected = partition.selected;\n\n  if (selected.length === 0) {\n    // nothing selected, start a range\n    selected[0] = group.min;\n    selected[1] = group.max;\n  } else if (group.min >= selected[1]) {\n    // clicked outside to the rigth of selection\n    selected[1] = group.max;\n  } else if (group.max <= selected[0]) {\n    // clicked outside to the left of selection\n    selected[0] = group.min;\n  } else {\n    // clicked inside selection\n    var d1, d2;\n    if (partition.groupLog) {\n      d1 = Math.abs(Math.log(selected[0]) - Math.log(group.min));\n      d2 = Math.abs(Math.log(selected[1]) - Math.log(group.max));\n    } else {\n      d1 = Math.abs(selected[0] - group.min);\n      d2 = Math.abs(selected[1] - group.max);\n    }\n    if (d1 < d2) {\n      selected[0] = group.min;\n    } else {\n      selected[1] = group.max;\n    }\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateDatetime1D (partition, group) {\n  var selected = partition.selected;\n\n  if (!selected || selected.length === 0) {\n    // nothing selected, start a range\n    selected[0] = group.min.toISOString();\n    selected[1] = group.max.toISOString();\n    return;\n  }\n\n  var selectionStart = moment(selected[0]);\n  var selectionEnd = moment(selected[1]);\n\n  if (!group.min.isBefore(selectionEnd)) {\n    // clicked outside to the rigth of selection\n    selected[1] = group.max.toISOString();\n  } else if (!group.max.isAfter(selectionStart)) {\n    // clicked outside to the left of selection\n    selected[0] = group.min.toISOString();\n  } else {\n    // clicked inside selection\n    var d1, d2;\n    d1 = Math.abs(selectionStart.diff(group.min));\n    d2 = Math.abs(selectionEnd.diff(group.max));\n\n    if (d1 < d2) {\n      selected[0] = group.max.toISOString();\n    } else {\n      selected[1] = group.min.toISOString();\n    }\n  }\n}\n\n/*\n * @param {Group} group - The group to add or remove from the filter\n */\nfunction updateDuration1D (partition, group) {\n  var selected = partition.selected;\n\n  if (selected.length === 0) {\n    // nothing selected, start a range\n    selected[0] = group.min.toISOString();\n    selected[1] = group.max.toISOString();\n    return;\n  }\n\n  var selectionStart = moment.duration(selected[0]);\n  var selectionEnd = moment.duration(selected[1]);\n\n  if (group.min >= selectionEnd) {\n    // clicked outside to the rigth of selection\n    selected[1] = group.max.toISOString();\n  } else if (group.max <= selectionStart) {\n    // clicked outside to the left of selection\n    selected[0] = group.min.toISOString();\n  } else {\n    // clicked inside selection\n    var d1, d2;\n    d1 = Math.abs(selectionStart - group.min);\n    d2 = Math.abs(selectionEnd - group.max);\n\n    if (d1 < d2) {\n      selected[0] = group.max.toISOString();\n    } else {\n      selected[1] = group.min.toISOString();\n    }\n  }\n}\n\n/**\n * Update the selection with a given group or interval\n * or, if no group is given, clear the selection.\n *\n * For categorial selections the following rules are used:\n * 1. none selected:\n *    add the group to the selection\n * 2. one selected and the group is the same:\n *    invert the selection\n * 3. one selected and the group is different:\n *    add the group to the selection\n * 4. more than one selected and the group is in the selection:\n *    remove the group from the selection\n * 5. more than one selected and the group is not in the selection:\n *    add the group to the selection\n *\n * For continuous selections the following rules are used:\n * 1. no range selected\n *    set the range equal to that of the group\n * 2. a range selected and the group is outside the selection:\n *    extend the selection to include the group\n * 3. a range selected and the group is inside the selection:\n *    set the endpoint closest to the group to that of the group\n *\n * @function\n * @param {Partition} Partition to update\n * @param {(string|number[])} Group or interval\n */\nfunction updateSelection (partition, group) {\n  if (!group) {\n    // Clear the selection (ie. all points are selected)\n    partition.selected.splice(0, partition.selected.length);\n  } else {\n    // Update the selection\n    if (partition.type === 'categorial' || partition.type === 'constant') {\n      updateCategorial1D(partition, group);\n    } else if (partition.type === 'continuous') {\n      updateContinuous1D(partition, group);\n    } else if (partition.type === 'datetime') {\n      updateDatetime1D(partition, group);\n    } else if (partition.type === 'duration') {\n      updateDuration1D(partition, group);\n    } else if (partition.type === 'text') {\n      updateText(partition, group);\n    } else {\n      console.error('Cannot update selection', partition.type);\n    }\n  }\n}\n\nmodule.exports = {\n  filterFunction: filterFunction,\n  updateSelection: updateSelection\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9zZWxlY3Rpb24uanM/NGY5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlbGVjdGlvblxuICogQG1vZHVsZSBjbGllbnQvdXRpbC1zZWxlY3Rpb25cbiAqL1xudmFyIG1pc3ZhbCA9IHJlcXVpcmUoJy4vbWlzdmFsJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5cbi8qXG4gKiBTZXQgYSBjYXRlZ29yaWFsIDFEIGZpbHRlciBmdW5jdGlvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbkNhdGVnb3JpYWwxRCAocGFydGl0aW9uKSB7XG4gIHZhciBoYXlzdGFjayA9IHt9O1xuXG4gIGlmICghcGFydGl0aW9uLnNlbGVjdGVkIHx8ICFwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgcGFydGl0aW9uLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgaGF5c3RhY2tbZ3JvdXAudmFsdWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0aXRpb24uc2VsZWN0ZWQuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICAgICAgaGF5c3RhY2tbaF0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIG5lZWRsZSA9IGQ7XG4gICAgaWYgKCEobmVlZGxlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBuZWVkbGUgPSBbZF07XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgbmVlZGxlLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQgfCBoYXlzdGFja1tzXTtcbiAgICB9KTtcbiAgICByZXR1cm4gISFzZWxlY3RlZDtcbiAgfTtcbn1cblxuLypcbiAqIFNldCBhIHRleHQgZmlsdGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gcGFydGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uVGV4dCAocGFydGl0aW9uKSB7XG4gIHZhciBoYXlzdGFjayA9IHt9O1xuXG4gIC8vIG5vdGhpbmcgc2VsZWN0ZWQsIHNvIGFsbCBzZWxlY3RlZFxuICBpZiAocGFydGl0aW9uLnNlbGVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcGFydGl0aW9uLnNlbGVjdGVkLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgICBoYXlzdGFja1toXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBuZWVkbGUgPSBkO1xuICAgIGlmICghKG5lZWRsZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgbmVlZGxlID0gW2RdO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgIG5lZWRsZS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkIHwgaGF5c3RhY2tbc107XG4gICAgfSk7XG4gICAgcmV0dXJuICEhc2VsZWN0ZWQ7XG4gIH07XG59XG5cbi8qXG4gKiBTZXQgYSBjb250aW51b3VzIDFEIGZpbHRlciBmdW5jdGlvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbkNvbnRpbnVvdXMxRCAocGFydGl0aW9uKSB7XG4gIHZhciBlZGdlID0gcGFydGl0aW9uLm1heHZhbDtcbiAgdmFyIG1pbjtcbiAgdmFyIG1heDtcblxuICBpZiAoIXBhcnRpdGlvbi5zZWxlY3RlZCB8fCAhcGFydGl0aW9uLnNlbGVjdGVkLmxlbmd0aCkge1xuICAgIG1pbiA9IHBhcnRpdGlvbi5taW52YWw7XG4gICAgbWF4ID0gcGFydGl0aW9uLm1heHZhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAoKGQgPj0gbWluICYmIGQgPD0gbWF4KSAmJiAoZCAhPT0gbWlzdmFsKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtaW4gPSBwYXJ0aXRpb24uc2VsZWN0ZWRbMF07XG4gICAgbWF4ID0gcGFydGl0aW9uLnNlbGVjdGVkWzFdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuICgoZCA+PSBtaW4gJiYgZCA8IG1heCkgfHwgKChkID09PSBlZGdlKSAmJiAobWF4ID09PSBlZGdlKSkpICYmIChkICE9PSBtaXN2YWwpO1xuICAgIH07XG4gIH1cbn1cblxuLypcbiAqIFNldCBhIGNvbnRpbnVvdXMgMUQgZmlsdGVyIGZ1bmN0aW9uIG9uIGEgZGF0ZXRpbWUgZGltZW5zaW9uXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gcGFydGl0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uRGF0ZXRpbWUxRCAocGFydGl0aW9uKSB7XG4gIHZhciBlZGdlID0gbW9tZW50KHBhcnRpdGlvbi5tYXh2YWwpO1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuXG4gIGlmICghcGFydGl0aW9uLnNlbGVjdGVkIHx8ICFwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgbWluID0gbW9tZW50KHBhcnRpdGlvbi5taW52YWwpO1xuICAgIG1heCA9IG1vbWVudChwYXJ0aXRpb24ubWF4dmFsKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIG0gPSBtb21lbnQoZCk7XG4gICAgICByZXR1cm4gKG0gIT09IG1pc3ZhbCkgJiYgIW0uaXNCZWZvcmUobWluKSAmJiAhbS5pc0FmdGVyKG1heCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtaW4gPSBtb21lbnQocGFydGl0aW9uLnNlbGVjdGVkWzBdKTtcbiAgICBtYXggPSBtb21lbnQocGFydGl0aW9uLnNlbGVjdGVkWzFdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBtID0gbW9tZW50KGQpO1xuICAgICAgcmV0dXJuIChtICE9PSBtaXN2YWwpICYmICFtaW4uaXNBZnRlcihtKSAmJiAobS5pc0JlZm9yZShtYXgpIHx8IChtYXguaXNTYW1lKGVkZ2UpICYmIG1heC5pc1NhbWUobSkpKTtcbiAgICB9O1xuICB9XG59XG5cbi8qXG4gKiBTZXQgYSBjb250aW51b3VzIDFEIGZpbHRlciBmdW5jdGlvbiBvbiBhIGR1cmF0aW9uIGRpbWVuc2lvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBmaWx0ZXJGdW5jdGlvbkR1cmF0aW9uMUQgKHBhcnRpdGlvbikge1xuICB2YXIgZWRnZSA9IHBhcnRpdGlvbi5tYXh2YWw7XG4gIHZhciBtaW47XG4gIHZhciBtYXg7XG5cbiAgaWYgKCFwYXJ0aXRpb24uc2VsZWN0ZWQgfHwgIXBhcnRpdGlvbi5zZWxlY3RlZC5sZW5ndGgpIHtcbiAgICBtaW4gPSBwYXJ0aXRpb24ubWludmFsO1xuICAgIG1heCA9IHBhcnRpdGlvbi5tYXh2YWw7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSBtb21lbnQuZHVyYXRpb24oZCk7XG4gICAgICByZXR1cm4gbW9tZW50LmlzRHVyYXRpb24obSkgJiYgbSA+PSBtaW4gJiYgbSA8PSBtYXg7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtaW4gPSBtb21lbnQuZHVyYXRpb24ocGFydGl0aW9uLnNlbGVjdGVkWzBdKTtcbiAgICBtYXggPSBtb21lbnQuZHVyYXRpb24ocGFydGl0aW9uLnNlbGVjdGVkWzFdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSBtb21lbnQuZHVyYXRpb24oZCk7XG4gICAgICByZXR1cm4gbW9tZW50LmlzRHVyYXRpb24obSkgJiYgbSA+PSBtaW4gJiYgKG0gPCBtYXggfHwgKG0gPD0gbWF4ICYmIG1heCA+PSBlZGdlKSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEEgZmlsdGVyIGZ1bmN0aW9uIGJhc2VkIGZvciBhIHNpbmdsZSBwYXJ0aXRpb25cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59IHNlbGVjdGVkIFRydWUgaWYgdGhlIGRhdGFwb2ludCBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhcG9pbnRcbiAqIEBtZW1iZXJvZiEgU2VsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uIChwYXJ0aXRpb24pIHtcbiAgaWYgKHBhcnRpdGlvbi5pc0NhdGVnb3JpYWwgfHwgcGFydGl0aW9uLmlzQ29uc3RhbnQpIHtcbiAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb25DYXRlZ29yaWFsMUQocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNDb250aW51b3VzKSB7XG4gICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uQ29udGludW91czFEKHBhcnRpdGlvbik7XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzRGF0ZXRpbWUpIHtcbiAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb25EYXRldGltZTFEKHBhcnRpdGlvbik7XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzRHVyYXRpb24pIHtcbiAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb25EdXJhdGlvbjFEKHBhcnRpdGlvbik7XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzVGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXJGdW5jdGlvblRleHQocGFydGl0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgbWFrZSBmaWx0ZXJmdW5jdGlvbiBmb3IgcGFydGl0aW9uJywgcGFydGl0aW9uKTtcbiAgfVxufVxuXG4vKlxuICogQHBhcmFtIHtHcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYWRkIG9yIHJlbW92ZSBmcm9tIHRoZSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2F0ZWdvcmlhbDFEIChwYXJ0aXRpb24sIGdyb3VwKSB7XG4gIHZhciBzZWxlY3RlZCA9IHBhcnRpdGlvbi5zZWxlY3RlZDtcblxuICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gMS4gbm9uZSBzZWxlY3RlZDpcbiAgICBzZWxlY3RlZC5wdXNoKGdyb3VwLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoc2VsZWN0ZWRbMF0gPT09IGdyb3VwLnZhbHVlKSB7XG4gICAgICAvLyAyLiBvbmUgc2VsZWN0ZWQgYW5kIHRoZSBncm91cCBpcyB0aGUgc2FtZTpcbiAgICAgIHNlbGVjdGVkLnNwbGljZSgwLCBzZWxlY3RlZC5sZW5ndGgpO1xuICAgICAgcGFydGl0aW9uLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGlmIChnLnZhbHVlICE9PSBncm91cC52YWx1ZSkge1xuICAgICAgICAgIHNlbGVjdGVkLnB1c2goZy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBvbmUgc2VsZWN0ZWQgYW5kIHRoZSBncm91cCBpcyBkaWZmZXJlbnQ6XG4gICAgICBzZWxlY3RlZC5wdXNoKGdyb3VwLnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGk7XG4gICAgaSA9IHNlbGVjdGVkLmluZGV4T2YoZ3JvdXAudmFsdWUpO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIC8vIDQuIG1vcmUgdGhhbiBvbmUgc2VsZWN0ZWQgYW5kIHRoZSBncm91cCBpcyBpbiB0aGUgc2VsZWN0aW9uOlxuICAgICAgc2VsZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyA1LiBtb3JlIHRoYW4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgbm90IGluIHRoZSBzZWxlY3Rpb246XG4gICAgICBzZWxlY3RlZC5wdXNoKGdyb3VwLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBhZnRlciBhZGQ6IGlmIGZpbHRlcnMgPT0gZ3JvdXBzLCByZXNldCBhbmQgZG9udCBmaWx0ZXJcbiAgaWYgKHNlbGVjdGVkLmxlbmd0aCA9PT0gcGFydGl0aW9uLmdyb3Vwcy5sZW5ndGgpIHtcbiAgICBzZWxlY3RlZC5zcGxpY2UoMCwgc2VsZWN0ZWQubGVuZ3RoKTtcbiAgfVxufVxuXG4vKlxuICogQHBhcmFtIHtHcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYWRkIG9yIHJlbW92ZSBmcm9tIHRoZSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlVGV4dCAocGFydGl0aW9uLCBncm91cCkge1xuICB2YXIgc2VsZWN0ZWQgPSBwYXJ0aXRpb24uc2VsZWN0ZWQ7XG5cbiAgdmFyIGk7XG4gIGkgPSBzZWxlY3RlZC5pbmRleE9mKGdyb3VwLnZhbHVlKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIC8vIDEuIGluIHRoZSBzZWxlY3Rpb24sIHJlbW92ZSBpdFxuICAgIHNlbGVjdGVkLnNwbGljZShpLCAxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAyLiBub3QgaW4gdGhlIHNlbGVjdGlvbiwgYWRkIGl0XG4gICAgc2VsZWN0ZWQucHVzaChncm91cC52YWx1ZSk7XG4gIH1cbn1cblxuLypcbiAqIEBwYXJhbSB7R3JvdXB9IGdyb3VwIC0gVGhlIGdyb3VwIHRvIGFkZCBvciByZW1vdmUgZnJvbSB0aGUgZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRpbnVvdXMxRCAocGFydGl0aW9uLCBncm91cCkge1xuICB2YXIgc2VsZWN0ZWQgPSBwYXJ0aXRpb24uc2VsZWN0ZWQ7XG5cbiAgaWYgKHNlbGVjdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIG5vdGhpbmcgc2VsZWN0ZWQsIHN0YXJ0IGEgcmFuZ2VcbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbjtcbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heDtcbiAgfSBlbHNlIGlmIChncm91cC5taW4gPj0gc2VsZWN0ZWRbMV0pIHtcbiAgICAvLyBjbGlja2VkIG91dHNpZGUgdG8gdGhlIHJpZ3RoIG9mIHNlbGVjdGlvblxuICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWF4O1xuICB9IGVsc2UgaWYgKGdyb3VwLm1heCA8PSBzZWxlY3RlZFswXSkge1xuICAgIC8vIGNsaWNrZWQgb3V0c2lkZSB0byB0aGUgbGVmdCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBjbGlja2VkIGluc2lkZSBzZWxlY3Rpb25cbiAgICB2YXIgZDEsIGQyO1xuICAgIGlmIChwYXJ0aXRpb24uZ3JvdXBMb2cpIHtcbiAgICAgIGQxID0gTWF0aC5hYnMoTWF0aC5sb2coc2VsZWN0ZWRbMF0pIC0gTWF0aC5sb2coZ3JvdXAubWluKSk7XG4gICAgICBkMiA9IE1hdGguYWJzKE1hdGgubG9nKHNlbGVjdGVkWzFdKSAtIE1hdGgubG9nKGdyb3VwLm1heCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkMSA9IE1hdGguYWJzKHNlbGVjdGVkWzBdIC0gZ3JvdXAubWluKTtcbiAgICAgIGQyID0gTWF0aC5hYnMoc2VsZWN0ZWRbMV0gLSBncm91cC5tYXgpO1xuICAgIH1cbiAgICBpZiAoZDEgPCBkMikge1xuICAgICAgc2VsZWN0ZWRbMF0gPSBncm91cC5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWF4O1xuICAgIH1cbiAgfVxufVxuXG4vKlxuICogQHBhcmFtIHtHcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYWRkIG9yIHJlbW92ZSBmcm9tIHRoZSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGF0ZXRpbWUxRCAocGFydGl0aW9uLCBncm91cCkge1xuICB2YXIgc2VsZWN0ZWQgPSBwYXJ0aXRpb24uc2VsZWN0ZWQ7XG5cbiAgaWYgKCFzZWxlY3RlZCB8fCBzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBub3RoaW5nIHNlbGVjdGVkLCBzdGFydCBhIHJhbmdlXG4gICAgc2VsZWN0ZWRbMF0gPSBncm91cC5taW4udG9JU09TdHJpbmcoKTtcbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heC50b0lTT1N0cmluZygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb25TdGFydCA9IG1vbWVudChzZWxlY3RlZFswXSk7XG4gIHZhciBzZWxlY3Rpb25FbmQgPSBtb21lbnQoc2VsZWN0ZWRbMV0pO1xuXG4gIGlmICghZ3JvdXAubWluLmlzQmVmb3JlKHNlbGVjdGlvbkVuZCkpIHtcbiAgICAvLyBjbGlja2VkIG91dHNpZGUgdG8gdGhlIHJpZ3RoIG9mIHNlbGVjdGlvblxuICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWF4LnRvSVNPU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAoIWdyb3VwLm1heC5pc0FmdGVyKHNlbGVjdGlvblN0YXJ0KSkge1xuICAgIC8vIGNsaWNrZWQgb3V0c2lkZSB0byB0aGUgbGVmdCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbi50b0lTT1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNsaWNrZWQgaW5zaWRlIHNlbGVjdGlvblxuICAgIHZhciBkMSwgZDI7XG4gICAgZDEgPSBNYXRoLmFicyhzZWxlY3Rpb25TdGFydC5kaWZmKGdyb3VwLm1pbikpO1xuICAgIGQyID0gTWF0aC5hYnMoc2VsZWN0aW9uRW5kLmRpZmYoZ3JvdXAubWF4KSk7XG5cbiAgICBpZiAoZDEgPCBkMikge1xuICAgICAgc2VsZWN0ZWRbMF0gPSBncm91cC5tYXgudG9JU09TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRbMV0gPSBncm91cC5taW4udG9JU09TdHJpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuLypcbiAqIEBwYXJhbSB7R3JvdXB9IGdyb3VwIC0gVGhlIGdyb3VwIHRvIGFkZCBvciByZW1vdmUgZnJvbSB0aGUgZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUR1cmF0aW9uMUQgKHBhcnRpdGlvbiwgZ3JvdXApIHtcbiAgdmFyIHNlbGVjdGVkID0gcGFydGl0aW9uLnNlbGVjdGVkO1xuXG4gIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBub3RoaW5nIHNlbGVjdGVkLCBzdGFydCBhIHJhbmdlXG4gICAgc2VsZWN0ZWRbMF0gPSBncm91cC5taW4udG9JU09TdHJpbmcoKTtcbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heC50b0lTT1N0cmluZygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb25TdGFydCA9IG1vbWVudC5kdXJhdGlvbihzZWxlY3RlZFswXSk7XG4gIHZhciBzZWxlY3Rpb25FbmQgPSBtb21lbnQuZHVyYXRpb24oc2VsZWN0ZWRbMV0pO1xuXG4gIGlmIChncm91cC5taW4gPj0gc2VsZWN0aW9uRW5kKSB7XG4gICAgLy8gY2xpY2tlZCBvdXRzaWRlIHRvIHRoZSByaWd0aCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFsxXSA9IGdyb3VwLm1heC50b0lTT1N0cmluZygpO1xuICB9IGVsc2UgaWYgKGdyb3VwLm1heCA8PSBzZWxlY3Rpb25TdGFydCkge1xuICAgIC8vIGNsaWNrZWQgb3V0c2lkZSB0byB0aGUgbGVmdCBvZiBzZWxlY3Rpb25cbiAgICBzZWxlY3RlZFswXSA9IGdyb3VwLm1pbi50b0lTT1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNsaWNrZWQgaW5zaWRlIHNlbGVjdGlvblxuICAgIHZhciBkMSwgZDI7XG4gICAgZDEgPSBNYXRoLmFicyhzZWxlY3Rpb25TdGFydCAtIGdyb3VwLm1pbik7XG4gICAgZDIgPSBNYXRoLmFicyhzZWxlY3Rpb25FbmQgLSBncm91cC5tYXgpO1xuXG4gICAgaWYgKGQxIDwgZDIpIHtcbiAgICAgIHNlbGVjdGVkWzBdID0gZ3JvdXAubWF4LnRvSVNPU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkWzFdID0gZ3JvdXAubWluLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGdpdmVuIGdyb3VwIG9yIGludGVydmFsXG4gKiBvciwgaWYgbm8gZ3JvdXAgaXMgZ2l2ZW4sIGNsZWFyIHRoZSBzZWxlY3Rpb24uXG4gKlxuICogRm9yIGNhdGVnb3JpYWwgc2VsZWN0aW9ucyB0aGUgZm9sbG93aW5nIHJ1bGVzIGFyZSB1c2VkOlxuICogMS4gbm9uZSBzZWxlY3RlZDpcbiAqICAgIGFkZCB0aGUgZ3JvdXAgdG8gdGhlIHNlbGVjdGlvblxuICogMi4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgdGhlIHNhbWU6XG4gKiAgICBpbnZlcnQgdGhlIHNlbGVjdGlvblxuICogMy4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgZGlmZmVyZW50OlxuICogICAgYWRkIHRoZSBncm91cCB0byB0aGUgc2VsZWN0aW9uXG4gKiA0LiBtb3JlIHRoYW4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgaW4gdGhlIHNlbGVjdGlvbjpcbiAqICAgIHJlbW92ZSB0aGUgZ3JvdXAgZnJvbSB0aGUgc2VsZWN0aW9uXG4gKiA1LiBtb3JlIHRoYW4gb25lIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgbm90IGluIHRoZSBzZWxlY3Rpb246XG4gKiAgICBhZGQgdGhlIGdyb3VwIHRvIHRoZSBzZWxlY3Rpb25cbiAqXG4gKiBGb3IgY29udGludW91cyBzZWxlY3Rpb25zIHRoZSBmb2xsb3dpbmcgcnVsZXMgYXJlIHVzZWQ6XG4gKiAxLiBubyByYW5nZSBzZWxlY3RlZFxuICogICAgc2V0IHRoZSByYW5nZSBlcXVhbCB0byB0aGF0IG9mIHRoZSBncm91cFxuICogMi4gYSByYW5nZSBzZWxlY3RlZCBhbmQgdGhlIGdyb3VwIGlzIG91dHNpZGUgdGhlIHNlbGVjdGlvbjpcbiAqICAgIGV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIGluY2x1ZGUgdGhlIGdyb3VwXG4gKiAzLiBhIHJhbmdlIHNlbGVjdGVkIGFuZCB0aGUgZ3JvdXAgaXMgaW5zaWRlIHRoZSBzZWxlY3Rpb246XG4gKiAgICBzZXQgdGhlIGVuZHBvaW50IGNsb3Nlc3QgdG8gdGhlIGdyb3VwIHRvIHRoYXQgb2YgdGhlIGdyb3VwXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gUGFydGl0aW9uIHRvIHVwZGF0ZVxuICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcltdKX0gR3JvdXAgb3IgaW50ZXJ2YWxcbiAqL1xuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uIChwYXJ0aXRpb24sIGdyb3VwKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICAvLyBDbGVhciB0aGUgc2VsZWN0aW9uIChpZS4gYWxsIHBvaW50cyBhcmUgc2VsZWN0ZWQpXG4gICAgcGFydGl0aW9uLnNlbGVjdGVkLnNwbGljZSgwLCBwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvblxuICAgIGlmIChwYXJ0aXRpb24udHlwZSA9PT0gJ2NhdGVnb3JpYWwnIHx8IHBhcnRpdGlvbi50eXBlID09PSAnY29uc3RhbnQnKSB7XG4gICAgICB1cGRhdGVDYXRlZ29yaWFsMUQocGFydGl0aW9uLCBncm91cCk7XG4gICAgfSBlbHNlIGlmIChwYXJ0aXRpb24udHlwZSA9PT0gJ2NvbnRpbnVvdXMnKSB7XG4gICAgICB1cGRhdGVDb250aW51b3VzMUQocGFydGl0aW9uLCBncm91cCk7XG4gICAgfSBlbHNlIGlmIChwYXJ0aXRpb24udHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgdXBkYXRlRGF0ZXRpbWUxRChwYXJ0aXRpb24sIGdyb3VwKTtcbiAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi50eXBlID09PSAnZHVyYXRpb24nKSB7XG4gICAgICB1cGRhdGVEdXJhdGlvbjFEKHBhcnRpdGlvbiwgZ3JvdXApO1xuICAgIH0gZWxzZSBpZiAocGFydGl0aW9uLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgdXBkYXRlVGV4dChwYXJ0aXRpb24sIGdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHVwZGF0ZSBzZWxlY3Rpb24nLCBwYXJ0aXRpb24udHlwZSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaWx0ZXJGdW5jdGlvbjogZmlsdGVyRnVuY3Rpb24sXG4gIHVwZGF0ZVNlbGVjdGlvbjogdXBkYXRlU2VsZWN0aW9uXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1278\n")},"181d":function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"0d97\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"914f\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\nvar yeast = __webpack_require__(/*! yeast */ \"c16d\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function () {\n  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"86e3\");\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function (onPause) {\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause () {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' === self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' === packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' !== this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' === this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close () {\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' === this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\n     ('http' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgxZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzP2U1ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///181d\n")},"1e1f":function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar eio = __webpack_require__(/*! engine.io-client */ \"c59b\");\nvar Socket = __webpack_require__(/*! ./socket */ \"4c13\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"6fba\");\nvar on = __webpack_require__(/*! ./on */ \"faaa\");\nvar bind = __webpack_require__(/*! component-bind */ \"b6f6\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client:manager');\nvar indexOf = __webpack_require__(/*! indexof */ \"3294\");\nvar Backoff = __webpack_require__(/*! backo2 */ \"f942\");\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.engine.id;\n    }\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.engine.id;\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting evnet is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMWUxZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcz9mMDk3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChmbiwgb3B0cykge1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbiAobnNwLCBvcHRzKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdGluZycsIG9uQ29ubmVjdGluZyk7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuICAgICAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuICAgICAgb25Db25uZWN0aW5nKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0aW5nICgpIHtcbiAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAocGFja2V0LnF1ZXJ5ICYmIHBhY2tldC50eXBlID09PSAwKSBwYWNrZXQubnNwICs9ICc/JyArIHBhY2tldC5xdWVyeTtcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uIChlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2VcbiAgICAvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1e1f\n")},"1ed2":function(module,exports){eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMWVkMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/NDg1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1ed2\n")},"23b1":function(module,exports,__webpack_require__){eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug.debug = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"0b10\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting\n    args = exports.formatArgs.apply(self, args);\n\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/[\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjNiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanM/NjMxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWcuZGVidWcgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmdcbiAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9bXFxcXF4kKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23b1\n")},"2dce":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module requirements.\n */\n\nvar Polling = __webpack_require__(/*! ./polling */ \"181d\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function (e) {\n    self.onError('jsonp poll error', e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  } else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch (e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function () {\n      if (self.iframe.readyState === 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMmRjZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzP2RmZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJywgZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfSBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2dce\n")},3902:function(module,exports,__webpack_require__){eval("/**\n * Base class\n *\n * Implements unique ID per instance. It is set once, and can not be updated.\n * An ID is generated during initialization; however it is included in the (de-)serializing of the object.\n * @class Base\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\n\n// see discussion here: https://gist.github.com/gordonbrander/2230317\nfunction uniqueID () {\n  function chr4 () {\n    return Math.random().toString(16).slice(-4);\n  }\n  return chr4() + chr4() +\n    '-' + chr4() +\n    '-' + chr4() +\n    '-' + chr4() +\n    '-' + chr4() + chr4() + chr4();\n}\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * Unique ID for this class\n     * @memberof! Base\n     * @readonly\n     * @type {ID}\n     */\n    id: {\n      type: 'string',\n      default: function () {\n        return uniqueID();\n      },\n      setonce: true\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9iYXNlLmpzP2NlYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlIGNsYXNzXG4gKlxuICogSW1wbGVtZW50cyB1bmlxdWUgSUQgcGVyIGluc3RhbmNlLiBJdCBpcyBzZXQgb25jZSwgYW5kIGNhbiBub3QgYmUgdXBkYXRlZC5cbiAqIEFuIElEIGlzIGdlbmVyYXRlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb247IGhvd2V2ZXIgaXQgaXMgaW5jbHVkZWQgaW4gdGhlIChkZS0pc2VyaWFsaXppbmcgb2YgdGhlIG9iamVjdC5cbiAqIEBjbGFzcyBCYXNlXG4gKi9cbnZhciBBbXBlcnNhbmRNb2RlbCA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1tb2RlbCcpO1xuXG4vLyBzZWUgZGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9nb3Jkb25icmFuZGVyLzIyMzAzMTdcbmZ1bmN0aW9uIHVuaXF1ZUlEICgpIHtcbiAgZnVuY3Rpb24gY2hyNCAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKC00KTtcbiAgfVxuICByZXR1cm4gY2hyNCgpICsgY2hyNCgpICtcbiAgICAnLScgKyBjaHI0KCkgK1xuICAgICctJyArIGNocjQoKSArXG4gICAgJy0nICsgY2hyNCgpICtcbiAgICAnLScgKyBjaHI0KCkgKyBjaHI0KCkgKyBjaHI0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgSUQgZm9yIHRoaXMgY2xhc3NcbiAgICAgKiBAbWVtYmVyb2YhIEJhc2VcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7SUR9XG4gICAgICovXG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdW5pcXVlSUQoKTtcbiAgICAgIH0sXG4gICAgICBzZXRvbmNlOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3902\n")},"3b07":function(module,exports,__webpack_require__){eval("/**\n * Main spot object.\n *\n * @class Spot\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Dataview = __webpack_require__(/*! ./dataview */ \"5066\");\nvar Datasets = __webpack_require__(/*! ./dataset/collection */ \"544d\");\nvar driverClient = __webpack_require__(/*! ./driver/client */ \"720c\");\nvar driverServer = __webpack_require__(/*! ./driver/server */ \"072d\");\nvar utildx = __webpack_require__(/*! ./util/crossfilter */ \"adfa\");\nvar timeUtil = __webpack_require__(/*! ./util/time */ \"d45b\");\nvar io = __webpack_require__(/*! socket.io-client */ \"b452\");\n\n/**\n * Connect to the spot-server using a websocket and setup callbacks\n *\n * @function\n * @param {address} Optional. IP address and port number to connect to. fi.  'http://localhost:3000'\n *\n * @memberof! Spot\n */\nfunction connectToServer (address) {\n  var me = this;\n  var socket;\n\n  if (address) {\n    // connect to specified address\n    // necessary for when window.location is not availble (node.js)\n    socket = io.connect(address);\n  } else {\n    // Use socket.io fallback to autodetect address\n    // ie. when a website wants to connect, use the window.location\n    socket = io.connect();\n  }\n\n  socket.on('connect', function () {\n    me.isConnected = true;\n    console.log('Connected to server');\n  });\n\n  socket.on('disconnect', function () {\n    me.isConnected = false;\n  });\n\n  socket.on('syncDatasets', function (req) {\n    // do an incremental update, as we typically start without datasets\n    me.datasets.add(req.data, { merge: true });\n  });\n\n  socket.on('syncDataview', function (req) {\n    me.dataview.reset(req.data);\n  });\n\n  socket.on('syncFacets', function (req) {\n    // do an incremental update, as we typically update only a few properties of a facet\n    // Also, a full reset will orphan the view.model objects in spot-app (ie. crashes)\n    var dataset = me.datasets.get(req.datasetId);\n    dataset.facets.add(req.data, { merge: true });\n\n    me.resetDataview(); // NOTE: the cached (serialized) datasets need to be updated, too\n\n    dataset.trigger('syncFacets');\n  });\n\n  socket.on('newData', function (req) {\n    var filter = me.dataview.filters.get(req.filterId);\n    if (req.data) {\n      filter.data = req.data;\n\n      // for text filters, rebuild partition and count\n      filter.partitions.forEach(function (partition, p) {\n        var columnToName = {1: 'a', 2: 'b', 3: 'c', 4: 'd'};\n\n        if (partition.isText) {\n          partition.groups.reset(null, {silent: true});\n          filter.data.forEach(function (d) {\n            var count = (parseFloat(d.aa) || parseInt(d.count)) || 0;\n\n            if (count) {\n              partition.groups.add({\n                min: 0,\n                max: 100,\n                count: count,\n                label: d[columnToName[(p + 1)]],\n                value: d[columnToName[(p + 1)]]\n              }, {silent: true});\n            }\n          });\n          partition.groups.sort();\n        }\n      });\n      filter.trigger('newData');\n    }\n  });\n\n  socket.on('newMetaData', function (req) {\n    me.dataview.dataTotal = parseInt(req.dataTotal);\n    me.dataview.dataSelected = parseInt(req.dataSelected);\n    console.timeEnd('Get data');\n    me.dataview.trigger('newMetaData');\n  });\n\n  socket.connect();\n  me.socket = socket;\n}\n\n/**\n * Disconnect from the spot-server\n *\n * @function\n * @memberof! Spot\n */\nfunction disconnectFromServer () {\n  this.socket.disconnect();\n}\n\n/**\n * Request a list of available datasets from the server\n *\n * Depending on the driver, this can be an asyncrhonous function.\n * It returns a Promise that resolves to the dataset collection\n *\n * @function\n * @returns {Promise}\n *\n * @memberof! Spot\n */\nfunction getDatasets () {\n  var me = this;\n\n  return new Promise(function (resolve, reject) {\n    me.socket.emit('getDatasets');\n\n    me.datasets.once('reset', function () {\n      resolve(me.datasets);\n    });\n  });\n}\n\n/**\n * Reset min, max, and categories for all facets in the dataview\n *\n * @param {Spot} me Main spot instance\n *\n * @memberof! Spot\n */\nfunction resetDataview () {\n  var toSerialize = [];\n\n  // Update list of active datasets, and serialize the datasets parts we need to send on getData requests\n  this.dataview.datasetIds = [];\n  this.datasets.forEach(function (dataset) {\n    if (dataset.isActive) {\n      // BUGFIX: the list of datasetIds can get out of sync when using spot-server. Just recreate it always.\n      this.dataview.datasetIds.push(dataset.getId());\n      toSerialize.push(dataset.toJSON()); // TODO: only serialize used facets?\n    }\n  }, this);\n  this.cachedDatasets = JSON.stringify(toSerialize);\n\n  // rescan min/max values and categories for the newly added facets\n  this.dataview.facets.forEach(function (facet) {\n    var newFacet = this.dataview.facets.get(facet.name, 'name');\n\n    if (newFacet.isContinuous || newFacet.isDatetime || newFacet.isDuration) {\n      this.setFacetMinMax(facet);\n    } else if (newFacet.isCategorial) {\n      this.setFacetCategories(facet);\n    }\n  }, this);\n}\n\n/*\n * Add or remove facets from a dataset to the global (merged) dataset\n *\n * @memberof! Spot\n * @param {Spot} me Main spot instance\n * @param {Dataset} dataset Dataset set add or remove\n */\nfunction toggleDatasetFacets (me, dataset) {\n  if (dataset.isActive) {\n    // remove active facets in dataset from the global dataset...\n    dataset.facets.forEach(function (facet) {\n      if (!facet.isActive) {\n        return;\n      }\n\n      // ...but only when no other active dataset contains it\n      var facetIsUnique = true;\n      me.datasets.forEach(function (otherDataset) {\n        if (!otherDataset.isActive || otherDataset === dataset) {\n          return;\n        }\n        if (otherDataset.facets.get(facet.name, 'name')) {\n          facetIsUnique = false;\n        }\n      });\n      if (facetIsUnique) {\n        var toRemove = me.dataview.facets.get(facet.name, 'name');\n        me.dataview.facets.remove(toRemove);\n      }\n    });\n  } else if (!dataset.isActive) {\n    // copy facets\n    dataset.facets.forEach(function (facet) {\n      // do nothing if facet is not active\n      if (!facet.isActive) {\n        return;\n      }\n\n      // default options for all facet types\n      var options = {\n        name: facet.name,\n        accessor: facet.name,\n        description: facet.description,\n        type: facet.transform.transformedType,\n        units: facet.units, // TODO: transformed units?\n        isActive: true\n      };\n\n      // do not add if a similar facet already exists\n      if (!me.dataview.facets.get(facet.name, 'name')) {\n        me.dataview.facets.add(options);\n      }\n    });\n  }\n}\n\n/*\n * Add or remove data from a dataset to the global (merged) dataset\n *\n * @memberof! Spot\n * @param {Spot} me Main spot instance\n * @param {Dataset} dataset Dataset set add or remove\n */\nfunction toggleDatasetData (me, dataset) {\n  if (dataset.isActive) {\n    // if dataset is active, remove it:\n    // ...clear all crossfilter filters\n    me.dataview.filters.forEach(function (filter) {\n      // BUGFIX: when loading sessions, the dataset is not initialized properly\n      // so check for it to be sure\n      if (filter.dimension) {\n        filter.dimension.filterAll();\n      }\n    });\n\n    // ...filter all data, originating from the dataset from the dataset\n    var dimension = me.dataview.crossfilter.dimension(function (d) {\n      return d._OriginalDatasetId;\n    });\n    dimension.filter(dataset.getId());\n\n    // ...remove matching data\n    me.dataview.crossfilter.remove();\n\n    // ...restore original filters\n    dimension.filterAll();\n    dimension.dispose();\n    me.dataview.filters.forEach(function (filter) {\n      filter.updateDataFilter();\n    });\n  } else if (!dataset.isActive) {\n    // if dataset is not active, add it\n    // ...find facets to copy\n    var dataTransforms = [];\n    dataset.facets.forEach(function (facet) {\n      // do nothing if facet is not active\n      if (!facet.isActive) {\n        return;\n      }\n      dataTransforms.push({\n        key: facet.name,\n        fn: utildx.valueFn(facet)\n      });\n    });\n\n    // ...transform data\n    var data = dataset.data;\n    var transformedData = [];\n\n    data.forEach(function (datum) {\n      var transformedDatum = {};\n      dataTransforms.forEach(function (transform) {\n        transformedDatum[transform.key] = transform.fn(datum);\n      });\n      transformedDatum._OriginalDatasetId = dataset.getId();\n      transformedData.push(transformedDatum);\n    });\n\n    // ...add to merged dataset\n    me.dataview.crossfilter.add(transformedData);\n  }\n\n  // update counts\n  me.dataview.dataTotal = me.dataview.crossfilter.size();\n  me.dataview.dataSelected = me.dataview.countGroup.value();\n}\n\n/**\n * Add or remove a dataset from the dataview\n * @param {Dataset} dataset Dataset set add or remove\n *\n * @function\n * @memberof! Spot\n */\nfunction toggleDataset (dataset) {\n  if (this.sessionType === 'server') {\n    toggleDatasetFacets(this, dataset);\n  } else if (this.sessionType === 'client') {\n    // release all filters\n    this.dataview.filters.forEach(function (filter) {\n      filter.releaseDataFilter();\n    });\n\n    // manually merge the datasets\n    toggleDatasetFacets(this, dataset);\n    toggleDatasetData(this, dataset);\n  }\n\n  dataset.isActive = !dataset.isActive;\n\n  this.resetDataview();\n}\n\nfunction setFacetMinMax (facet) {\n  // This should work for all kinds of facets:\n  // numbers, durations, and datatimes all implement the relevant operations\n  var datasets = this.datasets;\n\n  var first = true;\n  datasets.forEach(function (dataset) {\n    if (dataset.isActive) {\n      var subFacet = dataset.facets.get(facet.name, 'name');\n      if (first) {\n        facet.minvalAsText = subFacet.transform.transformedMinAsText;\n        facet.maxvalAsText = subFacet.transform.transformedMaxAsText;\n        first = false;\n      } else {\n        if (subFacet.minval < facet.minval) {\n          facet.minvalAsText = subFacet.transform.transformedMinAsText;\n        }\n        if (subFacet.maxval > facet.maxval) {\n          facet.maxvalAsText = subFacet.transform.transformedMaxAsText;\n        }\n      }\n    }\n  });\n}\n\nfunction setFacetCategories (facet) {\n  var datasets = this.datasets;\n\n  facet.categorialTransform.reset();\n\n  // get categories by combining the sets for the separate datasets\n  datasets.forEach(function (dataset) {\n    if (dataset.isActive) {\n      var subFacet = dataset.facets.get(facet.name, 'name');\n\n      if (subFacet.isCategorial) {\n        // merge rules from subFacet into those of Facet\n        subFacet.categorialTransform.rules.forEach(function (rule) {\n          var newRule = facet.categorialTransform.rules.get(rule.expression, 'expression');\n          if (newRule) {\n            newRule.count += rule.count;\n          } else {\n            facet.categorialTransform.rules.add(rule.toJSON());\n          }\n        });\n      } else if (subFacet.isDatetime) {\n        var expressions = timeUtil.timeParts.get(subFacet.datetimeTransform.transformedFormat, 'description').groups;\n        expressions.forEach(function (expression) {\n          var newRule = facet.categorialTransform.rules.get(expression, 'expression');\n          if (newRule) {\n            // no-op: category exist and we don't have a proper count\n          } else {\n            facet.categorialTransform.rules.add({\n              expression: expression,\n              count: 0,\n              group: expression\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nmodule.exports = BaseModel.extend({\n  type: 'user',\n  props: {\n    /**\n     * Is there a connection with a spot sever?\n     * @memberof! Spot\n     * @type {boolean}\n     */\n    isConnected: ['boolean', true, false],\n    /**\n     * When the app in locked down, facets and datasets cannot be edited\n     * @memberof! Spot\n     * @type {boolean}\n     */\n    isLockedDown: ['boolean', true, false],\n    /**\n     * Type of spot session. Must be 'client' or 'server'\n     * @memberof! Spot\n     * @type {string}\n     */\n    sessionType: {\n      type: 'string',\n      required: true,\n      default: 'client',\n      values: ['client', 'server'],\n      setOnce: true\n    }\n  },\n  children: {\n    /**\n     * A union of all active datasets\n     * @memberof! Spot\n     * @type {Dataview}\n     */\n    dataview: Dataview\n  },\n  collections: {\n    /**\n     * Collection of all datasets\n     * @memberof! Spot\n     * @type {Dataset[]}\n     */\n    datasets: Datasets\n  },\n  initialize: function () {\n    // first do parent class initialization\n    BaseModel.prototype.initialize.apply(this, arguments);\n\n    // default to client side (crossfilter) sessions\n    this.driver = driverClient;\n\n    // assign backend driver\n    if (arguments && arguments[0] && arguments[0].sessionType) {\n      if (arguments[0].sessionType === 'client') {\n        this.driver = driverClient;\n      } else if (arguments[0].sessionType === 'server') {\n        this.driver = driverServer;\n      } else {\n        console.error('No driver for type', arguments[0].sessionType);\n      }\n    }\n  },\n  resetDataview: resetDataview,\n  connectToServer: connectToServer,\n  disconnectFromServer: disconnectFromServer,\n  getDatasets: getDatasets,\n  setFacetMinMax: setFacetMinMax,\n  setFacetCategories: setFacetCategories,\n  toggleDataset: toggleDataset\n});\n\nmodule.exports.util = {\n  dx: utildx,\n  misval: __webpack_require__(/*! ./util/misval */ \"bff6\"),\n  time: timeUtil\n};\n\nmodule.exports.transforms = {\n  categorial: __webpack_require__(/*! ./facet/categorial-transform */ \"9b75\"),\n  continuous: __webpack_require__(/*! ./facet/continuous-transform */ \"5a80\"),\n  datetime: __webpack_require__(/*! ./facet/datetime-transform */ \"a0ca\"),\n  duration: __webpack_require__(/*! ./facet/duration-transform */ \"b123\")\n};\n\nmodule.exports.constructors = {\n  Dataview: Dataview,\n  Dataset: __webpack_require__(/*! ./dataset */ \"545a\"),\n  Datasets: Datasets\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiM2IwNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvbWUuanM/Y2NmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1haW4gc3BvdCBvYmplY3QuXG4gKlxuICogQGNsYXNzIFNwb3RcbiAqL1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlJyk7XG52YXIgRGF0YXZpZXcgPSByZXF1aXJlKCcuL2RhdGF2aWV3Jyk7XG52YXIgRGF0YXNldHMgPSByZXF1aXJlKCcuL2RhdGFzZXQvY29sbGVjdGlvbicpO1xudmFyIGRyaXZlckNsaWVudCA9IHJlcXVpcmUoJy4vZHJpdmVyL2NsaWVudCcpO1xudmFyIGRyaXZlclNlcnZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3NlcnZlcicpO1xudmFyIHV0aWxkeCA9IHJlcXVpcmUoJy4vdXRpbC9jcm9zc2ZpbHRlcicpO1xudmFyIHRpbWVVdGlsID0gcmVxdWlyZSgnLi91dGlsL3RpbWUnKTtcbnZhciBpbyA9IHJlcXVpcmUoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBDb25uZWN0IHRvIHRoZSBzcG90LXNlcnZlciB1c2luZyBhIHdlYnNvY2tldCBhbmQgc2V0dXAgY2FsbGJhY2tzXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2FkZHJlc3N9IE9wdGlvbmFsLiBJUCBhZGRyZXNzIGFuZCBwb3J0IG51bWJlciB0byBjb25uZWN0IHRvLiBmaS4gICdodHRwOi8vbG9jYWxob3N0OjMwMDAnXG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3RUb1NlcnZlciAoYWRkcmVzcykge1xuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgc29ja2V0O1xuXG4gIGlmIChhZGRyZXNzKSB7XG4gICAgLy8gY29ubmVjdCB0byBzcGVjaWZpZWQgYWRkcmVzc1xuICAgIC8vIG5lY2Vzc2FyeSBmb3Igd2hlbiB3aW5kb3cubG9jYXRpb24gaXMgbm90IGF2YWlsYmxlIChub2RlLmpzKVxuICAgIHNvY2tldCA9IGlvLmNvbm5lY3QoYWRkcmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIHNvY2tldC5pbyBmYWxsYmFjayB0byBhdXRvZGV0ZWN0IGFkZHJlc3NcbiAgICAvLyBpZS4gd2hlbiBhIHdlYnNpdGUgd2FudHMgdG8gY29ubmVjdCwgdXNlIHRoZSB3aW5kb3cubG9jYXRpb25cbiAgICBzb2NrZXQgPSBpby5jb25uZWN0KCk7XG4gIH1cblxuICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgbWUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gc2VydmVyJyk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbignZGlzY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBtZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICB9KTtcblxuICBzb2NrZXQub24oJ3N5bmNEYXRhc2V0cycsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICAvLyBkbyBhbiBpbmNyZW1lbnRhbCB1cGRhdGUsIGFzIHdlIHR5cGljYWxseSBzdGFydCB3aXRob3V0IGRhdGFzZXRzXG4gICAgbWUuZGF0YXNldHMuYWRkKHJlcS5kYXRhLCB7IG1lcmdlOiB0cnVlIH0pO1xuICB9KTtcblxuICBzb2NrZXQub24oJ3N5bmNEYXRhdmlldycsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICBtZS5kYXRhdmlldy5yZXNldChyZXEuZGF0YSk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbignc3luY0ZhY2V0cycsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICAvLyBkbyBhbiBpbmNyZW1lbnRhbCB1cGRhdGUsIGFzIHdlIHR5cGljYWxseSB1cGRhdGUgb25seSBhIGZldyBwcm9wZXJ0aWVzIG9mIGEgZmFjZXRcbiAgICAvLyBBbHNvLCBhIGZ1bGwgcmVzZXQgd2lsbCBvcnBoYW4gdGhlIHZpZXcubW9kZWwgb2JqZWN0cyBpbiBzcG90LWFwcCAoaWUuIGNyYXNoZXMpXG4gICAgdmFyIGRhdGFzZXQgPSBtZS5kYXRhc2V0cy5nZXQocmVxLmRhdGFzZXRJZCk7XG4gICAgZGF0YXNldC5mYWNldHMuYWRkKHJlcS5kYXRhLCB7IG1lcmdlOiB0cnVlIH0pO1xuXG4gICAgbWUucmVzZXREYXRhdmlldygpOyAvLyBOT1RFOiB0aGUgY2FjaGVkIChzZXJpYWxpemVkKSBkYXRhc2V0cyBuZWVkIHRvIGJlIHVwZGF0ZWQsIHRvb1xuXG4gICAgZGF0YXNldC50cmlnZ2VyKCdzeW5jRmFjZXRzJyk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbignbmV3RGF0YScsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICB2YXIgZmlsdGVyID0gbWUuZGF0YXZpZXcuZmlsdGVycy5nZXQocmVxLmZpbHRlcklkKTtcbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgIGZpbHRlci5kYXRhID0gcmVxLmRhdGE7XG5cbiAgICAgIC8vIGZvciB0ZXh0IGZpbHRlcnMsIHJlYnVpbGQgcGFydGl0aW9uIGFuZCBjb3VudFxuICAgICAgZmlsdGVyLnBhcnRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGFydGl0aW9uLCBwKSB7XG4gICAgICAgIHZhciBjb2x1bW5Ub05hbWUgPSB7MTogJ2EnLCAyOiAnYicsIDM6ICdjJywgNDogJ2QnfTtcblxuICAgICAgICBpZiAocGFydGl0aW9uLmlzVGV4dCkge1xuICAgICAgICAgIHBhcnRpdGlvbi5ncm91cHMucmVzZXQobnVsbCwge3NpbGVudDogdHJ1ZX0pO1xuICAgICAgICAgIGZpbHRlci5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IChwYXJzZUZsb2F0KGQuYWEpIHx8IHBhcnNlSW50KGQuY291bnQpKSB8fCAwO1xuXG4gICAgICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgICAgcGFydGl0aW9uLmdyb3Vwcy5hZGQoe1xuICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGRbY29sdW1uVG9OYW1lWyhwICsgMSldXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZFtjb2x1bW5Ub05hbWVbKHAgKyAxKV1dXG4gICAgICAgICAgICAgIH0sIHtzaWxlbnQ6IHRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXJ0aXRpb24uZ3JvdXBzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmaWx0ZXIudHJpZ2dlcignbmV3RGF0YScpO1xuICAgIH1cbiAgfSk7XG5cbiAgc29ja2V0Lm9uKCduZXdNZXRhRGF0YScsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICBtZS5kYXRhdmlldy5kYXRhVG90YWwgPSBwYXJzZUludChyZXEuZGF0YVRvdGFsKTtcbiAgICBtZS5kYXRhdmlldy5kYXRhU2VsZWN0ZWQgPSBwYXJzZUludChyZXEuZGF0YVNlbGVjdGVkKTtcbiAgICBjb25zb2xlLnRpbWVFbmQoJ0dldCBkYXRhJyk7XG4gICAgbWUuZGF0YXZpZXcudHJpZ2dlcignbmV3TWV0YURhdGEnKTtcbiAgfSk7XG5cbiAgc29ja2V0LmNvbm5lY3QoKTtcbiAgbWUuc29ja2V0ID0gc29ja2V0O1xufVxuXG4vKipcbiAqIERpc2Nvbm5lY3QgZnJvbSB0aGUgc3BvdC1zZXJ2ZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiEgU3BvdFxuICovXG5mdW5jdGlvbiBkaXNjb25uZWN0RnJvbVNlcnZlciAoKSB7XG4gIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IGEgbGlzdCBvZiBhdmFpbGFibGUgZGF0YXNldHMgZnJvbSB0aGUgc2VydmVyXG4gKlxuICogRGVwZW5kaW5nIG9uIHRoZSBkcml2ZXIsIHRoaXMgY2FuIGJlIGFuIGFzeW5jcmhvbm91cyBmdW5jdGlvbi5cbiAqIEl0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRhdGFzZXQgY29sbGVjdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge1Byb21pc2V9XG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFzZXRzICgpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIG1lLnNvY2tldC5lbWl0KCdnZXREYXRhc2V0cycpO1xuXG4gICAgbWUuZGF0YXNldHMub25jZSgncmVzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKG1lLmRhdGFzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzZXQgbWluLCBtYXgsIGFuZCBjYXRlZ29yaWVzIGZvciBhbGwgZmFjZXRzIGluIHRoZSBkYXRhdmlld1xuICpcbiAqIEBwYXJhbSB7U3BvdH0gbWUgTWFpbiBzcG90IGluc3RhbmNlXG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKi9cbmZ1bmN0aW9uIHJlc2V0RGF0YXZpZXcgKCkge1xuICB2YXIgdG9TZXJpYWxpemUgPSBbXTtcblxuICAvLyBVcGRhdGUgbGlzdCBvZiBhY3RpdmUgZGF0YXNldHMsIGFuZCBzZXJpYWxpemUgdGhlIGRhdGFzZXRzIHBhcnRzIHdlIG5lZWQgdG8gc2VuZCBvbiBnZXREYXRhIHJlcXVlc3RzXG4gIHRoaXMuZGF0YXZpZXcuZGF0YXNldElkcyA9IFtdO1xuICB0aGlzLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICBpZiAoZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgICAgLy8gQlVHRklYOiB0aGUgbGlzdCBvZiBkYXRhc2V0SWRzIGNhbiBnZXQgb3V0IG9mIHN5bmMgd2hlbiB1c2luZyBzcG90LXNlcnZlci4gSnVzdCByZWNyZWF0ZSBpdCBhbHdheXMuXG4gICAgICB0aGlzLmRhdGF2aWV3LmRhdGFzZXRJZHMucHVzaChkYXRhc2V0LmdldElkKCkpO1xuICAgICAgdG9TZXJpYWxpemUucHVzaChkYXRhc2V0LnRvSlNPTigpKTsgLy8gVE9ETzogb25seSBzZXJpYWxpemUgdXNlZCBmYWNldHM/XG4gICAgfVxuICB9LCB0aGlzKTtcbiAgdGhpcy5jYWNoZWREYXRhc2V0cyA9IEpTT04uc3RyaW5naWZ5KHRvU2VyaWFsaXplKTtcblxuICAvLyByZXNjYW4gbWluL21heCB2YWx1ZXMgYW5kIGNhdGVnb3JpZXMgZm9yIHRoZSBuZXdseSBhZGRlZCBmYWNldHNcbiAgdGhpcy5kYXRhdmlldy5mYWNldHMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICB2YXIgbmV3RmFjZXQgPSB0aGlzLmRhdGF2aWV3LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKTtcblxuICAgIGlmIChuZXdGYWNldC5pc0NvbnRpbnVvdXMgfHwgbmV3RmFjZXQuaXNEYXRldGltZSB8fCBuZXdGYWNldC5pc0R1cmF0aW9uKSB7XG4gICAgICB0aGlzLnNldEZhY2V0TWluTWF4KGZhY2V0KTtcbiAgICB9IGVsc2UgaWYgKG5ld0ZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgICAgdGhpcy5zZXRGYWNldENhdGVnb3JpZXMoZmFjZXQpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG59XG5cbi8qXG4gKiBBZGQgb3IgcmVtb3ZlIGZhY2V0cyBmcm9tIGEgZGF0YXNldCB0byB0aGUgZ2xvYmFsIChtZXJnZWQpIGRhdGFzZXRcbiAqXG4gKiBAbWVtYmVyb2YhIFNwb3RcbiAqIEBwYXJhbSB7U3BvdH0gbWUgTWFpbiBzcG90IGluc3RhbmNlXG4gKiBAcGFyYW0ge0RhdGFzZXR9IGRhdGFzZXQgRGF0YXNldCBzZXQgYWRkIG9yIHJlbW92ZVxuICovXG5mdW5jdGlvbiB0b2dnbGVEYXRhc2V0RmFjZXRzIChtZSwgZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBhY3RpdmUgZmFjZXRzIGluIGRhdGFzZXQgZnJvbSB0aGUgZ2xvYmFsIGRhdGFzZXQuLi5cbiAgICBkYXRhc2V0LmZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChmYWNldCkge1xuICAgICAgaWYgKCFmYWNldC5pc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmJ1dCBvbmx5IHdoZW4gbm8gb3RoZXIgYWN0aXZlIGRhdGFzZXQgY29udGFpbnMgaXRcbiAgICAgIHZhciBmYWNldElzVW5pcXVlID0gdHJ1ZTtcbiAgICAgIG1lLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24gKG90aGVyRGF0YXNldCkge1xuICAgICAgICBpZiAoIW90aGVyRGF0YXNldC5pc0FjdGl2ZSB8fCBvdGhlckRhdGFzZXQgPT09IGRhdGFzZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyRGF0YXNldC5mYWNldHMuZ2V0KGZhY2V0Lm5hbWUsICduYW1lJykpIHtcbiAgICAgICAgICBmYWNldElzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGZhY2V0SXNVbmlxdWUpIHtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gbWUuZGF0YXZpZXcuZmFjZXRzLmdldChmYWNldC5uYW1lLCAnbmFtZScpO1xuICAgICAgICBtZS5kYXRhdmlldy5mYWNldHMucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICghZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgIC8vIGNvcHkgZmFjZXRzXG4gICAgZGF0YXNldC5mYWNldHMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgZmFjZXQgaXMgbm90IGFjdGl2ZVxuICAgICAgaWYgKCFmYWNldC5pc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZmF1bHQgb3B0aW9ucyBmb3IgYWxsIGZhY2V0IHR5cGVzXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgbmFtZTogZmFjZXQubmFtZSxcbiAgICAgICAgYWNjZXNzb3I6IGZhY2V0Lm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBmYWNldC5kZXNjcmlwdGlvbixcbiAgICAgICAgdHlwZTogZmFjZXQudHJhbnNmb3JtLnRyYW5zZm9ybWVkVHlwZSxcbiAgICAgICAgdW5pdHM6IGZhY2V0LnVuaXRzLCAvLyBUT0RPOiB0cmFuc2Zvcm1lZCB1bml0cz9cbiAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIGRvIG5vdCBhZGQgaWYgYSBzaW1pbGFyIGZhY2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICBpZiAoIW1lLmRhdGF2aWV3LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKSkge1xuICAgICAgICBtZS5kYXRhdmlldy5mYWNldHMuYWRkKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qXG4gKiBBZGQgb3IgcmVtb3ZlIGRhdGEgZnJvbSBhIGRhdGFzZXQgdG8gdGhlIGdsb2JhbCAobWVyZ2VkKSBkYXRhc2V0XG4gKlxuICogQG1lbWJlcm9mISBTcG90XG4gKiBAcGFyYW0ge1Nwb3R9IG1lIE1haW4gc3BvdCBpbnN0YW5jZVxuICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0IERhdGFzZXQgc2V0IGFkZCBvciByZW1vdmVcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlRGF0YXNldERhdGEgKG1lLCBkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0LmlzQWN0aXZlKSB7XG4gICAgLy8gaWYgZGF0YXNldCBpcyBhY3RpdmUsIHJlbW92ZSBpdDpcbiAgICAvLyAuLi5jbGVhciBhbGwgY3Jvc3NmaWx0ZXIgZmlsdGVyc1xuICAgIG1lLmRhdGF2aWV3LmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAvLyBCVUdGSVg6IHdoZW4gbG9hZGluZyBzZXNzaW9ucywgdGhlIGRhdGFzZXQgaXMgbm90IGluaXRpYWxpemVkIHByb3Blcmx5XG4gICAgICAvLyBzbyBjaGVjayBmb3IgaXQgdG8gYmUgc3VyZVxuICAgICAgaWYgKGZpbHRlci5kaW1lbnNpb24pIHtcbiAgICAgICAgZmlsdGVyLmRpbWVuc2lvbi5maWx0ZXJBbGwoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIC4uLmZpbHRlciBhbGwgZGF0YSwgb3JpZ2luYXRpbmcgZnJvbSB0aGUgZGF0YXNldCBmcm9tIHRoZSBkYXRhc2V0XG4gICAgdmFyIGRpbWVuc2lvbiA9IG1lLmRhdGF2aWV3LmNyb3NzZmlsdGVyLmRpbWVuc2lvbihmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuX09yaWdpbmFsRGF0YXNldElkO1xuICAgIH0pO1xuICAgIGRpbWVuc2lvbi5maWx0ZXIoZGF0YXNldC5nZXRJZCgpKTtcblxuICAgIC8vIC4uLnJlbW92ZSBtYXRjaGluZyBkYXRhXG4gICAgbWUuZGF0YXZpZXcuY3Jvc3NmaWx0ZXIucmVtb3ZlKCk7XG5cbiAgICAvLyAuLi5yZXN0b3JlIG9yaWdpbmFsIGZpbHRlcnNcbiAgICBkaW1lbnNpb24uZmlsdGVyQWxsKCk7XG4gICAgZGltZW5zaW9uLmRpc3Bvc2UoKTtcbiAgICBtZS5kYXRhdmlldy5maWx0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgZmlsdGVyLnVwZGF0ZURhdGFGaWx0ZXIoKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICghZGF0YXNldC5pc0FjdGl2ZSkge1xuICAgIC8vIGlmIGRhdGFzZXQgaXMgbm90IGFjdGl2ZSwgYWRkIGl0XG4gICAgLy8gLi4uZmluZCBmYWNldHMgdG8gY29weVxuICAgIHZhciBkYXRhVHJhbnNmb3JtcyA9IFtdO1xuICAgIGRhdGFzZXQuZmFjZXRzLmZvckVhY2goZnVuY3Rpb24gKGZhY2V0KSB7XG4gICAgICAvLyBkbyBub3RoaW5nIGlmIGZhY2V0IGlzIG5vdCBhY3RpdmVcbiAgICAgIGlmICghZmFjZXQuaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGF0YVRyYW5zZm9ybXMucHVzaCh7XG4gICAgICAgIGtleTogZmFjZXQubmFtZSxcbiAgICAgICAgZm46IHV0aWxkeC52YWx1ZUZuKGZhY2V0KVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyAuLi50cmFuc2Zvcm0gZGF0YVxuICAgIHZhciBkYXRhID0gZGF0YXNldC5kYXRhO1xuICAgIHZhciB0cmFuc2Zvcm1lZERhdGEgPSBbXTtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0dW0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZERhdHVtID0ge307XG4gICAgICBkYXRhVHJhbnNmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtZWREYXR1bVt0cmFuc2Zvcm0ua2V5XSA9IHRyYW5zZm9ybS5mbihkYXR1bSk7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zZm9ybWVkRGF0dW0uX09yaWdpbmFsRGF0YXNldElkID0gZGF0YXNldC5nZXRJZCgpO1xuICAgICAgdHJhbnNmb3JtZWREYXRhLnB1c2godHJhbnNmb3JtZWREYXR1bSk7XG4gICAgfSk7XG5cbiAgICAvLyAuLi5hZGQgdG8gbWVyZ2VkIGRhdGFzZXRcbiAgICBtZS5kYXRhdmlldy5jcm9zc2ZpbHRlci5hZGQodHJhbnNmb3JtZWREYXRhKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBjb3VudHNcbiAgbWUuZGF0YXZpZXcuZGF0YVRvdGFsID0gbWUuZGF0YXZpZXcuY3Jvc3NmaWx0ZXIuc2l6ZSgpO1xuICBtZS5kYXRhdmlldy5kYXRhU2VsZWN0ZWQgPSBtZS5kYXRhdmlldy5jb3VudEdyb3VwLnZhbHVlKCk7XG59XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBhIGRhdGFzZXQgZnJvbSB0aGUgZGF0YXZpZXdcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldCBEYXRhc2V0IHNldCBhZGQgb3IgcmVtb3ZlXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YhIFNwb3RcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlRGF0YXNldCAoZGF0YXNldCkge1xuICBpZiAodGhpcy5zZXNzaW9uVHlwZSA9PT0gJ3NlcnZlcicpIHtcbiAgICB0b2dnbGVEYXRhc2V0RmFjZXRzKHRoaXMsIGRhdGFzZXQpO1xuICB9IGVsc2UgaWYgKHRoaXMuc2Vzc2lvblR5cGUgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gcmVsZWFzZSBhbGwgZmlsdGVyc1xuICAgIHRoaXMuZGF0YXZpZXcuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgIGZpbHRlci5yZWxlYXNlRGF0YUZpbHRlcigpO1xuICAgIH0pO1xuXG4gICAgLy8gbWFudWFsbHkgbWVyZ2UgdGhlIGRhdGFzZXRzXG4gICAgdG9nZ2xlRGF0YXNldEZhY2V0cyh0aGlzLCBkYXRhc2V0KTtcbiAgICB0b2dnbGVEYXRhc2V0RGF0YSh0aGlzLCBkYXRhc2V0KTtcbiAgfVxuXG4gIGRhdGFzZXQuaXNBY3RpdmUgPSAhZGF0YXNldC5pc0FjdGl2ZTtcblxuICB0aGlzLnJlc2V0RGF0YXZpZXcoKTtcbn1cblxuZnVuY3Rpb24gc2V0RmFjZXRNaW5NYXggKGZhY2V0KSB7XG4gIC8vIFRoaXMgc2hvdWxkIHdvcmsgZm9yIGFsbCBraW5kcyBvZiBmYWNldHM6XG4gIC8vIG51bWJlcnMsIGR1cmF0aW9ucywgYW5kIGRhdGF0aW1lcyBhbGwgaW1wbGVtZW50IHRoZSByZWxldmFudCBvcGVyYXRpb25zXG4gIHZhciBkYXRhc2V0cyA9IHRoaXMuZGF0YXNldHM7XG5cbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIGlmIChkYXRhc2V0LmlzQWN0aXZlKSB7XG4gICAgICB2YXIgc3ViRmFjZXQgPSBkYXRhc2V0LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmYWNldC5taW52YWxBc1RleHQgPSBzdWJGYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNaW5Bc1RleHQ7XG4gICAgICAgIGZhY2V0Lm1heHZhbEFzVGV4dCA9IHN1YkZhY2V0LnRyYW5zZm9ybS50cmFuc2Zvcm1lZE1heEFzVGV4dDtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdWJGYWNldC5taW52YWwgPCBmYWNldC5taW52YWwpIHtcbiAgICAgICAgICBmYWNldC5taW52YWxBc1RleHQgPSBzdWJGYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNaW5Bc1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YkZhY2V0Lm1heHZhbCA+IGZhY2V0Lm1heHZhbCkge1xuICAgICAgICAgIGZhY2V0Lm1heHZhbEFzVGV4dCA9IHN1YkZhY2V0LnRyYW5zZm9ybS50cmFuc2Zvcm1lZE1heEFzVGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldEZhY2V0Q2F0ZWdvcmllcyAoZmFjZXQpIHtcbiAgdmFyIGRhdGFzZXRzID0gdGhpcy5kYXRhc2V0cztcblxuICBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJlc2V0KCk7XG5cbiAgLy8gZ2V0IGNhdGVnb3JpZXMgYnkgY29tYmluaW5nIHRoZSBzZXRzIGZvciB0aGUgc2VwYXJhdGUgZGF0YXNldHNcbiAgZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIGlmIChkYXRhc2V0LmlzQWN0aXZlKSB7XG4gICAgICB2YXIgc3ViRmFjZXQgPSBkYXRhc2V0LmZhY2V0cy5nZXQoZmFjZXQubmFtZSwgJ25hbWUnKTtcblxuICAgICAgaWYgKHN1YkZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgICAgICAvLyBtZXJnZSBydWxlcyBmcm9tIHN1YkZhY2V0IGludG8gdGhvc2Ugb2YgRmFjZXRcbiAgICAgICAgc3ViRmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgdmFyIG5ld1J1bGUgPSBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJ1bGVzLmdldChydWxlLmV4cHJlc3Npb24sICdleHByZXNzaW9uJyk7XG4gICAgICAgICAgaWYgKG5ld1J1bGUpIHtcbiAgICAgICAgICAgIG5ld1J1bGUuY291bnQgKz0gcnVsZS5jb3VudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5ydWxlcy5hZGQocnVsZS50b0pTT04oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3ViRmFjZXQuaXNEYXRldGltZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aW1lVXRpbC50aW1lUGFydHMuZ2V0KHN1YkZhY2V0LmRhdGV0aW1lVHJhbnNmb3JtLnRyYW5zZm9ybWVkRm9ybWF0LCAnZGVzY3JpcHRpb24nKS5ncm91cHM7XG4gICAgICAgIGV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbmV3UnVsZSA9IGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0ucnVsZXMuZ2V0KGV4cHJlc3Npb24sICdleHByZXNzaW9uJyk7XG4gICAgICAgICAgaWYgKG5ld1J1bGUpIHtcbiAgICAgICAgICAgIC8vIG5vLW9wOiBjYXRlZ29yeSBleGlzdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIHByb3BlciBjb3VudFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWNldC5jYXRlZ29yaWFsVHJhbnNmb3JtLnJ1bGVzLmFkZCh7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICBncm91cDogZXhwcmVzc2lvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VNb2RlbC5leHRlbmQoe1xuICB0eXBlOiAndXNlcicsXG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogSXMgdGhlcmUgYSBjb25uZWN0aW9uIHdpdGggYSBzcG90IHNldmVyP1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkOiBbJ2Jvb2xlYW4nLCB0cnVlLCBmYWxzZV0sXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgYXBwIGluIGxvY2tlZCBkb3duLCBmYWNldHMgYW5kIGRhdGFzZXRzIGNhbm5vdCBiZSBlZGl0ZWRcbiAgICAgKiBAbWVtYmVyb2YhIFNwb3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xvY2tlZERvd246IFsnYm9vbGVhbicsIHRydWUsIGZhbHNlXSxcbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHNwb3Qgc2Vzc2lvbi4gTXVzdCBiZSAnY2xpZW50JyBvciAnc2VydmVyJ1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2Vzc2lvblR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnY2xpZW50JyxcbiAgICAgIHZhbHVlczogWydjbGllbnQnLCAnc2VydmVyJ10sXG4gICAgICBzZXRPbmNlOiB0cnVlXG4gICAgfVxuICB9LFxuICBjaGlsZHJlbjoge1xuICAgIC8qKlxuICAgICAqIEEgdW5pb24gb2YgYWxsIGFjdGl2ZSBkYXRhc2V0c1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtEYXRhdmlld31cbiAgICAgKi9cbiAgICBkYXRhdmlldzogRGF0YXZpZXdcbiAgfSxcbiAgY29sbGVjdGlvbnM6IHtcbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIGFsbCBkYXRhc2V0c1xuICAgICAqIEBtZW1iZXJvZiEgU3BvdFxuICAgICAqIEB0eXBlIHtEYXRhc2V0W119XG4gICAgICovXG4gICAgZGF0YXNldHM6IERhdGFzZXRzXG4gIH0sXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBmaXJzdCBkbyBwYXJlbnQgY2xhc3MgaW5pdGlhbGl6YXRpb25cbiAgICBCYXNlTW9kZWwucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIGRlZmF1bHQgdG8gY2xpZW50IHNpZGUgKGNyb3NzZmlsdGVyKSBzZXNzaW9uc1xuICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyQ2xpZW50O1xuXG4gICAgLy8gYXNzaWduIGJhY2tlbmQgZHJpdmVyXG4gICAgaWYgKGFyZ3VtZW50cyAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLnNlc3Npb25UeXBlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdLnNlc3Npb25UeXBlID09PSAnY2xpZW50Jykge1xuICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlckNsaWVudDtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdLnNlc3Npb25UeXBlID09PSAnc2VydmVyJykge1xuICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlclNlcnZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGRyaXZlciBmb3IgdHlwZScsIGFyZ3VtZW50c1swXS5zZXNzaW9uVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXNldERhdGF2aWV3OiByZXNldERhdGF2aWV3LFxuICBjb25uZWN0VG9TZXJ2ZXI6IGNvbm5lY3RUb1NlcnZlcixcbiAgZGlzY29ubmVjdEZyb21TZXJ2ZXI6IGRpc2Nvbm5lY3RGcm9tU2VydmVyLFxuICBnZXREYXRhc2V0czogZ2V0RGF0YXNldHMsXG4gIHNldEZhY2V0TWluTWF4OiBzZXRGYWNldE1pbk1heCxcbiAgc2V0RmFjZXRDYXRlZ29yaWVzOiBzZXRGYWNldENhdGVnb3JpZXMsXG4gIHRvZ2dsZURhdGFzZXQ6IHRvZ2dsZURhdGFzZXRcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy51dGlsID0ge1xuICBkeDogdXRpbGR4LFxuICBtaXN2YWw6IHJlcXVpcmUoJy4vdXRpbC9taXN2YWwnKSxcbiAgdGltZTogdGltZVV0aWxcbn07XG5cbm1vZHVsZS5leHBvcnRzLnRyYW5zZm9ybXMgPSB7XG4gIGNhdGVnb3JpYWw6IHJlcXVpcmUoJy4vZmFjZXQvY2F0ZWdvcmlhbC10cmFuc2Zvcm0nKSxcbiAgY29udGludW91czogcmVxdWlyZSgnLi9mYWNldC9jb250aW51b3VzLXRyYW5zZm9ybScpLFxuICBkYXRldGltZTogcmVxdWlyZSgnLi9mYWNldC9kYXRldGltZS10cmFuc2Zvcm0nKSxcbiAgZHVyYXRpb246IHJlcXVpcmUoJy4vZmFjZXQvZHVyYXRpb24tdHJhbnNmb3JtJylcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNvbnN0cnVjdG9ycyA9IHtcbiAgRGF0YXZpZXc6IERhdGF2aWV3LFxuICBEYXRhc2V0OiByZXF1aXJlKCcuL2RhdGFzZXQnKSxcbiAgRGF0YXNldHM6IERhdGFzZXRzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3b07\n")},"419b":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "698d")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanM/MGJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///419b\n')},"433b":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"23b1\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return process.env.DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"26d5\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMzYi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZGVidWcvYnJvd3Nlci5qcz82NDdhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHJldHVybiBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///433b\n")},4573:function(module,exports,__webpack_require__){"use strict";eval('\n\nvar xfilterArray = __webpack_require__(/*! ./array */ "0fc4");\nvar xfilterFilter = __webpack_require__(/*! ./filter */ "a376");\nvar crossfilter_identity = __webpack_require__(/*! ./identity */ "55a3");\nvar crossfilter_null = __webpack_require__(/*! ./null */ "de3f");\nvar crossfilter_zero = __webpack_require__(/*! ./zero */ "b730");\nvar xfilterHeapselect = __webpack_require__(/*! ./heapselect */ "e95e");\nvar xfilterHeap = __webpack_require__(/*! ./heap */ "a74f");\nvar bisect = __webpack_require__(/*! ./bisect */ "02ef");\nvar insertionsort = __webpack_require__(/*! ./insertionsort */ "753f");\nvar permute = __webpack_require__(/*! ./permute */ "5677");\nvar quicksort = __webpack_require__(/*! ./quicksort */ "b28e");\nvar xfilterReduce = __webpack_require__(/*! ./reduce */ "55c1");\nvar packageJson = __webpack_require__(/*! ./../package.json */ "a8db"); // require own package.json for the version field\nvar result = __webpack_require__(/*! lodash.result */ "d101");\n\n// constants\nvar REMOVED_INDEX = -1;\n\n// expose API exports\nexports.crossfilter = crossfilter;\nexports.crossfilter.heap = xfilterHeap;\nexports.crossfilter.heapselect = xfilterHeapselect;\nexports.crossfilter.bisect = bisect;\nexports.crossfilter.insertionsort = insertionsort;\nexports.crossfilter.permute = permute;\nexports.crossfilter.quicksort = quicksort;\nexports.crossfilter.version = packageJson.version; // please note use of "package-json-versionify" transform\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there\'s actually new data to add\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange(\'dataAdded\');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = crossfilter_index(n, n),\n        removed = [],\n        usePred = typeof predicate === \'function\',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange(\'dataRemoved\');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the "one" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === \'string\') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        newIterablesIndexCount,\n        iterablesIndexFilterStatus,\n        newIterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sort = quicksort.by(function(i) { return newValues[i]; }),\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or\'d with the\n    // bit offset of the set bit in the dimension\'s "one" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = crossfilter_range(newData.length);\n        newIterablesIndexFilterStatus = crossfilter_index(t,1);\n        var unsortedIndex = crossfilter_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sort(crossfilter_range(t), 0, t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sort(crossfilter_range(n1), 0, n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      if(iterable) {\n        n1 = t;\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n      if (refilterFunction) {\n        for (var index2 = 0; index2 < n1; ++index2) {\n          if (!refilterFunction(newValues[index2], index2)) {\n            filters[offset][newIndex[index2] + n0] |= one;\n            if(iterable) newIterablesIndexFilterStatus[index2] = 1;\n          }\n        }\n      } else {\n        for (var index3 = 0; index3 < lo1; ++index3) {\n          filters[offset][newIndex[index3] + n0] |= one;\n          if(iterable) newIterablesIndexFilterStatus[index3] = 1;\n        }\n        for (var index4 = hi1; index4 < n1; ++index4) {\n          filters[offset][newIndex[index4] + n0] |= one;\n          if(iterable) newIterablesIndexFilterStatus[index4] = 1;\n        }\n      }\n\n      // If this dimension previously had no data, then we don\'t need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : crossfilter_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = crossfilter_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount.length = i1;\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus.length = j;\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(bounds[0] === 0 && bounds[1] === values.length) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange(\'filtered\');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === "function"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n      \n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange(\'filtered\');\n    }\n    \n    function currentFilter() {\n      return filterValue;\n    }\n    \n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension\'s order.\n    // Note: observes this dimension\'s filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension\'s order.\n    // Note: observes this dimension\'s filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id  group id\n          groupWidth = 8,\n          groupCapacity = crossfilter_capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = crossfilter_null,\n          reset = crossfilter_null,\n          resetNeeded = true,\n          groupAll = key === crossfilter_null,\n          n0old;\n\n      if (arguments.length < 1) key = crossfilter_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : crossfilter_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don\'t need to update the reduce values.\n        if (resetNeeded) add = initial = crossfilter_null;\n        if (resetNeeded) remove = initial = crossfilter_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = crossfilter_null;\n            reset = crossfilter_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = crossfilter_capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = crossfilter_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = crossfilter_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = crossfilter_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an \'unfiltered\' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an \'unfiltered\' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension\'s natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, crossfilter_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), crossfilter_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(crossfilter_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(crossfilter_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, crossfilter_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), crossfilter_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== \'function\'){\n      /* eslint no-console: 0 */\n      console.warn(\'onChange callback parameter must be a function!\');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction crossfilter_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction crossfilter_range(n) {\n  var range = crossfilter_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction crossfilter_capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU3My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9jcm9zc2ZpbHRlci5qcz82NTk4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHhmaWx0ZXJBcnJheSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcbnZhciB4ZmlsdGVyRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBjcm9zc2ZpbHRlcl9pZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcbnZhciBjcm9zc2ZpbHRlcl9udWxsID0gcmVxdWlyZSgnLi9udWxsJyk7XG52YXIgY3Jvc3NmaWx0ZXJfemVybyA9IHJlcXVpcmUoJy4vemVybycpO1xudmFyIHhmaWx0ZXJIZWFwc2VsZWN0ID0gcmVxdWlyZSgnLi9oZWFwc2VsZWN0Jyk7XG52YXIgeGZpbHRlckhlYXAgPSByZXF1aXJlKCcuL2hlYXAnKTtcbnZhciBiaXNlY3QgPSByZXF1aXJlKCcuL2Jpc2VjdCcpO1xudmFyIGluc2VydGlvbnNvcnQgPSByZXF1aXJlKCcuL2luc2VydGlvbnNvcnQnKTtcbnZhciBwZXJtdXRlID0gcmVxdWlyZSgnLi9wZXJtdXRlJyk7XG52YXIgcXVpY2tzb3J0ID0gcmVxdWlyZSgnLi9xdWlja3NvcnQnKTtcbnZhciB4ZmlsdGVyUmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4vLi4vcGFja2FnZS5qc29uJyk7IC8vIHJlcXVpcmUgb3duIHBhY2thZ2UuanNvbiBmb3IgdGhlIHZlcnNpb24gZmllbGRcbnZhciByZXN1bHQgPSByZXF1aXJlKCdsb2Rhc2gucmVzdWx0Jyk7XG5cbi8vIGNvbnN0YW50c1xudmFyIFJFTU9WRURfSU5ERVggPSAtMTtcblxuLy8gZXhwb3NlIEFQSSBleHBvcnRzXG5leHBvcnRzLmNyb3NzZmlsdGVyID0gY3Jvc3NmaWx0ZXI7XG5leHBvcnRzLmNyb3NzZmlsdGVyLmhlYXAgPSB4ZmlsdGVySGVhcDtcbmV4cG9ydHMuY3Jvc3NmaWx0ZXIuaGVhcHNlbGVjdCA9IHhmaWx0ZXJIZWFwc2VsZWN0O1xuZXhwb3J0cy5jcm9zc2ZpbHRlci5iaXNlY3QgPSBiaXNlY3Q7XG5leHBvcnRzLmNyb3NzZmlsdGVyLmluc2VydGlvbnNvcnQgPSBpbnNlcnRpb25zb3J0O1xuZXhwb3J0cy5jcm9zc2ZpbHRlci5wZXJtdXRlID0gcGVybXV0ZTtcbmV4cG9ydHMuY3Jvc3NmaWx0ZXIucXVpY2tzb3J0ID0gcXVpY2tzb3J0O1xuZXhwb3J0cy5jcm9zc2ZpbHRlci52ZXJzaW9uID0gcGFja2FnZUpzb24udmVyc2lvbjsgLy8gcGxlYXNlIG5vdGUgdXNlIG9mIFwicGFja2FnZS1qc29uLXZlcnNpb25pZnlcIiB0cmFuc2Zvcm1cblxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXIoKSB7XG4gIHZhciBjcm9zc2ZpbHRlciA9IHtcbiAgICBhZGQ6IGFkZCxcbiAgICByZW1vdmU6IHJlbW92ZURhdGEsXG4gICAgZGltZW5zaW9uOiBkaW1lbnNpb24sXG4gICAgZ3JvdXBBbGw6IGdyb3VwQWxsLFxuICAgIHNpemU6IHNpemUsXG4gICAgYWxsOiBhbGwsXG4gICAgYWxsRmlsdGVyZWQ6IGFsbEZpbHRlcmVkLFxuICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICBpc0VsZW1lbnRGaWx0ZXJlZDogaXNFbGVtZW50RmlsdGVyZWRcbiAgfTtcblxuICB2YXIgZGF0YSA9IFtdLCAvLyB0aGUgcmVjb3Jkc1xuICAgICAgbiA9IDAsIC8vIHRoZSBudW1iZXIgb2YgcmVjb3JkczsgZGF0YS5sZW5ndGhcbiAgICAgIGZpbHRlcnMsIC8vIDEgaXMgZmlsdGVyZWQgb3V0XG4gICAgICBmaWx0ZXJMaXN0ZW5lcnMgPSBbXSwgLy8gd2hlbiB0aGUgZmlsdGVycyBjaGFuZ2VcbiAgICAgIGRhdGFMaXN0ZW5lcnMgPSBbXSwgLy8gd2hlbiBkYXRhIGlzIGFkZGVkXG4gICAgICByZW1vdmVEYXRhTGlzdGVuZXJzID0gW10sIC8vIHdoZW4gZGF0YSBpcyByZW1vdmVkXG4gICAgICBjYWxsYmFja3MgPSBbXTtcblxuICBmaWx0ZXJzID0gbmV3IHhmaWx0ZXJBcnJheS5iaXRhcnJheSgwKTtcblxuICAvLyBBZGRzIHRoZSBzcGVjaWZpZWQgbmV3IHJlY29yZHMgdG8gdGhpcyBjcm9zc2ZpbHRlci5cbiAgZnVuY3Rpb24gYWRkKG5ld0RhdGEpIHtcbiAgICB2YXIgbjAgPSBuLFxuICAgICAgICBuMSA9IG5ld0RhdGEubGVuZ3RoO1xuXG4gICAgLy8gSWYgdGhlcmUncyBhY3R1YWxseSBuZXcgZGF0YSB0byBhZGTigKZcbiAgICAvLyBNZXJnZSB0aGUgbmV3IGRhdGEgaW50byB0aGUgZXhpc3RpbmcgZGF0YS5cbiAgICAvLyBMZW5ndGhlbiB0aGUgZmlsdGVyIGJpdHNldCB0byBoYW5kbGUgdGhlIG5ldyByZWNvcmRzLlxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnMgKGRpbWVuc2lvbnMgYW5kIGdyb3VwcykgdGhhdCBuZXcgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgaWYgKG4xKSB7XG4gICAgICBkYXRhID0gZGF0YS5jb25jYXQobmV3RGF0YSk7XG4gICAgICBmaWx0ZXJzLmxlbmd0aGVuKG4gKz0gbjEpO1xuICAgICAgZGF0YUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbChuZXdEYXRhLCBuMCwgbjEpOyB9KTtcbiAgICAgIHRyaWdnZXJPbkNoYW5nZSgnZGF0YUFkZGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyb3NzZmlsdGVyO1xuICB9XG5cbiAgLy8gUmVtb3ZlcyBhbGwgcmVjb3JkcyB0aGF0IG1hdGNoIHRoZSBjdXJyZW50IGZpbHRlcnMsIG9yIGlmIGEgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCxcbiAgLy8gcmVtb3ZlcyBhbGwgcmVjb3JkcyBtYXRjaGluZyB0aGUgcHJlZGljYXRlIChpZ25vcmluZyBmaWx0ZXJzKS5cbiAgZnVuY3Rpb24gcmVtb3ZlRGF0YShwcmVkaWNhdGUpIHtcbiAgICB2YXIgLy8gTWFwcGluZyBmcm9tIG9sZCByZWNvcmQgaW5kZXhlcyB0byBuZXcgaW5kZXhlcyAoYWZ0ZXIgcmVjb3JkcyByZW1vdmVkKVxuICAgICAgICBuZXdJbmRleCA9IGNyb3NzZmlsdGVyX2luZGV4KG4sIG4pLFxuICAgICAgICByZW1vdmVkID0gW10sXG4gICAgICAgIHVzZVByZWQgPSB0eXBlb2YgcHJlZGljYXRlID09PSAnZnVuY3Rpb24nLFxuICAgICAgICBzaG91bGRSZW1vdmUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiB1c2VQcmVkID8gcHJlZGljYXRlKGRhdGFbaV0sIGkpIDogZmlsdGVycy56ZXJvKGkpXG4gICAgICAgIH07XG5cbiAgICBmb3IgKHZhciBpbmRleDEgPSAwLCBpbmRleDIgPSAwOyBpbmRleDEgPCBuOyArK2luZGV4MSkge1xuICAgICAgaWYgKCBzaG91bGRSZW1vdmUoaW5kZXgxKSApIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGluZGV4MSk7XG4gICAgICAgIG5ld0luZGV4W2luZGV4MV0gPSBSRU1PVkVEX0lOREVYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SW5kZXhbaW5kZXgxXSA9IGluZGV4MisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hpbmcgcmVjb3JkcyBmcm9tIGdyb3Vwcy5cbiAgICBmaWx0ZXJMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihsKSB7IGwoLTEsIC0xLCBbXSwgcmVtb3ZlZCwgdHJ1ZSk7IH0pO1xuXG4gICAgLy8gVXBkYXRlIGluZGV4ZXMuXG4gICAgcmVtb3ZlRGF0YUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbChuZXdJbmRleCk7IH0pO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBmaWx0ZXJzIGFuZCBkYXRhIGJ5IG92ZXJ3cml0aW5nLlxuICAgIGZvciAodmFyIGluZGV4MyA9IDAsIGluZGV4NCA9IDA7IGluZGV4MyA8IG47ICsraW5kZXgzKSB7XG4gICAgICBpZiAoIG5ld0luZGV4W2luZGV4M10gIT09IFJFTU9WRURfSU5ERVggKSB7XG4gICAgICAgIGlmIChpbmRleDMgIT09IGluZGV4NCkgZmlsdGVycy5jb3B5KGluZGV4NCwgaW5kZXgzKSwgZGF0YVtpbmRleDRdID0gZGF0YVtpbmRleDNdO1xuICAgICAgICArK2luZGV4NDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhLmxlbmd0aCA9IG4gPSBpbmRleDQ7XG4gICAgZmlsdGVycy50cnVuY2F0ZShpbmRleDQpO1xuICAgIHRyaWdnZXJPbkNoYW5nZSgnZGF0YVJlbW92ZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hc2tGb3JEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICB2YXIgbixcbiAgICAgICAgZCxcbiAgICAgICAgbGVuLFxuICAgICAgICBpZCxcbiAgICAgICAgbWFzayA9IEFycmF5KGZpbHRlcnMuc3ViYXJyYXlzKTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgZmlsdGVycy5zdWJhcnJheXM7IG4rKykgeyBtYXNrW25dID0gfjA7IH1cbiAgICBmb3IgKGQgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgZCA8IGxlbjsgZCsrKSB7XG4gICAgICAvLyBUaGUgdG9wIGJpdHMgb2YgdGhlIElEIGFyZSB0aGUgc3ViYXJyYXkgb2Zmc2V0IGFuZCB0aGUgbG93ZXIgYml0cyBhcmUgdGhlIGJpdFxuICAgICAgLy8gb2Zmc2V0IG9mIHRoZSBcIm9uZVwiIG1hc2suXG4gICAgICBpZCA9IGRpbWVuc2lvbnNbZF0uaWQoKTtcbiAgICAgIG1hc2tbaWQgPj4gN10gJj0gfigweDEgPDwgKGlkICYgMHgzZikpO1xuICAgIH1cbiAgICByZXR1cm4gbWFzaztcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBkYXRhIGVsZW1lbnQgYXQgaW5kZXggaSBpcyBmaWx0ZXJlZCBJTi5cbiAgLy8gT3B0aW9uYWxseSwgaWdub3JlIHRoZSBmaWx0ZXJzIG9mIGFueSBkaW1lbnNpb25zIGluIHRoZSBpZ25vcmVfZGltZW5zaW9ucyBsaXN0LlxuICBmdW5jdGlvbiBpc0VsZW1lbnRGaWx0ZXJlZChpLCBpZ25vcmVfZGltZW5zaW9ucykge1xuICAgIHZhciBtYXNrID0gbWFza0ZvckRpbWVuc2lvbnMoaWdub3JlX2RpbWVuc2lvbnMgfHwgW10pO1xuICAgIHJldHVybiBmaWx0ZXJzLnplcm9FeGNlcHRNYXNrKGksbWFzayk7XG4gIH1cblxuICAvLyBBZGRzIGEgbmV3IGRpbWVuc2lvbiB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUgYWNjZXNzb3IgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIGRpbWVuc2lvbih2YWx1ZSwgaXRlcmFibGUpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgYWNjZXNzb3JQYXRoID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHJlc3VsdChkLCBhY2Nlc3NvclBhdGgpOyB9O1xuICAgIH1cblxuICAgIHZhciBkaW1lbnNpb24gPSB7XG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIGZpbHRlckV4YWN0OiBmaWx0ZXJFeGFjdCxcbiAgICAgIGZpbHRlclJhbmdlOiBmaWx0ZXJSYW5nZSxcbiAgICAgIGZpbHRlckZ1bmN0aW9uOiBmaWx0ZXJGdW5jdGlvbixcbiAgICAgIGZpbHRlckFsbDogZmlsdGVyQWxsLFxuICAgICAgY3VycmVudEZpbHRlcjogY3VycmVudEZpbHRlcixcbiAgICAgIGhhc0N1cnJlbnRGaWx0ZXI6IGhhc0N1cnJlbnRGaWx0ZXIsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgZ3JvdXBBbGw6IGdyb3VwQWxsLFxuICAgICAgZGlzcG9zZTogZGlzcG9zZSxcbiAgICAgIHJlbW92ZTogZGlzcG9zZSwgLy8gZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICBhY2Nlc3NvcjogdmFsdWUsXG4gICAgICBpZDogZnVuY3Rpb24oKSB7IHJldHVybiBpZDsgfVxuICAgIH07XG5cbiAgICB2YXIgb25lLCAvLyBsb3dlc3QgdW5zZXQgYml0IGFzIG1hc2ssIGUuZy4sIDAwMDAxMDAwXG4gICAgICAgIHplcm8sIC8vIGludmVydGVkIG9uZSwgZS5nLiwgMTExMTAxMTFcbiAgICAgICAgb2Zmc2V0LCAvLyBvZmZzZXQgaW50byB0aGUgZmlsdGVycyBhcnJheXNcbiAgICAgICAgaWQsIC8vIHVuaXF1ZSBJRCBmb3IgdGhpcyBkaW1lbnNpb24gKHJldXNlZCB3aGVuIGRpbWVuc2lvbnMgYXJlIGRpc3Bvc2VkKVxuICAgICAgICB2YWx1ZXMsIC8vIHNvcnRlZCwgY2FjaGVkIGFycmF5XG4gICAgICAgIGluZGV4LCAvLyBtYXBzIHNvcnRlZCB2YWx1ZSBpbmRleCAtPiByZWNvcmQgaW5kZXggKGluIGRhdGEpXG4gICAgICAgIG5ld1ZhbHVlcywgLy8gdGVtcG9yYXJ5IGFycmF5IHN0b3JpbmcgbmV3bHktYWRkZWQgdmFsdWVzXG4gICAgICAgIG5ld0luZGV4LCAvLyB0ZW1wb3JhcnkgYXJyYXkgc3RvcmluZyBuZXdseS1hZGRlZCBpbmRleFxuICAgICAgICBpdGVyYWJsZXNJbmRleENvdW50LFxuICAgICAgICBuZXdJdGVyYWJsZXNJbmRleENvdW50LFxuICAgICAgICBpdGVyYWJsZXNJbmRleEZpbHRlclN0YXR1cyxcbiAgICAgICAgbmV3SXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXMsXG4gICAgICAgIGl0ZXJhYmxlc0VtcHR5Um93cyA9IFtdLFxuICAgICAgICBzb3J0ID0gcXVpY2tzb3J0LmJ5KGZ1bmN0aW9uKGkpIHsgcmV0dXJuIG5ld1ZhbHVlc1tpXTsgfSksXG4gICAgICAgIHJlZmlsdGVyID0geGZpbHRlckZpbHRlci5maWx0ZXJBbGwsIC8vIGZvciByZWNvbXB1dGluZyBmaWx0ZXJcbiAgICAgICAgcmVmaWx0ZXJGdW5jdGlvbiwgLy8gdGhlIGN1c3RvbSBmaWx0ZXIgZnVuY3Rpb24gaW4gdXNlXG4gICAgICAgIGZpbHRlclZhbHVlLCAvLyB0aGUgdmFsdWUgdXNlZCBmb3IgZmlsdGVyaW5nICh2YWx1ZSwgYXJyYXksIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZClcbiAgICAgICAgZmlsdGVyVmFsdWVQcmVzZW50LCAvLyB0cnVlIGlmIGZpbHRlclZhbHVlIGNvbnRhaW5zIHNvbWV0aGluZ1xuICAgICAgICBpbmRleExpc3RlbmVycyA9IFtdLCAvLyB3aGVuIGRhdGEgaXMgYWRkZWRcbiAgICAgICAgZGltZW5zaW9uR3JvdXBzID0gW10sXG4gICAgICAgIGxvMCA9IDAsXG4gICAgICAgIGhpMCA9IDAsXG4gICAgICAgIHQgPSAwLFxuICAgICAgICBrO1xuXG4gICAgLy8gVXBkYXRpbmcgYSBkaW1lbnNpb24gaXMgYSB0d28tc3RhZ2UgcHJvY2Vzcy4gRmlyc3QsIHdlIG11c3QgdXBkYXRlIHRoZVxuICAgIC8vIGFzc29jaWF0ZWQgZmlsdGVycyBmb3IgdGhlIG5ld2x5LWFkZGVkIHJlY29yZHMuIE9uY2UgYWxsIGRpbWVuc2lvbnMgaGF2ZVxuICAgIC8vIHVwZGF0ZWQgdGhlaXIgZmlsdGVycywgdGhlIGdyb3VwcyBhcmUgbm90aWZpZWQgdG8gdXBkYXRlLlxuICAgIGRhdGFMaXN0ZW5lcnMudW5zaGlmdChwcmVBZGQpO1xuICAgIGRhdGFMaXN0ZW5lcnMucHVzaChwb3N0QWRkKTtcblxuICAgIHJlbW92ZURhdGFMaXN0ZW5lcnMucHVzaChyZW1vdmVEYXRhKTtcblxuICAgIC8vIEFkZCBhIG5ldyBkaW1lbnNpb24gaW4gdGhlIGZpbHRlciBiaXRtYXAgYW5kIHN0b3JlIHRoZSBvZmZzZXQgYW5kIGJpdG1hc2suXG4gICAgdmFyIHRtcCA9IGZpbHRlcnMuYWRkKCk7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcbiAgICBvbmUgPSB0bXAub25lO1xuICAgIHplcm8gPSB+b25lO1xuXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgZGltZW5zaW9uXG4gICAgLy8gSURzIHdpbGwgYmUgcmUtdXNlZCBpZiBkaW1lbnNpb25zIGFyZSBkaXNwb3NlZC5cbiAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIHRoZSBJRCBpcyB0aGUgc3ViYXJyYXkgb2Zmc2V0IHNoaWZ0ZWQgbGVmdCA3IGJpdHMgb3InZCB3aXRoIHRoZVxuICAgIC8vIGJpdCBvZmZzZXQgb2YgdGhlIHNldCBiaXQgaW4gdGhlIGRpbWVuc2lvbidzIFwib25lXCIgbWFzay5cbiAgICBpZCA9IChvZmZzZXQgPDwgNykgfCAoTWF0aC5sb2cob25lKSAvIE1hdGgubG9nKDIpKTtcblxuICAgIHByZUFkZChkYXRhLCAwLCBuKTtcbiAgICBwb3N0QWRkKGRhdGEsIDAsIG4pO1xuXG4gICAgLy8gSW5jb3Jwb3JhdGVzIHRoZSBzcGVjaWZpZWQgbmV3IHJlY29yZHMgaW50byB0aGlzIGRpbWVuc2lvbi5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyBmaWx0ZXJzLCB2YWx1ZXMsIGFuZCBpbmRleC5cbiAgICBmdW5jdGlvbiBwcmVBZGQobmV3RGF0YSwgbjAsIG4xKSB7XG5cbiAgICAgIGlmIChpdGVyYWJsZSl7XG4gICAgICAgIC8vIENvdW50IGFsbCB0aGUgdmFsdWVzXG4gICAgICAgIHQgPSAwO1xuICAgICAgICBqID0gMDtcbiAgICAgICAgayA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkwID0gMDsgaTAgPCBuZXdEYXRhLmxlbmd0aDsgaTArKykge1xuICAgICAgICAgIGZvcihqID0gMCwgayA9IHZhbHVlKG5ld0RhdGFbaTBdKTsgaiA8IGsubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXdWYWx1ZXMgPSBbXTtcbiAgICAgICAgbmV3SXRlcmFibGVzSW5kZXhDb3VudCA9IGNyb3NzZmlsdGVyX3JhbmdlKG5ld0RhdGEubGVuZ3RoKTtcbiAgICAgICAgbmV3SXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXMgPSBjcm9zc2ZpbHRlcl9pbmRleCh0LDEpO1xuICAgICAgICB2YXIgdW5zb3J0ZWRJbmRleCA9IGNyb3NzZmlsdGVyX3JhbmdlKHQpO1xuXG4gICAgICAgIGZvciAodmFyIGwgPSAwLCBpbmRleDEgPSAwOyBpbmRleDEgPCBuZXdEYXRhLmxlbmd0aDsgaW5kZXgxKyspIHtcbiAgICAgICAgICBrID0gdmFsdWUobmV3RGF0YVtpbmRleDFdKVxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYoIWsubGVuZ3RoKXtcbiAgICAgICAgICAgIG5ld0l0ZXJhYmxlc0luZGV4Q291bnRbaW5kZXgxXSA9IDA7XG4gICAgICAgICAgICBpdGVyYWJsZXNFbXB0eVJvd3MucHVzaChpbmRleDEgKyBuMCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3SXRlcmFibGVzSW5kZXhDb3VudFtpbmRleDFdID0gay5sZW5ndGhcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbmV3VmFsdWVzLnB1c2goa1tqXSk7XG4gICAgICAgICAgICB1bnNvcnRlZEluZGV4W2xdID0gaW5kZXgxO1xuICAgICAgICAgICAgbCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgU29ydCBtYXAgdXNlZCB0byBzb3J0IGJvdGggdGhlIHZhbHVlcyBhbmQgdGhlIHZhbHVlVG9EYXRhIGluZGljZXNcbiAgICAgICAgdmFyIHNvcnRNYXAgPSBzb3J0KGNyb3NzZmlsdGVyX3JhbmdlKHQpLCAwLCB0KTtcblxuICAgICAgICAvLyBVc2UgdGhlIHNvcnRNYXAgdG8gc29ydCB0aGUgbmV3VmFsdWVzXG4gICAgICAgIG5ld1ZhbHVlcyA9IHBlcm11dGUobmV3VmFsdWVzLCBzb3J0TWFwKTtcblxuXG4gICAgICAgIC8vIFVzZSB0aGUgc29ydE1hcCB0byBzb3J0IHRoZSB1bnNvcnRlZEluZGV4IG1hcFxuICAgICAgICAvLyBuZXdJbmRleCBzaG91bGQgYmUgYSBtYXAgb2Ygc29ydGVkVmFsdWUgLT4gY3Jvc3NmaWx0ZXJEYXRhXG4gICAgICAgIG5ld0luZGV4ID0gcGVybXV0ZSh1bnNvcnRlZEluZGV4LCBzb3J0TWFwKVxuXG4gICAgICB9IGVsc2V7XG4gICAgICAgIC8vIFBlcm11dGUgbmV3IHZhbHVlcyBpbnRvIG5hdHVyYWwgb3JkZXIgdXNpbmcgYSBzdGFuZGFyZCBzb3J0ZWQgaW5kZXguXG4gICAgICAgIG5ld1ZhbHVlcyA9IG5ld0RhdGEubWFwKHZhbHVlKTtcbiAgICAgICAgbmV3SW5kZXggPSBzb3J0KGNyb3NzZmlsdGVyX3JhbmdlKG4xKSwgMCwgbjEpO1xuICAgICAgICBuZXdWYWx1ZXMgPSBwZXJtdXRlKG5ld1ZhbHVlcywgbmV3SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZihpdGVyYWJsZSkge1xuICAgICAgICBuMSA9IHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEJpc2VjdCBuZXdWYWx1ZXMgdG8gZGV0ZXJtaW5lIHdoaWNoIG5ldyByZWNvcmRzIGFyZSBzZWxlY3RlZC5cbiAgICAgIHZhciBib3VuZHMgPSByZWZpbHRlcihuZXdWYWx1ZXMpLCBsbzEgPSBib3VuZHNbMF0sIGhpMSA9IGJvdW5kc1sxXTtcbiAgICAgIGlmIChyZWZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4MiA9IDA7IGluZGV4MiA8IG4xOyArK2luZGV4Mikge1xuICAgICAgICAgIGlmICghcmVmaWx0ZXJGdW5jdGlvbihuZXdWYWx1ZXNbaW5kZXgyXSwgaW5kZXgyKSkge1xuICAgICAgICAgICAgZmlsdGVyc1tvZmZzZXRdW25ld0luZGV4W2luZGV4Ml0gKyBuMF0gfD0gb25lO1xuICAgICAgICAgICAgaWYoaXRlcmFibGUpIG5ld0l0ZXJhYmxlc0luZGV4RmlsdGVyU3RhdHVzW2luZGV4Ml0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXgzID0gMDsgaW5kZXgzIDwgbG8xOyArK2luZGV4Mykge1xuICAgICAgICAgIGZpbHRlcnNbb2Zmc2V0XVtuZXdJbmRleFtpbmRleDNdICsgbjBdIHw9IG9uZTtcbiAgICAgICAgICBpZihpdGVyYWJsZSkgbmV3SXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbaW5kZXgzXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5kZXg0ID0gaGkxOyBpbmRleDQgPCBuMTsgKytpbmRleDQpIHtcbiAgICAgICAgICBmaWx0ZXJzW29mZnNldF1bbmV3SW5kZXhbaW5kZXg0XSArIG4wXSB8PSBvbmU7XG4gICAgICAgICAgaWYoaXRlcmFibGUpIG5ld0l0ZXJhYmxlc0luZGV4RmlsdGVyU3RhdHVzW2luZGV4NF0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgZGltZW5zaW9uIHByZXZpb3VzbHkgaGFkIG5vIGRhdGEsIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBkbyB0aGVcbiAgICAgIC8vIG1vcmUgZXhwZW5zaXZlIG1lcmdlIG9wZXJhdGlvbjsgdXNlIHRoZSBuZXcgdmFsdWVzIGFuZCBpbmRleCBhcy1pcy5cbiAgICAgIGlmICghbjApIHtcbiAgICAgICAgdmFsdWVzID0gbmV3VmFsdWVzO1xuICAgICAgICBpbmRleCA9IG5ld0luZGV4O1xuICAgICAgICBpdGVyYWJsZXNJbmRleENvdW50ID0gbmV3SXRlcmFibGVzSW5kZXhDb3VudDtcbiAgICAgICAgaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXMgPSBuZXdJdGVyYWJsZXNJbmRleEZpbHRlclN0YXR1cztcbiAgICAgICAgbG8wID0gbG8xO1xuICAgICAgICBoaTAgPSBoaTE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuXG5cbiAgICAgIHZhciBvbGRWYWx1ZXMgPSB2YWx1ZXMsXG4gICAgICAgIG9sZEluZGV4ID0gaW5kZXgsXG4gICAgICAgIG9sZEl0ZXJhYmxlc0luZGV4RmlsdGVyU3RhdHVzID0gaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXMsXG4gICAgICAgIG9sZF9uMCxcbiAgICAgICAgaTEgPSAwO1xuXG4gICAgICBpMCA9IDA7XG5cbiAgICAgIGlmKGl0ZXJhYmxlKXtcbiAgICAgICAgb2xkX24wID0gbjBcbiAgICAgICAgbjAgPSBvbGRWYWx1ZXMubGVuZ3RoO1xuICAgICAgICBuMSA9IHRcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgbmV3IGFycmF5cyBpbnRvIHdoaWNoIHRvIG1lcmdlIG5ldyBhbmQgb2xkLlxuICAgICAgdmFsdWVzID0gaXRlcmFibGUgPyBuZXcgQXJyYXkobjAgKyBuMSkgOiBuZXcgQXJyYXkobik7XG4gICAgICBpbmRleCA9IGl0ZXJhYmxlID8gbmV3IEFycmF5KG4wICsgbjEpIDogY3Jvc3NmaWx0ZXJfaW5kZXgobiwgbik7XG4gICAgICBpZihpdGVyYWJsZSkgaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXMgPSBjcm9zc2ZpbHRlcl9pbmRleChuMCArIG4xLCAxKTtcblxuICAgICAgLy8gQ29uY2F0ZW5hdGUgdGhlIG5ld0l0ZXJhYmxlc0luZGV4Q291bnQgb250byB0aGUgb2xkIG9uZS5cbiAgICAgIGlmKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciBvbGRpaWNsZW5ndGggPSBpdGVyYWJsZXNJbmRleENvdW50Lmxlbmd0aDtcbiAgICAgICAgaXRlcmFibGVzSW5kZXhDb3VudCA9IHhmaWx0ZXJBcnJheS5hcnJheUxlbmd0aGVuKGl0ZXJhYmxlc0luZGV4Q291bnQsIG4pO1xuICAgICAgICBmb3IodmFyIGo9MDsgaitvbGRpaWNsZW5ndGggPCBuOyBqKyspIHtcbiAgICAgICAgICBpdGVyYWJsZXNJbmRleENvdW50W2orb2xkaWljbGVuZ3RoXSA9IG5ld0l0ZXJhYmxlc0luZGV4Q291bnRbal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgdGhlIG9sZCBhbmQgbmV3IHNvcnRlZCB2YWx1ZXMsIGFuZCBvbGQgYW5kIG5ldyBpbmRleC5cbiAgICAgIHZhciBpbmRleDUgPSAwO1xuICAgICAgZm9yICg7IGkwIDwgbjAgJiYgaTEgPCBuMTsgKytpbmRleDUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlc1tpMF0gPCBuZXdWYWx1ZXNbaTFdKSB7XG4gICAgICAgICAgdmFsdWVzW2luZGV4NV0gPSBvbGRWYWx1ZXNbaTBdO1xuICAgICAgICAgIGlmKGl0ZXJhYmxlKSBpdGVyYWJsZXNJbmRleEZpbHRlclN0YXR1c1tpbmRleDVdID0gb2xkSXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbaTBdO1xuICAgICAgICAgIGluZGV4W2luZGV4NV0gPSBvbGRJbmRleFtpMCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXg1XSA9IG5ld1ZhbHVlc1tpMV07XG4gICAgICAgICAgaWYoaXRlcmFibGUpIGl0ZXJhYmxlc0luZGV4RmlsdGVyU3RhdHVzW2luZGV4NV0gPSBuZXdJdGVyYWJsZXNJbmRleEZpbHRlclN0YXR1c1tpMV07XG4gICAgICAgICAgaW5kZXhbaW5kZXg1XSA9IG5ld0luZGV4W2kxKytdICsgKGl0ZXJhYmxlID8gb2xkX24wIDogbjApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhbnkgcmVtYWluaW5nIG9sZCB2YWx1ZXMuXG4gICAgICBmb3IgKDsgaTAgPCBuMDsgKytpMCwgKytpbmRleDUpIHtcbiAgICAgICAgdmFsdWVzW2luZGV4NV0gPSBvbGRWYWx1ZXNbaTBdO1xuICAgICAgICBpZihpdGVyYWJsZSkgaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbaW5kZXg1XSA9IG9sZEl0ZXJhYmxlc0luZGV4RmlsdGVyU3RhdHVzW2kwXTtcbiAgICAgICAgaW5kZXhbaW5kZXg1XSA9IG9sZEluZGV4W2kwXTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGFueSByZW1haW5pbmcgbmV3IHZhbHVlcy5cbiAgICAgIGZvciAoOyBpMSA8IG4xOyArK2kxLCArK2luZGV4NSkge1xuICAgICAgICB2YWx1ZXNbaW5kZXg1XSA9IG5ld1ZhbHVlc1tpMV07XG4gICAgICAgIGlmKGl0ZXJhYmxlKSBpdGVyYWJsZXNJbmRleEZpbHRlclN0YXR1c1tpbmRleDVdID0gbmV3SXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbaTFdO1xuICAgICAgICBpbmRleFtpbmRleDVdID0gbmV3SW5kZXhbaTFdICsgKGl0ZXJhYmxlID8gb2xkX24wIDogbjApO1xuICAgICAgfVxuXG4gICAgICAvLyBCaXNlY3QgYWdhaW4gdG8gcmVjb21wdXRlIGxvMCBhbmQgaGkwLlxuICAgICAgYm91bmRzID0gcmVmaWx0ZXIodmFsdWVzKSwgbG8wID0gYm91bmRzWzBdLCBoaTAgPSBib3VuZHNbMV07XG4gICAgfVxuXG4gICAgLy8gV2hlbiBhbGwgZmlsdGVycyBoYXZlIHVwZGF0ZWQsIG5vdGlmeSBpbmRleCBsaXN0ZW5lcnMgb2YgdGhlIG5ldyB2YWx1ZXMuXG4gICAgZnVuY3Rpb24gcG9zdEFkZChuZXdEYXRhLCBuMCwgbjEpIHtcbiAgICAgIGluZGV4TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obCkgeyBsKG5ld1ZhbHVlcywgbmV3SW5kZXgsIG4wLCBuMSk7IH0pO1xuICAgICAgbmV3VmFsdWVzID0gbmV3SW5kZXggPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZURhdGEocmVJbmRleCkge1xuICAgICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwOyBpMCA8IGl0ZXJhYmxlc0VtcHR5Um93cy5sZW5ndGg7IGkwKyspIHtcbiAgICAgICAgICBpZiAocmVJbmRleFtpdGVyYWJsZXNFbXB0eVJvd3NbaTBdXSAhPT0gUkVNT1ZFRF9JTkRFWCkge1xuICAgICAgICAgICAgaXRlcmFibGVzRW1wdHlSb3dzW2kxXSA9IHJlSW5kZXhbaXRlcmFibGVzRW1wdHlSb3dzW2kwXV07XG4gICAgICAgICAgICBpMSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVyYWJsZXNFbXB0eVJvd3MubGVuZ3RoID0gaTE7XG4gICAgICAgIGZvciAoaTAgPSAwLCBpMSA9IDA7IGkwIDwgbjsgaTArKykge1xuICAgICAgICAgIGlmIChyZUluZGV4W2kwXSAhPT0gUkVNT1ZFRF9JTkRFWCkge1xuICAgICAgICAgICAgaWYgKGkxICE9PSBpMCkgaXRlcmFibGVzSW5kZXhDb3VudFtpMV0gPSBpdGVyYWJsZXNJbmRleENvdW50W2kwXTtcbiAgICAgICAgICAgIGkxKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZXJhYmxlc0luZGV4Q291bnQubGVuZ3RoID0gaTE7XG4gICAgICB9XG4gICAgICAvLyBSZXdyaXRlIG91ciBpbmRleCwgb3ZlcndyaXRpbmcgcmVtb3ZlZCB2YWx1ZXNcbiAgICAgIHZhciBuMCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDAsIG9sZERhdGFJbmRleDsgaSA8IG4wOyArK2kpIHtcbiAgICAgICAgb2xkRGF0YUluZGV4ID0gaW5kZXhbaV07XG4gICAgICAgIGlmIChyZUluZGV4W29sZERhdGFJbmRleF0gIT09IFJFTU9WRURfSU5ERVgpIHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikgdmFsdWVzW2pdID0gdmFsdWVzW2ldO1xuICAgICAgICAgIGluZGV4W2pdID0gcmVJbmRleFtvbGREYXRhSW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgICAgICAgaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbal0gPSBpdGVyYWJsZXNJbmRleEZpbHRlclN0YXR1c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZXMubGVuZ3RoID0gajtcbiAgICAgIGlmIChpdGVyYWJsZSkgaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXMubGVuZ3RoID0gajtcbiAgICAgIHdoaWxlIChqIDwgbjApIGluZGV4W2orK10gPSAwO1xuXG4gICAgICAvLyBCaXNlY3QgYWdhaW4gdG8gcmVjb21wdXRlIGxvMCBhbmQgaGkwLlxuICAgICAgdmFyIGJvdW5kcyA9IHJlZmlsdGVyKHZhbHVlcyk7XG4gICAgICBsbzAgPSBib3VuZHNbMF0sIGhpMCA9IGJvdW5kc1sxXTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGVzIHRoZSBzZWxlY3RlZCB2YWx1ZXMgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBib3VuZHMgW2xvLCBoaV0uXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGJ5IGFsbCB0aGUgcHVibGljIGZpbHRlciBtZXRob2RzLlxuICAgIGZ1bmN0aW9uIGZpbHRlckluZGV4Qm91bmRzKGJvdW5kcykge1xuXG4gICAgICB2YXIgbG8xID0gYm91bmRzWzBdLFxuICAgICAgICAgIGhpMSA9IGJvdW5kc1sxXTtcblxuICAgICAgaWYgKHJlZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgcmVmaWx0ZXJGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIGZpbHRlckluZGV4RnVuY3Rpb24oZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gbG8xIDw9IGkgJiYgaSA8IGhpMTsgfSwgYm91bmRzWzBdID09PSAwICYmIGJvdW5kc1sxXSA9PT0gdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGxvMCA9IGxvMTtcbiAgICAgICAgaGkwID0gaGkxO1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGssXG4gICAgICAgICAgYWRkZWQgPSBbXSxcbiAgICAgICAgICByZW1vdmVkID0gW10sXG4gICAgICAgICAgdmFsdWVJbmRleEFkZGVkID0gW10sXG4gICAgICAgICAgdmFsdWVJbmRleFJlbW92ZWQgPSBbXTtcblxuXG4gICAgICAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBsbyBpbmRleC5cbiAgICAgIGlmIChsbzEgPCBsbzApIHtcbiAgICAgICAgZm9yIChpID0gbG8xLCBqID0gTWF0aC5taW4obG8wLCBoaTEpOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgYWRkZWQucHVzaChpbmRleFtpXSk7XG4gICAgICAgICAgdmFsdWVJbmRleEFkZGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG8xID4gbG8wKSB7XG4gICAgICAgIGZvciAoaSA9IGxvMCwgaiA9IE1hdGgubWluKGxvMSwgaGkwKTsgaSA8IGo7ICsraSkge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChpbmRleFtpXSk7XG4gICAgICAgICAgdmFsdWVJbmRleFJlbW92ZWQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBoaSBpbmRleC5cbiAgICAgIGlmIChoaTEgPiBoaTApIHtcbiAgICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8xLCBoaTApLCBqID0gaGkxOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgYWRkZWQucHVzaChpbmRleFtpXSk7XG4gICAgICAgICAgdmFsdWVJbmRleEFkZGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGkxIDwgaGkwKSB7XG4gICAgICAgIGZvciAoaSA9IE1hdGgubWF4KGxvMCwgaGkxKSwgaiA9IGhpMDsgaSA8IGo7ICsraSkge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChpbmRleFtpXSk7XG4gICAgICAgICAgdmFsdWVJbmRleFJlbW92ZWQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZighaXRlcmFibGUpIHtcbiAgICAgICAgLy8gRmxpcCBmaWx0ZXJzIG5vcm1hbGx5LlxuXG4gICAgICAgIGZvcihpPTA7IGk8YWRkZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmaWx0ZXJzW29mZnNldF1bYWRkZWRbaV1dIF49IG9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpPTA7IGk8cmVtb3ZlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpbHRlcnNbb2Zmc2V0XVtyZW1vdmVkW2ldXSBePSBvbmU7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIGl0ZXJhYmxlcywgd2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoZSByb3cgaGFzIGJlZW4gY29tcGxldGVseSByZW1vdmVkIHZzIHBhcnRpYWxseSBpbmNsdWRlZFxuICAgICAgICAvLyBPbmx5IGNvdW50IGEgcm93IGFzIGFkZGVkIGlmIGl0IGlzIG5vdCBhbHJlYWR5IGJlaW5nIGFnZ3JlZ2F0ZWQuIE9ubHkgY291bnQgYSByb3dcbiAgICAgICAgLy8gYXMgcmVtb3ZlZCBpZiB0aGUgbGFzdCBlbGVtZW50IGJlaW5nIGFnZ3JlZ2F0ZWQgaXMgcmVtb3ZlZC5cblxuICAgICAgICB2YXIgbmV3QWRkZWQgPSBbXTtcbiAgICAgICAgdmFyIG5ld1JlbW92ZWQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFkZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlcmFibGVzSW5kZXhDb3VudFthZGRlZFtpXV0rK1xuICAgICAgICAgIGl0ZXJhYmxlc0luZGV4RmlsdGVyU3RhdHVzW3ZhbHVlSW5kZXhBZGRlZFtpXV0gPSAwO1xuICAgICAgICAgIGlmKGl0ZXJhYmxlc0luZGV4Q291bnRbYWRkZWRbaV1dID09PSAxKSB7XG4gICAgICAgICAgICBmaWx0ZXJzW29mZnNldF1bYWRkZWRbaV1dIF49IG9uZTtcbiAgICAgICAgICAgIG5ld0FkZGVkLnB1c2goYWRkZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZXJhYmxlc0luZGV4Q291bnRbcmVtb3ZlZFtpXV0tLVxuICAgICAgICAgIGl0ZXJhYmxlc0luZGV4RmlsdGVyU3RhdHVzW3ZhbHVlSW5kZXhSZW1vdmVkW2ldXSA9IDE7XG4gICAgICAgICAgaWYoaXRlcmFibGVzSW5kZXhDb3VudFtyZW1vdmVkW2ldXSA9PT0gMCkge1xuICAgICAgICAgICAgZmlsdGVyc1tvZmZzZXRdW3JlbW92ZWRbaV1dIF49IG9uZTtcbiAgICAgICAgICAgIG5ld1JlbW92ZWQucHVzaChyZW1vdmVkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhZGRlZCA9IG5ld0FkZGVkO1xuICAgICAgICByZW1vdmVkID0gbmV3UmVtb3ZlZDtcblxuICAgICAgICAvLyBOb3cgaGFuZGxlIGVtcHR5IHJvd3MuXG4gICAgICAgIGlmKGJvdW5kc1swXSA9PT0gMCAmJiBib3VuZHNbMV0gPT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBpdGVyYWJsZXNFbXB0eVJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKChmaWx0ZXJzW29mZnNldF1bayA9IGl0ZXJhYmxlc0VtcHR5Um93c1tpXV0gJiBvbmUpKSB7XG4gICAgICAgICAgICAgIC8vIFdhcyBub3QgaW4gdGhlIGZpbHRlciwgc28gc2V0IHRoZSBmaWx0ZXIgYW5kIGFkZFxuICAgICAgICAgICAgICBmaWx0ZXJzW29mZnNldF1ba10gXj0gb25lO1xuICAgICAgICAgICAgICBhZGRlZC5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaWx0ZXIgaW4gcGxhY2UgLSByZW1vdmUgZW1wdHkgcm93cyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBpdGVyYWJsZXNFbXB0eVJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKCEoZmlsdGVyc1tvZmZzZXRdW2sgPSBpdGVyYWJsZXNFbXB0eVJvd3NbaV1dICYgb25lKSkge1xuICAgICAgICAgICAgICAvLyBXYXMgaW4gdGhlIGZpbHRlciwgc28gc2V0IHRoZSBmaWx0ZXIgYW5kIHJlbW92ZVxuICAgICAgICAgICAgICBmaWx0ZXJzW29mZnNldF1ba10gXj0gb25lO1xuICAgICAgICAgICAgICByZW1vdmVkLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxvMCA9IGxvMTtcbiAgICAgIGhpMCA9IGhpMTtcbiAgICAgIGZpbHRlckxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbChvbmUsIG9mZnNldCwgYWRkZWQsIHJlbW92ZWQpOyB9KTtcbiAgICAgIHRyaWdnZXJPbkNoYW5nZSgnZmlsdGVyZWQnKTtcbiAgICAgIHJldHVybiBkaW1lbnNpb247XG4gICAgfVxuXG4gICAgLy8gRmlsdGVycyB0aGlzIGRpbWVuc2lvbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhbmdlLCB2YWx1ZSwgb3IgbnVsbC5cbiAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgbnVsbCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGZpbHRlckFsbC5cbiAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgYW4gYXJyYXksIHRoaXMgaXMgZXF1aXZhbGVudCB0byBmaWx0ZXJSYW5nZS5cbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBmaWx0ZXJFeGFjdC5cbiAgICBmdW5jdGlvbiBmaWx0ZXIocmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZSA9PSBudWxsXG4gICAgICAgICAgPyBmaWx0ZXJBbGwoKSA6IEFycmF5LmlzQXJyYXkocmFuZ2UpXG4gICAgICAgICAgPyBmaWx0ZXJSYW5nZShyYW5nZSkgOiB0eXBlb2YgcmFuZ2UgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZmlsdGVyRnVuY3Rpb24ocmFuZ2UpXG4gICAgICAgICAgOiBmaWx0ZXJFeGFjdChyYW5nZSk7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVycyB0aGlzIGRpbWVuc2lvbiB0byBzZWxlY3QgdGhlIGV4YWN0IHZhbHVlLlxuICAgIGZ1bmN0aW9uIGZpbHRlckV4YWN0KHZhbHVlKSB7XG4gICAgICBmaWx0ZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgZmlsdGVyVmFsdWVQcmVzZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmaWx0ZXJJbmRleEJvdW5kcygocmVmaWx0ZXIgPSB4ZmlsdGVyRmlsdGVyLmZpbHRlckV4YWN0KGJpc2VjdCwgdmFsdWUpKSh2YWx1ZXMpKTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXJzIHRoaXMgZGltZW5zaW9uIHRvIHNlbGVjdCB0aGUgc3BlY2lmaWVkIHJhbmdlIFtsbywgaGldLlxuICAgIC8vIFRoZSBsb3dlciBib3VuZCBpcyBpbmNsdXNpdmUsIGFuZCB0aGUgdXBwZXIgYm91bmQgaXMgZXhjbHVzaXZlLlxuICAgIGZ1bmN0aW9uIGZpbHRlclJhbmdlKHJhbmdlKSB7XG4gICAgICBmaWx0ZXJWYWx1ZSA9IHJhbmdlO1xuICAgICAgZmlsdGVyVmFsdWVQcmVzZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmaWx0ZXJJbmRleEJvdW5kcygocmVmaWx0ZXIgPSB4ZmlsdGVyRmlsdGVyLmZpbHRlclJhbmdlKGJpc2VjdCwgcmFuZ2UpKSh2YWx1ZXMpKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhcnMgYW55IGZpbHRlcnMgb24gdGhpcyBkaW1lbnNpb24uXG4gICAgZnVuY3Rpb24gZmlsdGVyQWxsKCkge1xuICAgICAgZmlsdGVyVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICBmaWx0ZXJWYWx1ZVByZXNlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmaWx0ZXJJbmRleEJvdW5kcygocmVmaWx0ZXIgPSB4ZmlsdGVyRmlsdGVyLmZpbHRlckFsbCkodmFsdWVzKSk7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVycyB0aGlzIGRpbWVuc2lvbiB1c2luZyBhbiBhcmJpdHJhcnkgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb24gZmlsdGVyRnVuY3Rpb24oZikge1xuICAgICAgZmlsdGVyVmFsdWUgPSBmO1xuICAgICAgZmlsdGVyVmFsdWVQcmVzZW50ID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgcmVmaWx0ZXJGdW5jdGlvbiA9IGY7XG4gICAgICByZWZpbHRlciA9IHhmaWx0ZXJGaWx0ZXIuZmlsdGVyQWxsO1xuXG4gICAgICBmaWx0ZXJJbmRleEZ1bmN0aW9uKGYsIGZhbHNlKTtcblxuICAgICAgdmFyIGJvdW5kcyA9IHJlZmlsdGVyKHZhbHVlcyk7XG4gICAgICBsbzAgPSBib3VuZHNbMF0sIGhpMCA9IGJvdW5kc1sxXTtcblxuICAgICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJJbmRleEZ1bmN0aW9uKGYsIGZpbHRlckFsbCkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgayxcbiAgICAgICAgICB4LFxuICAgICAgICAgIGFkZGVkID0gW10sXG4gICAgICAgICAgcmVtb3ZlZCA9IFtdLFxuICAgICAgICAgIHZhbHVlSW5kZXhBZGRlZCA9IFtdLFxuICAgICAgICAgIHZhbHVlSW5kZXhSZW1vdmVkID0gW10sXG4gICAgICAgICAgaW5kZXhMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZighaXRlcmFibGUpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGV4TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIShmaWx0ZXJzW29mZnNldF1bayA9IGluZGV4W2ldXSAmIG9uZSkgXiAhISh4ID0gZih2YWx1ZXNbaV0sIGkpKSkge1xuICAgICAgICAgICAgaWYgKHgpIGFkZGVkLnB1c2goayk7XG4gICAgICAgICAgICBlbHNlIHJlbW92ZWQucHVzaChrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoaXRlcmFibGUpIHtcbiAgICAgICAgZm9yKGk9MDsgaSA8IGluZGV4TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZihmKHZhbHVlc1tpXSwgaSkpIHtcbiAgICAgICAgICAgIGFkZGVkLnB1c2goaW5kZXhbaV0pO1xuICAgICAgICAgICAgdmFsdWVJbmRleEFkZGVkLnB1c2goaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChpbmRleFtpXSk7XG4gICAgICAgICAgICB2YWx1ZUluZGV4UmVtb3ZlZC5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZighaXRlcmFibGUpIHtcbiAgICAgICAgZm9yKGk9MDsgaTxhZGRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKGZpbHRlcnNbb2Zmc2V0XVthZGRlZFtpXV0gJiBvbmUpIGZpbHRlcnNbb2Zmc2V0XVthZGRlZFtpXV0gJj0gemVybztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpPTA7IGk8cmVtb3ZlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKCEoZmlsdGVyc1tvZmZzZXRdW3JlbW92ZWRbaV1dICYgb25lKSkgZmlsdGVyc1tvZmZzZXRdW3JlbW92ZWRbaV1dIHw9IG9uZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgbmV3QWRkZWQgPSBbXTtcbiAgICAgICAgdmFyIG5ld1JlbW92ZWQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFkZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgdGhpcyBwYXJ0aWN1bGFyIHZhbHVlIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgaWYoaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbdmFsdWVJbmRleEFkZGVkW2ldXSA9PT0gMSkge1xuICAgICAgICAgICAgaXRlcmFibGVzSW5kZXhDb3VudFthZGRlZFtpXV0rK1xuICAgICAgICAgICAgaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbdmFsdWVJbmRleEFkZGVkW2ldXSA9IDA7XG4gICAgICAgICAgICBpZihpdGVyYWJsZXNJbmRleENvdW50W2FkZGVkW2ldXSA9PT0gMSkge1xuICAgICAgICAgICAgICBmaWx0ZXJzW29mZnNldF1bYWRkZWRbaV1dIF49IG9uZTtcbiAgICAgICAgICAgICAgbmV3QWRkZWQucHVzaChhZGRlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgdGhpcyBwYXJ0aWN1bGFyIHZhbHVlIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICBpZihpdGVyYWJsZXNJbmRleEZpbHRlclN0YXR1c1t2YWx1ZUluZGV4UmVtb3ZlZFtpXV0gPT09IDApIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlc0luZGV4Q291bnRbcmVtb3ZlZFtpXV0tLVxuICAgICAgICAgICAgaXRlcmFibGVzSW5kZXhGaWx0ZXJTdGF0dXNbdmFsdWVJbmRleFJlbW92ZWRbaV1dID0gMTtcbiAgICAgICAgICAgIGlmKGl0ZXJhYmxlc0luZGV4Q291bnRbcmVtb3ZlZFtpXV0gPT09IDApIHtcbiAgICAgICAgICAgICAgZmlsdGVyc1tvZmZzZXRdW3JlbW92ZWRbaV1dIF49IG9uZTtcbiAgICAgICAgICAgICAgbmV3UmVtb3ZlZC5wdXNoKHJlbW92ZWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFkZGVkID0gbmV3QWRkZWQ7XG4gICAgICAgIHJlbW92ZWQgPSBuZXdSZW1vdmVkO1xuXG4gICAgICAgIC8vIE5vdyBoYW5kbGUgZW1wdHkgcm93cy5cbiAgICAgICAgaWYoZmlsdGVyQWxsKSB7XG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgaXRlcmFibGVzRW1wdHlSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZigoZmlsdGVyc1tvZmZzZXRdW2sgPSBpdGVyYWJsZXNFbXB0eVJvd3NbaV1dICYgb25lKSkge1xuICAgICAgICAgICAgICAvLyBXYXMgbm90IGluIHRoZSBmaWx0ZXIsIHNvIHNldCB0aGUgZmlsdGVyIGFuZCBhZGRcbiAgICAgICAgICAgICAgZmlsdGVyc1tvZmZzZXRdW2tdIF49IG9uZTtcbiAgICAgICAgICAgICAgYWRkZWQucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmlsdGVyIGluIHBsYWNlIC0gcmVtb3ZlIGVtcHR5IHJvd3MgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgaXRlcmFibGVzRW1wdHlSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZighKGZpbHRlcnNbb2Zmc2V0XVtrID0gaXRlcmFibGVzRW1wdHlSb3dzW2ldXSAmIG9uZSkpIHtcbiAgICAgICAgICAgICAgLy8gV2FzIGluIHRoZSBmaWx0ZXIsIHNvIHNldCB0aGUgZmlsdGVyIGFuZCByZW1vdmVcbiAgICAgICAgICAgICAgZmlsdGVyc1tvZmZzZXRdW2tdIF49IG9uZTtcbiAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaWx0ZXJMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihsKSB7IGwob25lLCBvZmZzZXQsIGFkZGVkLCByZW1vdmVkKTsgfSk7XG4gICAgICB0cmlnZ2VyT25DaGFuZ2UoJ2ZpbHRlcmVkJyk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGN1cnJlbnRGaWx0ZXIoKSB7XG4gICAgICByZXR1cm4gZmlsdGVyVmFsdWU7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGhhc0N1cnJlbnRGaWx0ZXIoKSB7XG4gICAgICByZXR1cm4gZmlsdGVyVmFsdWVQcmVzZW50O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBLIHNlbGVjdGVkIHJlY29yZHMgYmFzZWQgb24gdGhpcyBkaW1lbnNpb24ncyBvcmRlci5cbiAgICAvLyBOb3RlOiBvYnNlcnZlcyB0aGlzIGRpbWVuc2lvbidzIGZpbHRlciwgdW5saWtlIGdyb3VwIGFuZCBncm91cEFsbC5cbiAgICBmdW5jdGlvbiB0b3AoaywgdG9wX29mZnNldCkge1xuICAgICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgICAgaSA9IGhpMCxcbiAgICAgICAgICBqLFxuICAgICAgICAgIHRvU2tpcCA9IDA7XG5cbiAgICAgIGlmKHRvcF9vZmZzZXQgJiYgdG9wX29mZnNldCA+IDApIHRvU2tpcCA9IHRvcF9vZmZzZXQ7XG5cbiAgICAgIHdoaWxlICgtLWkgPj0gbG8wICYmIGsgPiAwKSB7XG4gICAgICAgIGlmIChmaWx0ZXJzLnplcm8oaiA9IGluZGV4W2ldKSkge1xuICAgICAgICAgIGlmKHRvU2tpcCA+IDApIHtcbiAgICAgICAgICAgIC8vc2tpcCBtYXRjaGluZyByb3dcbiAgICAgICAgICAgIC0tdG9Ta2lwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheS5wdXNoKGRhdGFbal0pO1xuICAgICAgICAgICAgLS1rO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihpdGVyYWJsZSl7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGl0ZXJhYmxlc0VtcHR5Um93cy5sZW5ndGggJiYgayA+IDA7IGkrKykge1xuICAgICAgICAgIC8vIEFkZCByb3cgd2l0aCBlbXB0eSBpdGVyYWJsZSBjb2x1bW4gYXQgdGhlIGVuZFxuICAgICAgICAgIGlmKGZpbHRlcnMuemVybyhqID0gaXRlcmFibGVzRW1wdHlSb3dzW2ldKSkge1xuICAgICAgICAgICAgaWYodG9Ta2lwID4gMCkge1xuICAgICAgICAgICAgICAvL3NraXAgbWF0Y2hpbmcgcm93XG4gICAgICAgICAgICAgIC0tdG9Ta2lwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJyYXkucHVzaChkYXRhW2pdKTtcbiAgICAgICAgICAgICAgLS1rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB0aGUgYm90dG9tIEsgc2VsZWN0ZWQgcmVjb3JkcyBiYXNlZCBvbiB0aGlzIGRpbWVuc2lvbidzIG9yZGVyLlxuICAgIC8vIE5vdGU6IG9ic2VydmVzIHRoaXMgZGltZW5zaW9uJ3MgZmlsdGVyLCB1bmxpa2UgZ3JvdXAgYW5kIGdyb3VwQWxsLlxuICAgIGZ1bmN0aW9uIGJvdHRvbShrLCBib3R0b21fb2Zmc2V0KSB7XG4gICAgICB2YXIgYXJyYXkgPSBbXSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgdG9Ta2lwID0gMDtcblxuICAgICAgaWYoYm90dG9tX29mZnNldCAmJiBib3R0b21fb2Zmc2V0ID4gMCkgdG9Ta2lwID0gYm90dG9tX29mZnNldDtcblxuICAgICAgaWYoaXRlcmFibGUpIHtcbiAgICAgICAgLy8gQWRkIHJvdyB3aXRoIGVtcHR5IGl0ZXJhYmxlIGNvbHVtbiBhdCB0aGUgdG9wXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGl0ZXJhYmxlc0VtcHR5Um93cy5sZW5ndGggJiYgayA+IDA7IGkrKykge1xuICAgICAgICAgIGlmKGZpbHRlcnMuemVybyhqID0gaXRlcmFibGVzRW1wdHlSb3dzW2ldKSkge1xuICAgICAgICAgICAgaWYodG9Ta2lwID4gMCkge1xuICAgICAgICAgICAgICAvL3NraXAgbWF0Y2hpbmcgcm93XG4gICAgICAgICAgICAgIC0tdG9Ta2lwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJyYXkucHVzaChkYXRhW2pdKTtcbiAgICAgICAgICAgICAgLS1rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpID0gbG8wO1xuXG4gICAgICB3aGlsZSAoaSA8IGhpMCAmJiBrID4gMCkge1xuICAgICAgICBpZiAoZmlsdGVycy56ZXJvKGogPSBpbmRleFtpXSkpIHtcbiAgICAgICAgICBpZih0b1NraXAgPiAwKSB7XG4gICAgICAgICAgICAvL3NraXAgbWF0Y2hpbmcgcm93XG4gICAgICAgICAgICAtLXRvU2tpcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXkucHVzaChkYXRhW2pdKTtcbiAgICAgICAgICAgIC0taztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLy8gQWRkcyBhIG5ldyBncm91cCB0byB0aGlzIGRpbWVuc2lvbiwgdXNpbmcgdGhlIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb24gZ3JvdXAoa2V5KSB7XG4gICAgICB2YXIgZ3JvdXAgPSB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBhbGw6IGFsbCxcbiAgICAgICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgICAgIHJlZHVjZUNvdW50OiByZWR1Y2VDb3VudCxcbiAgICAgICAgcmVkdWNlU3VtOiByZWR1Y2VTdW0sXG4gICAgICAgIG9yZGVyOiBvcmRlcixcbiAgICAgICAgb3JkZXJOYXR1cmFsOiBvcmRlck5hdHVyYWwsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGRpc3Bvc2U6IGRpc3Bvc2UsXG4gICAgICAgIHJlbW92ZTogZGlzcG9zZSAvLyBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiAgICAgIH07XG5cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMgZ3JvdXAgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGRpbWVuc2lvbiBpcyByZW1vdmVkLlxuICAgICAgZGltZW5zaW9uR3JvdXBzLnB1c2goZ3JvdXApO1xuXG4gICAgICB2YXIgZ3JvdXBzLCAvLyBhcnJheSBvZiB7a2V5LCB2YWx1ZX1cbiAgICAgICAgICBncm91cEluZGV4LCAvLyBvYmplY3QgaWQg4oamIGdyb3VwIGlkXG4gICAgICAgICAgZ3JvdXBXaWR0aCA9IDgsXG4gICAgICAgICAgZ3JvdXBDYXBhY2l0eSA9IGNyb3NzZmlsdGVyX2NhcGFjaXR5KGdyb3VwV2lkdGgpLFxuICAgICAgICAgIGsgPSAwLCAvLyBjYXJkaW5hbGl0eVxuICAgICAgICAgIHNlbGVjdCxcbiAgICAgICAgICBoZWFwLFxuICAgICAgICAgIHJlZHVjZUFkZCxcbiAgICAgICAgICByZWR1Y2VSZW1vdmUsXG4gICAgICAgICAgcmVkdWNlSW5pdGlhbCxcbiAgICAgICAgICB1cGRhdGUgPSBjcm9zc2ZpbHRlcl9udWxsLFxuICAgICAgICAgIHJlc2V0ID0gY3Jvc3NmaWx0ZXJfbnVsbCxcbiAgICAgICAgICByZXNldE5lZWRlZCA9IHRydWUsXG4gICAgICAgICAgZ3JvdXBBbGwgPSBrZXkgPT09IGNyb3NzZmlsdGVyX251bGwsXG4gICAgICAgICAgbjBvbGQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkga2V5ID0gY3Jvc3NmaWx0ZXJfaWRlbnRpdHk7XG5cbiAgICAgIC8vIFRoZSBncm91cCBsaXN0ZW5zIHRvIHRoZSBjcm9zc2ZpbHRlciBmb3Igd2hlbiBhbnkgZGltZW5zaW9uIGNoYW5nZXMsIHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiB1cGRhdGUgdGhlIGFzc29jaWF0ZWQgcmVkdWNlIHZhbHVlcy4gSXQgbXVzdCBhbHNvIGxpc3RlbiB0b1xuICAgICAgLy8gdGhlIHBhcmVudCBkaW1lbnNpb24gZm9yIHdoZW4gZGF0YSBpcyBhZGRlZCwgYW5kIGNvbXB1dGUgbmV3IGtleXMuXG4gICAgICBmaWx0ZXJMaXN0ZW5lcnMucHVzaCh1cGRhdGUpO1xuICAgICAgaW5kZXhMaXN0ZW5lcnMucHVzaChhZGQpO1xuICAgICAgcmVtb3ZlRGF0YUxpc3RlbmVycy5wdXNoKHJlbW92ZURhdGEpO1xuXG4gICAgICAvLyBJbmNvcnBvcmF0ZSBhbnkgZXhpc3RpbmcgZGF0YSBpbnRvIHRoZSBncm91cGluZy5cbiAgICAgIGFkZCh2YWx1ZXMsIGluZGV4LCAwLCBuKTtcblxuICAgICAgLy8gSW5jb3Jwb3JhdGVzIHRoZSBzcGVjaWZpZWQgbmV3IHZhbHVlcyBpbnRvIHRoaXMgZ3JvdXAuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyBncm91cHMgYW5kIGdyb3VwSW5kZXguXG4gICAgICBmdW5jdGlvbiBhZGQobmV3VmFsdWVzLCBuZXdJbmRleCwgbjAsIG4xKSB7XG5cbiAgICAgICAgaWYoaXRlcmFibGUpIHtcbiAgICAgICAgICBuMG9sZCA9IG4wXG4gICAgICAgICAgbjAgPSB2YWx1ZXMubGVuZ3RoIC0gbmV3VmFsdWVzLmxlbmd0aFxuICAgICAgICAgIG4xID0gbmV3VmFsdWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGRHcm91cHMgPSBncm91cHMsXG4gICAgICAgICAgICByZUluZGV4ID0gaXRlcmFibGUgPyBbXSA6IGNyb3NzZmlsdGVyX2luZGV4KGssIGdyb3VwQ2FwYWNpdHkpLFxuICAgICAgICAgICAgYWRkID0gcmVkdWNlQWRkLFxuICAgICAgICAgICAgcmVtb3ZlID0gcmVkdWNlUmVtb3ZlLFxuICAgICAgICAgICAgaW5pdGlhbCA9IHJlZHVjZUluaXRpYWwsXG4gICAgICAgICAgICBrMCA9IGssIC8vIG9sZCBjYXJkaW5hbGl0eVxuICAgICAgICAgICAgaTAgPSAwLCAvLyBpbmRleCBvZiBvbGQgZ3JvdXBcbiAgICAgICAgICAgIGkxID0gMCwgLy8gaW5kZXggb2YgbmV3IHJlY29yZFxuICAgICAgICAgICAgaiwgLy8gb2JqZWN0IGlkXG4gICAgICAgICAgICBnMCwgLy8gb2xkIGdyb3VwXG4gICAgICAgICAgICB4MCwgLy8gb2xkIGtleVxuICAgICAgICAgICAgeDEsIC8vIG5ldyBrZXlcbiAgICAgICAgICAgIGcsIC8vIGdyb3VwIHRvIGFkZFxuICAgICAgICAgICAgeDsgLy8ga2V5IG9mIGdyb3VwIHRvIGFkZFxuXG4gICAgICAgIC8vIElmIGEgcmVzZXQgaXMgbmVlZGVkLCB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgcmVkdWNlIHZhbHVlcy5cbiAgICAgICAgaWYgKHJlc2V0TmVlZGVkKSBhZGQgPSBpbml0aWFsID0gY3Jvc3NmaWx0ZXJfbnVsbDtcbiAgICAgICAgaWYgKHJlc2V0TmVlZGVkKSByZW1vdmUgPSBpbml0aWFsID0gY3Jvc3NmaWx0ZXJfbnVsbDtcblxuICAgICAgICAvLyBSZXNldCB0aGUgbmV3IGdyb3VwcyAoayBpcyBhIGxvd2VyIGJvdW5kKS5cbiAgICAgICAgLy8gQWxzbywgbWFrZSBzdXJlIHRoYXQgZ3JvdXBJbmRleCBleGlzdHMgYW5kIGlzIGxvbmcgZW5vdWdoLlxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkoayksIGsgPSAwO1xuICAgICAgICBpZihpdGVyYWJsZSl7XG4gICAgICAgICAgZ3JvdXBJbmRleCA9IGswID8gZ3JvdXBJbmRleCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgZ3JvdXBJbmRleCA9IGswID4gMSA/IHhmaWx0ZXJBcnJheS5hcnJheUxlbmd0aGVuKGdyb3VwSW5kZXgsIG4pIDogY3Jvc3NmaWx0ZXJfaW5kZXgobiwgZ3JvdXBDYXBhY2l0eSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEdldCB0aGUgZmlyc3Qgb2xkIGtleSAoeDAgb2YgZzApLCBpZiBpdCBleGlzdHMuXG4gICAgICAgIGlmIChrMCkgeDAgPSAoZzAgPSBvbGRHcm91cHNbMF0pLmtleTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBuZXcga2V5ICh4MSksIHNraXBwaW5nIE5hTiBrZXlzLlxuICAgICAgICB3aGlsZSAoaTEgPCBuMSAmJiAhKCh4MSA9IGtleShuZXdWYWx1ZXNbaTFdKSkgPj0geDEpKSArK2kxO1xuXG4gICAgICAgIC8vIFdoaWxlIG5ldyBrZXlzIHJlbWFpbuKAplxuICAgICAgICB3aGlsZSAoaTEgPCBuMSkge1xuXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBsZXNzZXIgb2YgdGhlIHR3byBjdXJyZW50IGtleXM7IG5ldyBhbmQgb2xkLlxuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvbGQga2V5cyByZW1haW5pbmcsIHRoZW4gYWx3YXlzIGFkZCB0aGUgbmV3IGtleS5cbiAgICAgICAgICBpZiAoZzAgJiYgeDAgPD0geDEpIHtcbiAgICAgICAgICAgIGcgPSBnMCwgeCA9IHgwO1xuXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIG5ldyBpbmRleCBvZiB0aGUgb2xkIGdyb3VwLlxuICAgICAgICAgICAgcmVJbmRleFtpMF0gPSBrO1xuXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbmV4dCBvbGQga2V5LlxuICAgICAgICAgICAgZzAgPSBvbGRHcm91cHNbKytpMF07XG4gICAgICAgICAgICBpZiAoZzApIHgwID0gZzAua2V5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnID0ge2tleTogeDEsIHZhbHVlOiBpbml0aWFsKCl9LCB4ID0geDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIHRoZSBsZXNzZXIgZ3JvdXAuXG4gICAgICAgICAgZ3JvdXBzW2tdID0gZztcblxuICAgICAgICAgIC8vIEFkZCBhbnkgc2VsZWN0ZWQgcmVjb3JkcyBiZWxvbmdpbmcgdG8gdGhlIGFkZGVkIGdyb3VwLCB3aGlsZVxuICAgICAgICAgIC8vIGFkdmFuY2luZyB0aGUgbmV3IGtleSBhbmQgcG9wdWxhdGluZyB0aGUgYXNzb2NpYXRlZCBncm91cCBpbmRleC5cblxuICAgICAgICAgIHdoaWxlICh4MSA8PSB4KSB7XG4gICAgICAgICAgICBqID0gbmV3SW5kZXhbaTFdICsgKGl0ZXJhYmxlID8gbjBvbGQgOiBuMClcblxuXG4gICAgICAgICAgICBpZihpdGVyYWJsZSl7XG4gICAgICAgICAgICAgIGlmKGdyb3VwSW5kZXhbal0pe1xuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXhbal0ucHVzaChrKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleFtqXSA9IFtrXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICBncm91cEluZGV4W2pdID0gaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWx3YXlzIGFkZCBuZXcgdmFsdWVzIHRvIGdyb3Vwcy4gT25seSByZW1vdmUgd2hlbiBub3QgaW4gZmlsdGVyLlxuICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyBncm91cHMgZnVsbCBpbmZvcm1hdGlvbiBvbiBkYXRhIGxpZmUtY3ljbGUuXG4gICAgICAgICAgICBnLnZhbHVlID0gYWRkKGcudmFsdWUsIGRhdGFbal0sIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJzLnplcm9FeGNlcHQoaiwgb2Zmc2V0LCB6ZXJvKSkgZy52YWx1ZSA9IHJlbW92ZShnLnZhbHVlLCBkYXRhW2pdLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoKytpMSA+PSBuMSkgYnJlYWs7XG4gICAgICAgICAgICB4MSA9IGtleShuZXdWYWx1ZXNbaTFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBncm91cEluY3JlbWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGFueSByZW1haW5pbmcgb2xkIGdyb3VwcyB0aGF0IHdlcmUgZ3JlYXRlciB0aDFhbiBhbGwgbmV3IGtleXMuXG4gICAgICAgIC8vIE5vIGluY3JlbWVudGFsIHJlZHVjZSBpcyBuZWVkZWQ7IHRoZXNlIGdyb3VwcyBoYXZlIG5vIG5ldyByZWNvcmRzLlxuICAgICAgICAvLyBBbHNvIHJlY29yZCB0aGUgbmV3IGluZGV4IG9mIHRoZSBvbGQgZ3JvdXAuXG4gICAgICAgIHdoaWxlIChpMCA8IGswKSB7XG4gICAgICAgICAgZ3JvdXBzW3JlSW5kZXhbaTBdID0ga10gPSBvbGRHcm91cHNbaTArK107XG4gICAgICAgICAgZ3JvdXBJbmNyZW1lbnQoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRmlsbCBpbiBnYXBzIHdpdGggZW1wdHkgYXJyYXlzIHdoZXJlIHRoZXJlIG1heSBoYXZlIGJlZW4gcm93cyB3aXRoIGVtcHR5IGl0ZXJhYmxlc1xuICAgICAgICBpZihpdGVyYWJsZSl7XG4gICAgICAgICAgZm9yICh2YXIgaW5kZXgxID0gMDsgaW5kZXgxIDwgbjsgaW5kZXgxKyspIHtcbiAgICAgICAgICAgIGlmKCFncm91cEluZGV4W2luZGV4MV0pe1xuICAgICAgICAgICAgICBncm91cEluZGV4W2luZGV4MV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBhZGRlZCBhbnkgbmV3IGdyb3VwcyBiZWZvcmUgYW55IG9sZCBncm91cHMsXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZ3JvdXAgaW5kZXggb2YgYWxsIHRoZSBvbGQgcmVjb3Jkcy5cbiAgICAgICAgaWYoayA+IGkwKXtcbiAgICAgICAgICBpZihpdGVyYWJsZSl7XG4gICAgICAgICAgICBmb3IgKGkwID0gMDsgaTAgPCBuMG9sZDsgKytpMCkge1xuICAgICAgICAgICAgICBmb3IgKGluZGV4MSA9IDA7IGluZGV4MSA8IGdyb3VwSW5kZXhbaTBdLmxlbmd0aDsgaW5kZXgxKyspIHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4W2kwXVtpbmRleDFdID0gcmVJbmRleFtncm91cEluZGV4W2kwXVtpbmRleDFdXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgZm9yIChpMCA9IDA7IGkwIDwgbjA7ICsraTApIHtcbiAgICAgICAgICAgICAgZ3JvdXBJbmRleFtpMF0gPSByZUluZGV4W2dyb3VwSW5kZXhbaTBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb2RpZnkgdGhlIHVwZGF0ZSBhbmQgcmVzZXQgYmVoYXZpb3IgYmFzZWQgb24gdGhlIGNhcmRpbmFsaXR5LlxuICAgICAgICAvLyBJZiB0aGUgY2FyZGluYWxpdHkgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG9uZSwgdGhlbiB0aGUgZ3JvdXBJbmRleFxuICAgICAgICAvLyBpcyBub3QgbmVlZGVkLiBJZiB0aGUgY2FyZGluYWxpdHkgaXMgemVybywgdGhlbiB0aGVyZSBhcmUgbm8gcmVjb3Jkc1xuICAgICAgICAvLyBhbmQgdGhlcmVmb3JlIG5vIGdyb3VwcyB0byB1cGRhdGUgb3IgcmVzZXQuIE5vdGUgdGhhdCB3ZSBhbHNvIG11c3RcbiAgICAgICAgLy8gY2hhbmdlIHRoZSByZWdpc3RlcmVkIGxpc3RlbmVyIHRvIHBvaW50IHRvIHRoZSBuZXcgbWV0aG9kLlxuICAgICAgICBqID0gZmlsdGVyTGlzdGVuZXJzLmluZGV4T2YodXBkYXRlKTtcbiAgICAgICAgaWYgKGsgPiAxIHx8IGl0ZXJhYmxlKSB7XG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlTWFueTtcbiAgICAgICAgICByZXNldCA9IHJlc2V0TWFueTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWsgJiYgZ3JvdXBBbGwpIHtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICAgICAgZ3JvdXBzID0gW3trZXk6IG51bGwsIHZhbHVlOiBpbml0aWFsKCl9XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZU9uZTtcbiAgICAgICAgICAgIHJlc2V0ID0gcmVzZXRPbmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZSA9IGNyb3NzZmlsdGVyX251bGw7XG4gICAgICAgICAgICByZXNldCA9IGNyb3NzZmlsdGVyX251bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyb3VwSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlckxpc3RlbmVyc1tqXSA9IHVwZGF0ZTtcblxuICAgICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGFkZGVkIGdyb3VwcyxcbiAgICAgICAgLy8gYW5kIHdpZGVuIHRoZSBncm91cCBpbmRleCBhcyBuZWVkZWQuXG4gICAgICAgIGZ1bmN0aW9uIGdyb3VwSW5jcmVtZW50KCkge1xuICAgICAgICAgIGlmKGl0ZXJhYmxlKXtcbiAgICAgICAgICAgIGsrK1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2sgPT09IGdyb3VwQ2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJlSW5kZXggPSB4ZmlsdGVyQXJyYXkuYXJyYXlXaWRlbihyZUluZGV4LCBncm91cFdpZHRoIDw8PSAxKTtcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSB4ZmlsdGVyQXJyYXkuYXJyYXlXaWRlbihncm91cEluZGV4LCBncm91cFdpZHRoKTtcbiAgICAgICAgICAgIGdyb3VwQ2FwYWNpdHkgPSBjcm9zc2ZpbHRlcl9jYXBhY2l0eShncm91cFdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlRGF0YShyZUluZGV4KSB7XG4gICAgICAgIGlmIChrID4gMSB8fCBpdGVyYWJsZSkge1xuICAgICAgICAgIHZhciBvbGRLID0gayxcbiAgICAgICAgICAgICAgb2xkR3JvdXBzID0gZ3JvdXBzLFxuICAgICAgICAgICAgICBzZWVuR3JvdXBzID0gY3Jvc3NmaWx0ZXJfaW5kZXgob2xkSywgb2xkSyksXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGkwLFxuICAgICAgICAgICAgICBqO1xuXG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBub24tbWF0Y2hlcyBieSBjb3B5aW5nIG1hdGNoaW5nIGdyb3VwIGluZGV4IGVudHJpZXMgdG9cbiAgICAgICAgICAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICBpZiAoIWl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICBpZiAocmVJbmRleFtpXSAhPT0gUkVNT1ZFRF9JTkRFWCkge1xuICAgICAgICAgICAgICAgIHNlZW5Hcm91cHNbZ3JvdXBJbmRleFtqXSA9IGdyb3VwSW5kZXhbaV1dID0gMTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHJlSW5kZXhbaV0gIT09IFJFTU9WRURfSU5ERVgpIHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4W2pdID0gZ3JvdXBJbmRleFtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkwID0gMDsgaTAgPCBncm91cEluZGV4W2pdLmxlbmd0aDsgaTArKykge1xuICAgICAgICAgICAgICAgICAgc2Vlbkdyb3Vwc1tncm91cEluZGV4W2pdW2kwXV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWFzc2VtYmxlIGdyb3VwcyBpbmNsdWRpbmcgb25seSB0aG9zZSBncm91cHMgdGhhdCB3ZXJlIHJlZmVycmVkXG4gICAgICAgICAgLy8gdG8gYnkgbWF0Y2hpbmcgZ3JvdXAgaW5kZXggZW50cmllcy4gIE5vdGUgdGhlIG5ldyBncm91cCBpbmRleCBpblxuICAgICAgICAgIC8vIHNlZW5Hcm91cHMuXG4gICAgICAgICAgZ3JvdXBzID0gW10sIGsgPSAwO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGRLOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChzZWVuR3JvdXBzW2ldKSB7XG4gICAgICAgICAgICAgIHNlZW5Hcm91cHNbaV0gPSBrKys7XG4gICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKG9sZEdyb3Vwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGsgPiAxIHx8IGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAvLyBSZWluZGV4IHRoZSBncm91cCBpbmRleCB1c2luZyBzZWVuR3JvdXBzIHRvIGZpbmQgdGhlIG5ldyBpbmRleC5cbiAgICAgICAgICAgIGlmICghaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGo7ICsraSkgZ3JvdXBJbmRleFtpXSA9IHNlZW5Hcm91cHNbZ3JvdXBJbmRleFtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpMCA9IDA7IGkwIDwgZ3JvdXBJbmRleFtpXS5sZW5ndGg7ICsraTApIHtcbiAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXhbaV1baTBdID0gc2Vlbkdyb3Vwc1tncm91cEluZGV4W2ldW2kwXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWx0ZXJMaXN0ZW5lcnNbZmlsdGVyTGlzdGVuZXJzLmluZGV4T2YodXBkYXRlKV0gPSBrID4gMSB8fCBpdGVyYWJsZVxuICAgICAgICAgICAgICA/IChyZXNldCA9IHJlc2V0TWFueSwgdXBkYXRlID0gdXBkYXRlTWFueSlcbiAgICAgICAgICAgICAgOiBrID09PSAxID8gKHJlc2V0ID0gcmVzZXRPbmUsIHVwZGF0ZSA9IHVwZGF0ZU9uZSlcbiAgICAgICAgICAgICAgOiByZXNldCA9IHVwZGF0ZSA9IGNyb3NzZmlsdGVyX251bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PT0gMSkge1xuICAgICAgICAgIGlmIChncm91cEFsbCkgcmV0dXJuO1xuICAgICAgICAgIGZvciAodmFyIGluZGV4MyA9IDA7IGluZGV4MyA8IG47ICsraW5kZXgzKSBpZiAocmVJbmRleFtpbmRleDNdICE9PSBSRU1PVkVEX0lOREVYKSByZXR1cm47XG4gICAgICAgICAgZ3JvdXBzID0gW10sIGsgPSAwO1xuICAgICAgICAgIGZpbHRlckxpc3RlbmVyc1tmaWx0ZXJMaXN0ZW5lcnMuaW5kZXhPZih1cGRhdGUpXSA9XG4gICAgICAgICAgdXBkYXRlID0gcmVzZXQgPSBjcm9zc2ZpbHRlcl9udWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZHVjZXMgdGhlIHNwZWNpZmllZCBzZWxlY3RlZCBvciBkZXNlbGVjdGVkIHJlY29yZHMuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCB3aGVuIHRoZSBjYXJkaW5hbGl0eSBpcyBncmVhdGVyIHRoYW4gMS5cbiAgICAgIC8vIG5vdEZpbHRlciBpbmRpY2F0ZXMgYSBjcm9zc2ZpbHRlci5hZGQvcmVtb3ZlIG9wZXJhdGlvbi5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnkoZmlsdGVyT25lLCBmaWx0ZXJPZmZzZXQsIGFkZGVkLCByZW1vdmVkLCBub3RGaWx0ZXIpIHtcblxuICAgICAgICBpZiAoKGZpbHRlck9uZSA9PT0gb25lICYmIGZpbHRlck9mZnNldCA9PT0gb2Zmc2V0KSB8fCByZXNldE5lZWRlZCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgZztcblxuICAgICAgICBpZihpdGVyYWJsZSl7XG4gICAgICAgICAgLy8gQWRkIHRoZSBhZGRlZCB2YWx1ZXMuXG4gICAgICAgICAgZm9yIChpID0gMCwgbiA9IGFkZGVkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKGZpbHRlcnMuemVyb0V4Y2VwdChrID0gYWRkZWRbaV0sIG9mZnNldCwgemVybykpIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdyb3VwSW5kZXhba10ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBnID0gZ3JvdXBzW2dyb3VwSW5kZXhba11bal1dO1xuICAgICAgICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VBZGQoZy52YWx1ZSwgZGF0YVtrXSwgZmFsc2UsIGopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZW1vdmVkIHZhbHVlcy5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzLm9ubHlFeGNlcHQoayA9IHJlbW92ZWRbaV0sIG9mZnNldCwgemVybywgZmlsdGVyT2Zmc2V0LCBmaWx0ZXJPbmUpKSB7XG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBncm91cEluZGV4W2tdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZyA9IGdyb3Vwc1tncm91cEluZGV4W2tdW2pdXTtcbiAgICAgICAgICAgICAgICBnLnZhbHVlID0gcmVkdWNlUmVtb3ZlKGcudmFsdWUsIGRhdGFba10sIG5vdEZpbHRlciwgaik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBhZGRlZCB2YWx1ZXMuXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBhZGRlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBpZiAoZmlsdGVycy56ZXJvRXhjZXB0KGsgPSBhZGRlZFtpXSwgb2Zmc2V0LCB6ZXJvKSkge1xuICAgICAgICAgICAgZyA9IGdyb3Vwc1tncm91cEluZGV4W2tdXTtcbiAgICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VBZGQoZy52YWx1ZSwgZGF0YVtrXSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVtb3ZlZCB2YWx1ZXMuXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSByZW1vdmVkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmIChmaWx0ZXJzLm9ubHlFeGNlcHQoayA9IHJlbW92ZWRbaV0sIG9mZnNldCwgemVybywgZmlsdGVyT2Zmc2V0LCBmaWx0ZXJPbmUpKSB7XG4gICAgICAgICAgICBnID0gZ3JvdXBzW2dyb3VwSW5kZXhba11dO1xuICAgICAgICAgICAgZy52YWx1ZSA9IHJlZHVjZVJlbW92ZShnLnZhbHVlLCBkYXRhW2tdLCBub3RGaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZWR1Y2VzIHRoZSBzcGVjaWZpZWQgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZCByZWNvcmRzLlxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiB0aGUgY2FyZGluYWxpdHkgaXMgMS5cbiAgICAgIC8vIG5vdEZpbHRlciBpbmRpY2F0ZXMgYSBjcm9zc2ZpbHRlci5hZGQvcmVtb3ZlIG9wZXJhdGlvbi5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9uZShmaWx0ZXJPbmUsIGZpbHRlck9mZnNldCwgYWRkZWQsIHJlbW92ZWQsIG5vdEZpbHRlcikge1xuICAgICAgICBpZiAoKGZpbHRlck9uZSA9PT0gb25lICYmIGZpbHRlck9mZnNldCA9PT0gb2Zmc2V0KSB8fCByZXNldE5lZWRlZCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICBnID0gZ3JvdXBzWzBdO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgYWRkZWQgdmFsdWVzLlxuICAgICAgICBmb3IgKGkgPSAwLCBuID0gYWRkZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKGZpbHRlcnMuemVyb0V4Y2VwdChrID0gYWRkZWRbaV0sIG9mZnNldCwgemVybykpIHtcbiAgICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VBZGQoZy52YWx1ZSwgZGF0YVtrXSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVtb3ZlZCB2YWx1ZXMuXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSByZW1vdmVkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmIChmaWx0ZXJzLm9ubHlFeGNlcHQoayA9IHJlbW92ZWRbaV0sIG9mZnNldCwgemVybywgZmlsdGVyT2Zmc2V0LCBmaWx0ZXJPbmUpKSB7XG4gICAgICAgICAgICBnLnZhbHVlID0gcmVkdWNlUmVtb3ZlKGcudmFsdWUsIGRhdGFba10sIG5vdEZpbHRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlY29tcHV0ZXMgdGhlIGdyb3VwIHJlZHVjZSB2YWx1ZXMgZnJvbSBzY3JhdGNoLlxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgd2hlbiB0aGUgY2FyZGluYWxpdHkgaXMgZ3JlYXRlciB0aGFuIDEuXG4gICAgICBmdW5jdGlvbiByZXNldE1hbnkoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGc7XG5cbiAgICAgICAgLy8gUmVzZXQgYWxsIGdyb3VwIHZhbHVlcy5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGs7ICsraSkge1xuICAgICAgICAgIGdyb3Vwc1tpXS52YWx1ZSA9IHJlZHVjZUluaXRpYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFkZCBhbGwgcmVjb3JkcyBhbmQgdGhlbiByZW1vdmUgZmlsdGVyZWQgcmVjb3JkcyBzbyB0aGF0IHJlZHVjZXJzXG4gICAgICAgIC8vIGNhbiBidWlsZCBhbiAndW5maWx0ZXJlZCcgdmlldyBldmVuIGlmIHRoZXJlIGFyZSBhbHJlYWR5IGZpbHRlcnMgaW5cbiAgICAgICAgLy8gcGxhY2Ugb24gb3RoZXIgZGltZW5zaW9ucy5cbiAgICAgICAgaWYoaXRlcmFibGUpe1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBncm91cEluZGV4W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGcgPSBncm91cHNbZ3JvdXBJbmRleFtpXVtqXV07XG4gICAgICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VBZGQoZy52YWx1ZSwgZGF0YVtpXSwgdHJ1ZSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghZmlsdGVycy56ZXJvRXhjZXB0KGksIG9mZnNldCwgemVybykpIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdyb3VwSW5kZXhbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBnID0gZ3JvdXBzW2dyb3VwSW5kZXhbaV1bal1dO1xuICAgICAgICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VSZW1vdmUoZy52YWx1ZSwgZGF0YVtpXSwgZmFsc2UsIGopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBnID0gZ3JvdXBzW2dyb3VwSW5kZXhbaV1dO1xuICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VBZGQoZy52YWx1ZSwgZGF0YVtpXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICghZmlsdGVycy56ZXJvRXhjZXB0KGksIG9mZnNldCwgemVybykpIHtcbiAgICAgICAgICAgIGcgPSBncm91cHNbZ3JvdXBJbmRleFtpXV07XG4gICAgICAgICAgICBnLnZhbHVlID0gcmVkdWNlUmVtb3ZlKGcudmFsdWUsIGRhdGFbaV0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVjb21wdXRlcyB0aGUgZ3JvdXAgcmVkdWNlIHZhbHVlcyBmcm9tIHNjcmF0Y2guXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCB3aGVuIHRoZSBjYXJkaW5hbGl0eSBpcyAxLlxuICAgICAgZnVuY3Rpb24gcmVzZXRPbmUoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZyA9IGdyb3Vwc1swXTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgc2luZ2xldG9uIGdyb3VwIHZhbHVlcy5cbiAgICAgICAgZy52YWx1ZSA9IHJlZHVjZUluaXRpYWwoKTtcblxuICAgICAgICAvLyBXZSBhZGQgYWxsIHJlY29yZHMgYW5kIHRoZW4gcmVtb3ZlIGZpbHRlcmVkIHJlY29yZHMgc28gdGhhdCByZWR1Y2Vyc1xuICAgICAgICAvLyBjYW4gYnVpbGQgYW4gJ3VuZmlsdGVyZWQnIHZpZXcgZXZlbiBpZiB0aGVyZSBhcmUgYWxyZWFkeSBmaWx0ZXJzIGluXG4gICAgICAgIC8vIHBsYWNlIG9uIG90aGVyIGRpbWVuc2lvbnMuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBnLnZhbHVlID0gcmVkdWNlQWRkKGcudmFsdWUsIGRhdGFbaV0sIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICghZmlsdGVycy56ZXJvRXhjZXB0KGksIG9mZnNldCwgemVybykpIHtcbiAgICAgICAgICAgIGcudmFsdWUgPSByZWR1Y2VSZW1vdmUoZy52YWx1ZSwgZGF0YVtpXSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cCB2YWx1ZXMsIGluIHRoZSBkaW1lbnNpb24ncyBuYXR1cmFsIG9yZGVyLlxuICAgICAgZnVuY3Rpb24gYWxsKCkge1xuICAgICAgICBpZiAocmVzZXROZWVkZWQpIHJlc2V0KCksIHJlc2V0TmVlZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybnMgYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgdG9wIEsgZ3JvdXAgdmFsdWVzLCBpbiByZWR1Y2Ugb3JkZXIuXG4gICAgICBmdW5jdGlvbiB0b3Aoaykge1xuICAgICAgICB2YXIgdG9wID0gc2VsZWN0KGFsbCgpLCAwLCBncm91cHMubGVuZ3RoLCBrKTtcbiAgICAgICAgcmV0dXJuIGhlYXAuc29ydCh0b3AsIDAsIHRvcC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXRzIHRoZSByZWR1Y2UgYmVoYXZpb3IgZm9yIHRoaXMgZ3JvdXAgdG8gdXNlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb25zLlxuICAgICAgLy8gVGhpcyBtZXRob2QgbGF6aWx5IHJlY29tcHV0ZXMgdGhlIHJlZHVjZSB2YWx1ZXMsIHdhaXRpbmcgdW50aWwgbmVlZGVkLlxuICAgICAgZnVuY3Rpb24gcmVkdWNlKGFkZCwgcmVtb3ZlLCBpbml0aWFsKSB7XG4gICAgICAgIHJlZHVjZUFkZCA9IGFkZDtcbiAgICAgICAgcmVkdWNlUmVtb3ZlID0gcmVtb3ZlO1xuICAgICAgICByZWR1Y2VJbml0aWFsID0gaW5pdGlhbDtcbiAgICAgICAgcmVzZXROZWVkZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG5cbiAgICAgIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciByZWR1Y2luZyBieSBjb3VudC5cbiAgICAgIGZ1bmN0aW9uIHJlZHVjZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gcmVkdWNlKHhmaWx0ZXJSZWR1Y2UucmVkdWNlSW5jcmVtZW50LCB4ZmlsdGVyUmVkdWNlLnJlZHVjZURlY3JlbWVudCwgY3Jvc3NmaWx0ZXJfemVybyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciByZWR1Y2luZyBieSBzdW0odmFsdWUpLlxuICAgICAgZnVuY3Rpb24gcmVkdWNlU3VtKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZWR1Y2UoeGZpbHRlclJlZHVjZS5yZWR1Y2VBZGQodmFsdWUpLCB4ZmlsdGVyUmVkdWNlLnJlZHVjZVN1YnRyYWN0KHZhbHVlKSwgY3Jvc3NmaWx0ZXJfemVybyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHMgdGhlIHJlZHVjZSBvcmRlciwgdXNpbmcgdGhlIHNwZWNpZmllZCBhY2Nlc3Nvci5cbiAgICAgIGZ1bmN0aW9uIG9yZGVyKHZhbHVlKSB7XG4gICAgICAgIHNlbGVjdCA9IHhmaWx0ZXJIZWFwc2VsZWN0LmJ5KHZhbHVlT2YpO1xuICAgICAgICBoZWFwID0geGZpbHRlckhlYXAuYnkodmFsdWVPZik7XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlT2YoZCkgeyByZXR1cm4gdmFsdWUoZC52YWx1ZSk7IH1cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuXG4gICAgICAvLyBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgbmF0dXJhbCBvcmRlcmluZyBieSByZWR1Y2UgdmFsdWUuXG4gICAgICBmdW5jdGlvbiBvcmRlck5hdHVyYWwoKSB7XG4gICAgICAgIHJldHVybiBvcmRlcihjcm9zc2ZpbHRlcl9pZGVudGl0eSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybnMgdGhlIGNhcmRpbmFsaXR5IG9mIHRoaXMgZ3JvdXAsIGlycmVzcGVjdGl2ZSBvZiBhbnkgZmlsdGVycy5cbiAgICAgIGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICAgIHJldHVybiBrO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmVzIHRoaXMgZ3JvdXAgYW5kIGFzc29jaWF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIGkgPSBmaWx0ZXJMaXN0ZW5lcnMuaW5kZXhPZih1cGRhdGUpO1xuICAgICAgICBpZiAoaSA+PSAwKSBmaWx0ZXJMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpID0gaW5kZXhMaXN0ZW5lcnMuaW5kZXhPZihhZGQpO1xuICAgICAgICBpZiAoaSA+PSAwKSBpbmRleExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGkgPSByZW1vdmVEYXRhTGlzdGVuZXJzLmluZGV4T2YocmVtb3ZlRGF0YSk7XG4gICAgICAgIGlmIChpID49IDApIHJlbW92ZURhdGFMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpID0gZGltZW5zaW9uR3JvdXBzLmluZGV4T2YoZ3JvdXApO1xuICAgICAgICBpZiAoaSA+PSAwKSBkaW1lbnNpb25Hcm91cHMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWR1Y2VDb3VudCgpLm9yZGVyTmF0dXJhbCgpO1xuICAgIH1cblxuICAgIC8vIEEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSBzaW5nbGV0b24gZ3JvdXAuXG4gICAgZnVuY3Rpb24gZ3JvdXBBbGwoKSB7XG4gICAgICB2YXIgZyA9IGdyb3VwKGNyb3NzZmlsdGVyX251bGwpLCBhbGwgPSBnLmFsbDtcbiAgICAgIGRlbGV0ZSBnLmFsbDtcbiAgICAgIGRlbGV0ZSBnLnRvcDtcbiAgICAgIGRlbGV0ZSBnLm9yZGVyO1xuICAgICAgZGVsZXRlIGcub3JkZXJOYXR1cmFsO1xuICAgICAgZGVsZXRlIGcuc2l6ZTtcbiAgICAgIGcudmFsdWUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFsbCgpWzBdLnZhbHVlOyB9O1xuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlcyB0aGlzIGRpbWVuc2lvbiBhbmQgYXNzb2NpYXRlZCBncm91cHMgYW5kIGV2ZW50IGxpc3RlbmVycy5cbiAgICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgZGltZW5zaW9uR3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgZ3JvdXAuZGlzcG9zZSgpOyB9KTtcbiAgICAgIHZhciBpID0gZGF0YUxpc3RlbmVycy5pbmRleE9mKHByZUFkZCk7XG4gICAgICBpZiAoaSA+PSAwKSBkYXRhTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIGkgPSBkYXRhTGlzdGVuZXJzLmluZGV4T2YocG9zdEFkZCk7XG4gICAgICBpZiAoaSA+PSAwKSBkYXRhTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIGkgPSByZW1vdmVEYXRhTGlzdGVuZXJzLmluZGV4T2YocmVtb3ZlRGF0YSk7XG4gICAgICBpZiAoaSA+PSAwKSByZW1vdmVEYXRhTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIGZpbHRlcnMubWFza3Nbb2Zmc2V0XSAmPSB6ZXJvO1xuICAgICAgcmV0dXJuIGZpbHRlckFsbCgpO1xuICAgIH1cblxuICAgIHJldHVybiBkaW1lbnNpb247XG4gIH1cblxuICAvLyBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZ3JvdXBBbGwgb24gYSBkdW1teSBkaW1lbnNpb24uXG4gIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGJlIG9wdGltaXplZCBzaW5jZSBpdCBhbHdheXMgaGFzIGNhcmRpbmFsaXR5IDEuXG4gIGZ1bmN0aW9uIGdyb3VwQWxsKCkge1xuICAgIHZhciBncm91cCA9IHtcbiAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgcmVkdWNlQ291bnQ6IHJlZHVjZUNvdW50LFxuICAgICAgcmVkdWNlU3VtOiByZWR1Y2VTdW0sXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBkaXNwb3NlOiBkaXNwb3NlLFxuICAgICAgcmVtb3ZlOiBkaXNwb3NlIC8vIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgIH07XG5cbiAgICB2YXIgcmVkdWNlVmFsdWUsXG4gICAgICAgIHJlZHVjZUFkZCxcbiAgICAgICAgcmVkdWNlUmVtb3ZlLFxuICAgICAgICByZWR1Y2VJbml0aWFsLFxuICAgICAgICByZXNldE5lZWRlZCA9IHRydWU7XG5cbiAgICAvLyBUaGUgZ3JvdXAgbGlzdGVucyB0byB0aGUgY3Jvc3NmaWx0ZXIgZm9yIHdoZW4gYW55IGRpbWVuc2lvbiBjaGFuZ2VzLCBzb1xuICAgIC8vIHRoYXQgaXQgY2FuIHVwZGF0ZSB0aGUgcmVkdWNlIHZhbHVlLiBJdCBtdXN0IGFsc28gbGlzdGVuIHRvIHRoZSBwYXJlbnRcbiAgICAvLyBkaW1lbnNpb24gZm9yIHdoZW4gZGF0YSBpcyBhZGRlZC5cbiAgICBmaWx0ZXJMaXN0ZW5lcnMucHVzaCh1cGRhdGUpO1xuICAgIGRhdGFMaXN0ZW5lcnMucHVzaChhZGQpO1xuXG4gICAgLy8gRm9yIGNvbnNpc3RlbmN5OyBhY3R1YWxseSBhIG5vLW9wIHNpbmNlIHJlc2V0TmVlZGVkIGlzIHRydWUuXG4gICAgYWRkKGRhdGEsIDAsIG4pO1xuXG4gICAgLy8gSW5jb3Jwb3JhdGVzIHRoZSBzcGVjaWZpZWQgbmV3IHZhbHVlcyBpbnRvIHRoaXMgZ3JvdXAuXG4gICAgZnVuY3Rpb24gYWRkKG5ld0RhdGEsIG4wKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKHJlc2V0TmVlZGVkKSByZXR1cm47XG5cbiAgICAgIC8vIEN5Y2xlIHRocm91Z2ggYWxsIHRoZSB2YWx1ZXMuXG4gICAgICBmb3IgKGkgPSBuMDsgaSA8IG47ICsraSkge1xuXG4gICAgICAgIC8vIEFkZCBhbGwgdmFsdWVzIGFsbCB0aGUgdGltZS5cbiAgICAgICAgcmVkdWNlVmFsdWUgPSByZWR1Y2VBZGQocmVkdWNlVmFsdWUsIGRhdGFbaV0sIHRydWUpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgdmFsdWUgaWYgZmlsdGVyZWQuXG4gICAgICAgIGlmICghZmlsdGVycy56ZXJvKGkpKSB7XG4gICAgICAgICAgcmVkdWNlVmFsdWUgPSByZWR1Y2VSZW1vdmUocmVkdWNlVmFsdWUsIGRhdGFbaV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlZHVjZXMgdGhlIHNwZWNpZmllZCBzZWxlY3RlZCBvciBkZXNlbGVjdGVkIHJlY29yZHMuXG4gICAgZnVuY3Rpb24gdXBkYXRlKGZpbHRlck9uZSwgZmlsdGVyT2Zmc2V0LCBhZGRlZCwgcmVtb3ZlZCwgbm90RmlsdGVyKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBrLFxuICAgICAgICAgIG47XG5cbiAgICAgIGlmIChyZXNldE5lZWRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBBZGQgdGhlIGFkZGVkIHZhbHVlcy5cbiAgICAgIGZvciAoaSA9IDAsIG4gPSBhZGRlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGZpbHRlcnMuemVybyhrID0gYWRkZWRbaV0pKSB7XG4gICAgICAgICAgcmVkdWNlVmFsdWUgPSByZWR1Y2VBZGQocmVkdWNlVmFsdWUsIGRhdGFba10sIG5vdEZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSByZW1vdmVkIHZhbHVlcy5cbiAgICAgIGZvciAoaSA9IDAsIG4gPSByZW1vdmVkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoZmlsdGVycy5vbmx5KGsgPSByZW1vdmVkW2ldLCBmaWx0ZXJPZmZzZXQsIGZpbHRlck9uZSkpIHtcbiAgICAgICAgICByZWR1Y2VWYWx1ZSA9IHJlZHVjZVJlbW92ZShyZWR1Y2VWYWx1ZSwgZGF0YVtrXSwgbm90RmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlY29tcHV0ZXMgdGhlIGdyb3VwIHJlZHVjZSB2YWx1ZSBmcm9tIHNjcmF0Y2guXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgcmVkdWNlVmFsdWUgPSByZWR1Y2VJbml0aWFsKCk7XG5cbiAgICAgIC8vIEN5Y2xlIHRocm91Z2ggYWxsIHRoZSB2YWx1ZXMuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG5cbiAgICAgICAgLy8gQWRkIGFsbCB2YWx1ZXMgYWxsIHRoZSB0aW1lLlxuICAgICAgICByZWR1Y2VWYWx1ZSA9IHJlZHVjZUFkZChyZWR1Y2VWYWx1ZSwgZGF0YVtpXSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB2YWx1ZSBpZiBpdCBpcyBmaWx0ZXJlZC5cbiAgICAgICAgaWYgKCFmaWx0ZXJzLnplcm8oaSkpIHtcbiAgICAgICAgICByZWR1Y2VWYWx1ZSA9IHJlZHVjZVJlbW92ZShyZWR1Y2VWYWx1ZSwgZGF0YVtpXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgcmVkdWNlIGJlaGF2aW9yIGZvciB0aGlzIGdyb3VwIHRvIHVzZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9ucy5cbiAgICAvLyBUaGlzIG1ldGhvZCBsYXppbHkgcmVjb21wdXRlcyB0aGUgcmVkdWNlIHZhbHVlLCB3YWl0aW5nIHVudGlsIG5lZWRlZC5cbiAgICBmdW5jdGlvbiByZWR1Y2UoYWRkLCByZW1vdmUsIGluaXRpYWwpIHtcbiAgICAgIHJlZHVjZUFkZCA9IGFkZDtcbiAgICAgIHJlZHVjZVJlbW92ZSA9IHJlbW92ZTtcbiAgICAgIHJlZHVjZUluaXRpYWwgPSBpbml0aWFsO1xuICAgICAgcmVzZXROZWVkZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cblxuICAgIC8vIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciByZWR1Y2luZyBieSBjb3VudC5cbiAgICBmdW5jdGlvbiByZWR1Y2VDb3VudCgpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoeGZpbHRlclJlZHVjZS5yZWR1Y2VJbmNyZW1lbnQsIHhmaWx0ZXJSZWR1Y2UucmVkdWNlRGVjcmVtZW50LCBjcm9zc2ZpbHRlcl96ZXJvKTtcbiAgICB9XG5cbiAgICAvLyBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVkdWNpbmcgYnkgc3VtKHZhbHVlKS5cbiAgICBmdW5jdGlvbiByZWR1Y2VTdW0odmFsdWUpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoeGZpbHRlclJlZHVjZS5yZWR1Y2VBZGQodmFsdWUpLCB4ZmlsdGVyUmVkdWNlLnJlZHVjZVN1YnRyYWN0KHZhbHVlKSwgY3Jvc3NmaWx0ZXJfemVybyk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB0aGUgY29tcHV0ZWQgcmVkdWNlIHZhbHVlLlxuICAgIGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgaWYgKHJlc2V0TmVlZGVkKSByZXNldCgpLCByZXNldE5lZWRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJlZHVjZVZhbHVlO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZXMgdGhpcyBncm91cCBhbmQgYXNzb2NpYXRlZCBldmVudCBsaXN0ZW5lcnMuXG4gICAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHZhciBpID0gZmlsdGVyTGlzdGVuZXJzLmluZGV4T2YodXBkYXRlKTtcbiAgICAgIGlmIChpID49IDApIGZpbHRlckxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICBpID0gZGF0YUxpc3RlbmVycy5pbmRleE9mKGFkZCk7XG4gICAgICBpZiAoaSA+PSAwKSBkYXRhTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkdWNlQ291bnQoKTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoaXMgY3Jvc3NmaWx0ZXIsIGlycmVzcGVjdGl2ZSBvZiBhbnkgZmlsdGVycy5cbiAgZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJhdyByb3cgZGF0YSBjb250YWluZWQgaW4gdGhpcyBjcm9zc2ZpbHRlclxuICBmdW5jdGlvbiBhbGwoKXtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIFJldHVybnMgcm93IGRhdGEgd2l0aCBhbGwgZGltZW5zaW9uIGZpbHRlcnMgYXBwbGllZCwgZXhjZXB0IGZvciBmaWx0ZXJzIGluIGlnbm9yZV9kaW1lbnNpb25zXG4gIGZ1bmN0aW9uIGFsbEZpbHRlcmVkKGlnbm9yZV9kaW1lbnNpb25zKSB7XG4gICAgdmFyIGFycmF5ID0gW10sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBtYXNrID0gbWFza0ZvckRpbWVuc2lvbnMoaWdub3JlX2RpbWVuc2lvbnMgfHwgW10pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChmaWx0ZXJzLnplcm9FeGNlcHRNYXNrKGksIG1hc2spKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChkYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZShjYil7XG4gICAgaWYodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKXtcbiAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICBjb25zb2xlLndhcm4oJ29uQ2hhbmdlIGNhbGxiYWNrIHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoY2FsbGJhY2tzLmluZGV4T2YoY2IpLCAxKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlck9uQ2hhbmdlKGV2ZW50TmFtZSl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrc1tpXShldmVudE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IGFkZChhcmd1bWVudHNbMF0pXG4gICAgICA6IGNyb3NzZmlsdGVyO1xufVxuXG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIHNpemUgbiwgYmlnIGVub3VnaCB0byBzdG9yZSBpZHMgdXAgdG8gbS5cbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2luZGV4KG4sIG0pIHtcbiAgcmV0dXJuIChtIDwgMHgxMDFcbiAgICAgID8geGZpbHRlckFycmF5LmFycmF5OCA6IG0gPCAweDEwMDAxXG4gICAgICA/IHhmaWx0ZXJBcnJheS5hcnJheTE2XG4gICAgICA6IHhmaWx0ZXJBcnJheS5hcnJheTMyKShuKTtcbn1cblxuLy8gQ29uc3RydWN0cyBhIG5ldyBhcnJheSBvZiBzaXplIG4sIHdpdGggc2VxdWVudGlhbCB2YWx1ZXMgZnJvbSAwIHRvIG4gLSAxLlxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfcmFuZ2Uobikge1xuICB2YXIgcmFuZ2UgPSBjcm9zc2ZpbHRlcl9pbmRleChuLCBuKTtcbiAgZm9yICh2YXIgaSA9IC0xOyArK2kgPCBuOykgcmFuZ2VbaV0gPSBpO1xuICByZXR1cm4gcmFuZ2U7XG59XG5cbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2NhcGFjaXR5KHcpIHtcbiAgcmV0dXJuIHcgPT09IDhcbiAgICAgID8gMHgxMDAgOiB3ID09PSAxNlxuICAgICAgPyAweDEwMDAwXG4gICAgICA6IDB4MTAwMDAwMDAwO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4573\n')},"4c13":function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! socket.io-parser */ \"6fba\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"ee5b\");\nvar toArray = __webpack_require__(/*! to-array */ \"7de3\");\nvar on = __webpack_require__(/*! ./on */ \"faaa\");\nvar bind = __webpack_require__(/*! component-bind */ \"b6f6\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client:socket');\nvar hasBin = __webpack_require__(/*! has-binary */ \"d304\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket (io, nsp, opts) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  if (opts && opts.query) {\n    this.query = opts.query;\n  }\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function () {\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' === this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' === typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  delete this.flags;\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' !== this.nsp) {\n    if (this.query) {\n      this.packet({type: parser.CONNECT, query: this.query});\n    } else {\n      this.packet({type: parser.CONNECT});\n    }\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function (packet) {\n  if (packet.nsp !== this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n  if ('function' === typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function (compress) {\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNGMxMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzPzg3ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAoaW8sIG5zcCwgb3B0cykge1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgfVxuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcbiAgaWYgKGhhc0JpbihhcmdzKSkgeyBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDsgfSAvLyBiaW5hcnlcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyVHlwZSwgZGF0YTogYXJncyB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcbiAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogdGhpcy5xdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKHBhY2tldC5uc3AgIT09IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4c13\n")},"4d50":function(module,exports,__webpack_require__){eval("/**\n * Facets are the main abstraction over the data.\n *\n * A `Dataset` is a collection of (similar) items, with each item having a certain set of properties, ie. `Facet`s.\n * The `Facet` class defines the property: It can be a continuous value, a set of labels or tags,\n * or it can be result of some transformation or equation.\n *\n * @class Facet\n * @extends Base\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar CategorialTransform = __webpack_require__(/*! ./facet/categorial-transform */ \"9b75\");\nvar ContinuousTransform = __webpack_require__(/*! ./facet/continuous-transform */ \"5a80\");\nvar datetimeTransform = __webpack_require__(/*! ./facet/datetime-transform */ \"a0ca\");\nvar durationTransform = __webpack_require__(/*! ./facet/duration-transform */ \"b123\");\nvar textTransform = __webpack_require__(/*! ./facet/text-transform */ \"e810\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\nmodule.exports = BaseModel.extend({\n  initialize: function () {\n    this.on('change:type', function (facet, newval) {\n      // reset transformations on type change\n      this.continuousTransform.reset();\n      this.categorialTransform.reset();\n      this.datetimeTransform.reset();\n      this.durationTransform.reset();\n    });\n  },\n  props: {\n    /**\n     * Show in facet lists (used for interactive searching on Facets page)\n     * @memberof! Facet\n     * @type {boolean}\n     */\n    show: ['boolean', false, true],\n\n    /**\n     * Show facet bar (on Analyze page)\n     * @memberof! Facet\n     * @type {boolean}\n     */\n    isActive: ['boolean', false, false],\n\n    // general facet properties\n    /**\n     * Description of this facet, for displaying purposes\n     * @memberof! Facet\n     * @type {string}\n     */\n    description: ['string', true, ''],\n\n    /**\n     * For continuous facets, its units for displaying purposes\n     * @memberof! Facet\n     * @type {string}\n     */\n    units: ['string', true, ''],\n\n    /**\n     * Short name (human readable) for this facet, must be unique.\n     * @memberof! Facet\n     * @type {string}\n     */\n    name: ['string', true, ''],\n\n    /**\n     * Type of this facet:\n     *  * `constant`        A constant value of \"1\" for all data items\n     *  * `continuous`      The facet takes on real numbers\n     *  * `categorial`      The facet is a string, or an array of strings (for a well defined set of labels and tags)\n     *  * `datetime`        The facet is a datetime (using momentjs.tz)\n     *  * `duration`        The facet is a duration (using momentjs.duration)\n     *  * `text`            Freeform text.\n     * Check for facet type using isConstant, isContinuous, isCategorial, isDatetime, isDuration, or isText  properties.\n     * @memberof! Facet\n     * @type {string}\n     */\n    type: {\n      type: 'string',\n      required: true,\n      default: 'categorial',\n      values: ['constant', 'continuous', 'categorial', 'datetime', 'duration', 'text']\n    },\n\n    /**\n     * The accessor for this facet.\n     * For nested properties use dot notation: For a dataset `[ {name: {first: \"Santa\", last: \"Claus\"}}, ...]`\n     * you can use `name.first` and `name.last` to get Santa and Claus, respectively.\n     *\n     * @memberof! Facet\n     * @type {string}\n     */\n    accessor: ['string', false, null],\n\n    /**\n     * Missing or invalid data indicator; for multiple values, use a comma separated, quoted list\n     * Numbers, strings, booleans, and the special value null are allowed.\n     * Use single or double quotes for strings \"missing\".\n     * The parsed values are available in the misval property.\n     *\n     * @memberof! Facet\n     * @type {string}\n     */\n    misvalAsText: 'string',\n\n    /**\n     * For continuous or datetime Facets, the minimum value as text.\n     * Parsed value available in the `minval` property\n     * @memberof! Facet\n     * @type {string}\n     */\n    minvalAsText: 'string',\n\n    /**\n     * For continuous or datetime Facets, the maximum value as text.\n     * Parsed value available in the `maxval` property\n     * @memberof! Facet\n     * @type {string}\n     */\n    maxvalAsText: 'string'\n  },\n  children: {\n    /**\n     * A categorial transformation to apply to the data\n     * @memberof! Facet\n     * @type {CategorialTransform}\n     */\n    categorialTransform: CategorialTransform,\n    /**\n     * A datetime transformation to apply to the data\n     * @memberof! Facet\n     * @type {dateimeTransform}\n     */\n    datetimeTransform: datetimeTransform,\n    /**\n     * A duration transformation to apply to the data\n     * @memberof! Facet\n     * @type {dateimeTransform}\n     */\n    durationTransform: durationTransform,\n    /**\n     * A continuous transformation to apply to the data\n     * @memberof! Facet\n     * @type {ContinuousTransform}\n     */\n    continuousTransform: ContinuousTransform,\n    /**\n     * A text transform\n     * @memberof! Facet\n     * @type {TextTransform}\n     */\n    textTransform: textTransform\n  },\n\n  derived: {\n    // properties for: type\n    isConstant: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'constant';\n      }\n    },\n    isContinuous: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'continuous';\n      }\n    },\n    isCategorial: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'categorial';\n      }\n    },\n    isDatetime: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'datetime';\n      }\n    },\n    isDuration: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'duration';\n      }\n    },\n    isText: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'text';\n      }\n    },\n\n    /**\n     * Array of missing data indicators\n     * @memberof! Facet\n     * @type {Object[]}\n     * @readonly\n     */\n    misval: {\n      deps: ['misvalAsText'],\n      fn: function () {\n        // Parse the text content as a JSON array:\n        //  - strings should be quoted\n        //  - numbers unquoated\n        //  - special numbers not allowed: NaN, Infinity\n        try {\n          if (this.misvalAsText !== null) {\n            return JSON.parse('[' + this.misvalAsText + ']');\n          } else {\n            return [];\n          }\n        } catch (e) {\n          return [];\n        }\n      },\n      cache: false\n    },\n\n    /**\n     * For continuous or datetime Facets, the minimum value.\n     * @memberof! Facet\n     * @type {number|datetime}\n     * @readonly\n     */\n    minval: {\n      deps: ['minvalAsText', 'type'],\n      fn: function () {\n        var min;\n        if (this.isContinuous) {\n          min = parseFloat(this.minvalAsText);\n          if (isNaN(min)) {\n            min = 0;\n          }\n        } else if (this.isDatetime) {\n          min = moment(this.minvalAsText, moment.ISO_8601);\n          if (!min.isValid()) {\n            min = moment('2010-01-01 00:00', moment.ISO_8601);\n          }\n        } else if (this.isDuration) {\n          min = moment.duration(this.minvalAsText);\n          if (!moment.isDuration(min)) {\n            min = moment.duration(1, 'seconds');\n          }\n        }\n        return min;\n      },\n      cache: false\n    },\n    /**\n     * For continuous or datetime Facets, the maximum value.\n     * @memberof! Facet\n     * @type {number|datetime}\n     * @readonly\n     */\n    maxval: {\n      deps: ['maxvalAsText', 'type'],\n      fn: function () {\n        var max;\n        if (this.isContinuous) {\n          max = parseFloat(this.maxvalAsText);\n          if (isNaN(max)) {\n            max = 100;\n          }\n        } else if (this.isDatetime) {\n          max = moment(this.maxvalAsText, moment.ISO_8601);\n          if (!max.isValid()) {\n            max = moment('2020-01-01 00:00', moment.ISO_8601);\n          }\n        } else if (this.isDuration) {\n          max = moment.duration(this.maxvalAsText);\n          if (!moment.isDuration(max)) {\n            max = moment.duration(100, 'seconds');\n          }\n        }\n        return max;\n      },\n      cache: false\n    },\n    transform: {\n      deps: ['type'],\n      fn: function () {\n        if (this.isContinuous) {\n          return this.continuousTransform;\n        } else if (this.isCategorial) {\n          return this.categorialTransform;\n        } else if (this.isDatetime) {\n          return this.datetimeTransform;\n        } else if (this.isDuration) {\n          return this.durationTransform;\n        } else if (this.isText) {\n          return this.textTransform;\n        }\n        console.error('Invalid facet');\n      },\n      cache: false\n    }\n  },\n  /**\n   * setMinMax sets the range of a continuous or time facet\n   * For facets in a dataview, the minimum is just the minimum of the facet over all active datasets,\n   * and the same for the maximum.\n   * For facets in a datset, the actual implementation is in the dataset driver.\n   *\n   * @memberof! Facet\n   */\n  setMinMax: function () {\n    var Dataset = __webpack_require__(/*! ./dataset */ \"545a\");\n    var Dataview = __webpack_require__(/*! ./dataview */ \"5066\");\n\n    var ancestor = this.collection.parent;\n    var spot;\n\n    if (ancestor instanceof Dataview) {\n      // Facet -> Facets -> Dataview -> Spot\n      spot = this.collection.parent.parent;\n      spot.setFacetMinMax(this);\n    } else if (ancestor instanceof Dataset) {\n      // Dataset -> Datasets -> Spot\n      spot = ancestor.collection.parent;\n      spot.driver.setMinMax(ancestor, this);\n    }\n  },\n  /**\n   * setCategories finds finds all values on an ordinal (categorial) axis\n   * Updates the categorialTransform of the facet\n   * For facets in a dataview, this is the union of the categories of facet over all active datasets.\n   * For facets in a dataset, the actual implementation is in the dataset driver.\n   *\n   * @memberof! Facet\n   */\n  setCategories: function () {\n    var Dataset = __webpack_require__(/*! ./dataset */ \"545a\");\n    var Dataview = __webpack_require__(/*! ./dataview */ \"5066\");\n\n    var ancestor = this.collection.parent;\n    var spot;\n\n    if (ancestor instanceof Dataview) {\n      // Facet -> Facets -> Dataview -> Spot\n      spot = this.collection.parent.parent;\n      spot.setFacetCategories(this);\n    } else if (ancestor instanceof Dataset) {\n      // Facet -> Facets -> Dataset -> Datasets -> Spot\n      spot = ancestor.collection.parent;\n      spot.driver.setCategories(ancestor, this);\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNGQ1MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQuanM/ZDdlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZhY2V0cyBhcmUgdGhlIG1haW4gYWJzdHJhY3Rpb24gb3ZlciB0aGUgZGF0YS5cbiAqXG4gKiBBIGBEYXRhc2V0YCBpcyBhIGNvbGxlY3Rpb24gb2YgKHNpbWlsYXIpIGl0ZW1zLCB3aXRoIGVhY2ggaXRlbSBoYXZpbmcgYSBjZXJ0YWluIHNldCBvZiBwcm9wZXJ0aWVzLCBpZS4gYEZhY2V0YHMuXG4gKiBUaGUgYEZhY2V0YCBjbGFzcyBkZWZpbmVzIHRoZSBwcm9wZXJ0eTogSXQgY2FuIGJlIGEgY29udGludW91cyB2YWx1ZSwgYSBzZXQgb2YgbGFiZWxzIG9yIHRhZ3MsXG4gKiBvciBpdCBjYW4gYmUgcmVzdWx0IG9mIHNvbWUgdHJhbnNmb3JtYXRpb24gb3IgZXF1YXRpb24uXG4gKlxuICogQGNsYXNzIEZhY2V0XG4gKiBAZXh0ZW5kcyBCYXNlXG4gKi9cbnZhciBCYXNlTW9kZWwgPSByZXF1aXJlKCcuL3V0aWwvYmFzZScpO1xudmFyIENhdGVnb3JpYWxUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2ZhY2V0L2NhdGVnb3JpYWwtdHJhbnNmb3JtJyk7XG52YXIgQ29udGludW91c1RyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZmFjZXQvY29udGludW91cy10cmFuc2Zvcm0nKTtcbnZhciBkYXRldGltZVRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vZmFjZXQvZGF0ZXRpbWUtdHJhbnNmb3JtJyk7XG52YXIgZHVyYXRpb25UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2ZhY2V0L2R1cmF0aW9uLXRyYW5zZm9ybScpO1xudmFyIHRleHRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2ZhY2V0L3RleHQtdHJhbnNmb3JtJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uKCdjaGFuZ2U6dHlwZScsIGZ1bmN0aW9uIChmYWNldCwgbmV3dmFsKSB7XG4gICAgICAvLyByZXNldCB0cmFuc2Zvcm1hdGlvbnMgb24gdHlwZSBjaGFuZ2VcbiAgICAgIHRoaXMuY29udGludW91c1RyYW5zZm9ybS5yZXNldCgpO1xuICAgICAgdGhpcy5jYXRlZ29yaWFsVHJhbnNmb3JtLnJlc2V0KCk7XG4gICAgICB0aGlzLmRhdGV0aW1lVHJhbnNmb3JtLnJlc2V0KCk7XG4gICAgICB0aGlzLmR1cmF0aW9uVHJhbnNmb3JtLnJlc2V0KCk7XG4gICAgfSk7XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogU2hvdyBpbiBmYWNldCBsaXN0cyAodXNlZCBmb3IgaW50ZXJhY3RpdmUgc2VhcmNoaW5nIG9uIEZhY2V0cyBwYWdlKVxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG93OiBbJ2Jvb2xlYW4nLCBmYWxzZSwgdHJ1ZV0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGZhY2V0IGJhciAob24gQW5hbHl6ZSBwYWdlKVxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZTogWydib29sZWFuJywgZmFsc2UsIGZhbHNlXSxcblxuICAgIC8vIGdlbmVyYWwgZmFjZXQgcHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uIG9mIHRoaXMgZmFjZXQsIGZvciBkaXNwbGF5aW5nIHB1cnBvc2VzXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGVzY3JpcHRpb246IFsnc3RyaW5nJywgdHJ1ZSwgJyddLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMgZmFjZXRzLCBpdHMgdW5pdHMgZm9yIGRpc3BsYXlpbmcgcHVycG9zZXNcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB1bml0czogWydzdHJpbmcnLCB0cnVlLCAnJ10sXG5cbiAgICAvKipcbiAgICAgKiBTaG9ydCBuYW1lIChodW1hbiByZWFkYWJsZSkgZm9yIHRoaXMgZmFjZXQsIG11c3QgYmUgdW5pcXVlLlxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5hbWU6IFsnc3RyaW5nJywgdHJ1ZSwgJyddLFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGlzIGZhY2V0OlxuICAgICAqICAqIGBjb25zdGFudGAgICAgICAgIEEgY29uc3RhbnQgdmFsdWUgb2YgXCIxXCIgZm9yIGFsbCBkYXRhIGl0ZW1zXG4gICAgICogICogYGNvbnRpbnVvdXNgICAgICAgVGhlIGZhY2V0IHRha2VzIG9uIHJlYWwgbnVtYmVyc1xuICAgICAqICAqIGBjYXRlZ29yaWFsYCAgICAgIFRoZSBmYWNldCBpcyBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyAoZm9yIGEgd2VsbCBkZWZpbmVkIHNldCBvZiBsYWJlbHMgYW5kIHRhZ3MpXG4gICAgICogICogYGRhdGV0aW1lYCAgICAgICAgVGhlIGZhY2V0IGlzIGEgZGF0ZXRpbWUgKHVzaW5nIG1vbWVudGpzLnR6KVxuICAgICAqICAqIGBkdXJhdGlvbmAgICAgICAgIFRoZSBmYWNldCBpcyBhIGR1cmF0aW9uICh1c2luZyBtb21lbnRqcy5kdXJhdGlvbilcbiAgICAgKiAgKiBgdGV4dGAgICAgICAgICAgICBGcmVlZm9ybSB0ZXh0LlxuICAgICAqIENoZWNrIGZvciBmYWNldCB0eXBlIHVzaW5nIGlzQ29uc3RhbnQsIGlzQ29udGludW91cywgaXNDYXRlZ29yaWFsLCBpc0RhdGV0aW1lLCBpc0R1cmF0aW9uLCBvciBpc1RleHQgIHByb3BlcnRpZXMuXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICdjYXRlZ29yaWFsJyxcbiAgICAgIHZhbHVlczogWydjb25zdGFudCcsICdjb250aW51b3VzJywgJ2NhdGVnb3JpYWwnLCAnZGF0ZXRpbWUnLCAnZHVyYXRpb24nLCAndGV4dCddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3IgdGhpcyBmYWNldC5cbiAgICAgKiBGb3IgbmVzdGVkIHByb3BlcnRpZXMgdXNlIGRvdCBub3RhdGlvbjogRm9yIGEgZGF0YXNldCBgWyB7bmFtZToge2ZpcnN0OiBcIlNhbnRhXCIsIGxhc3Q6IFwiQ2xhdXNcIn19LCAuLi5dYFxuICAgICAqIHlvdSBjYW4gdXNlIGBuYW1lLmZpcnN0YCBhbmQgYG5hbWUubGFzdGAgdG8gZ2V0IFNhbnRhIGFuZCBDbGF1cywgcmVzcGVjdGl2ZWx5LlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgYWNjZXNzb3I6IFsnc3RyaW5nJywgZmFsc2UsIG51bGxdLFxuXG4gICAgLyoqXG4gICAgICogTWlzc2luZyBvciBpbnZhbGlkIGRhdGEgaW5kaWNhdG9yOyBmb3IgbXVsdGlwbGUgdmFsdWVzLCB1c2UgYSBjb21tYSBzZXBhcmF0ZWQsIHF1b3RlZCBsaXN0XG4gICAgICogTnVtYmVycywgc3RyaW5ncywgYm9vbGVhbnMsIGFuZCB0aGUgc3BlY2lhbCB2YWx1ZSBudWxsIGFyZSBhbGxvd2VkLlxuICAgICAqIFVzZSBzaW5nbGUgb3IgZG91YmxlIHF1b3RlcyBmb3Igc3RyaW5ncyBcIm1pc3NpbmdcIi5cbiAgICAgKiBUaGUgcGFyc2VkIHZhbHVlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBtaXN2YWwgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBtaXN2YWxBc1RleHQ6ICdzdHJpbmcnLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMgb3IgZGF0ZXRpbWUgRmFjZXRzLCB0aGUgbWluaW11bSB2YWx1ZSBhcyB0ZXh0LlxuICAgICAqIFBhcnNlZCB2YWx1ZSBhdmFpbGFibGUgaW4gdGhlIGBtaW52YWxgIHByb3BlcnR5XG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbWludmFsQXNUZXh0OiAnc3RyaW5nJyxcblxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIG9yIGRhdGV0aW1lIEZhY2V0cywgdGhlIG1heGltdW0gdmFsdWUgYXMgdGV4dC5cbiAgICAgKiBQYXJzZWQgdmFsdWUgYXZhaWxhYmxlIGluIHRoZSBgbWF4dmFsYCBwcm9wZXJ0eVxuICAgICAqIEBtZW1iZXJvZiEgRmFjZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG1heHZhbEFzVGV4dDogJ3N0cmluZydcbiAgfSxcbiAgY2hpbGRyZW46IHtcbiAgICAvKipcbiAgICAgKiBBIGNhdGVnb3JpYWwgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkgdG8gdGhlIGRhdGFcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge0NhdGVnb3JpYWxUcmFuc2Zvcm19XG4gICAgICovXG4gICAgY2F0ZWdvcmlhbFRyYW5zZm9ybTogQ2F0ZWdvcmlhbFRyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIGRhdGV0aW1lIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBkYXRhXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtkYXRlaW1lVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIGRhdGV0aW1lVHJhbnNmb3JtOiBkYXRldGltZVRyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIGR1cmF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSBkYXRhXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtkYXRlaW1lVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIGR1cmF0aW9uVHJhbnNmb3JtOiBkdXJhdGlvblRyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIGNvbnRpbnVvdXMgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkgdG8gdGhlIGRhdGFcbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge0NvbnRpbnVvdXNUcmFuc2Zvcm19XG4gICAgICovXG4gICAgY29udGludW91c1RyYW5zZm9ybTogQ29udGludW91c1RyYW5zZm9ybSxcbiAgICAvKipcbiAgICAgKiBBIHRleHQgdHJhbnNmb3JtXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtUZXh0VHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRleHRUcmFuc2Zvcm06IHRleHRUcmFuc2Zvcm1cbiAgfSxcblxuICBkZXJpdmVkOiB7XG4gICAgLy8gcHJvcGVydGllcyBmb3I6IHR5cGVcbiAgICBpc0NvbnN0YW50OiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdjb25zdGFudCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0NvbnRpbnVvdXM6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2NvbnRpbnVvdXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNDYXRlZ29yaWFsOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdjYXRlZ29yaWFsJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzRGF0ZXRpbWU6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2RhdGV0aW1lJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzRHVyYXRpb246IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2R1cmF0aW9uJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzVGV4dDoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAndGV4dCc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIG1pc3NpbmcgZGF0YSBpbmRpY2F0b3JzXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtPYmplY3RbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBtaXN2YWw6IHtcbiAgICAgIGRlcHM6IFsnbWlzdmFsQXNUZXh0J10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dCBjb250ZW50IGFzIGEgSlNPTiBhcnJheTpcbiAgICAgICAgLy8gIC0gc3RyaW5ncyBzaG91bGQgYmUgcXVvdGVkXG4gICAgICAgIC8vICAtIG51bWJlcnMgdW5xdW9hdGVkXG4gICAgICAgIC8vICAtIHNwZWNpYWwgbnVtYmVycyBub3QgYWxsb3dlZDogTmFOLCBJbmZpbml0eVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLm1pc3ZhbEFzVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoJ1snICsgdGhpcy5taXN2YWxBc1RleHQgKyAnXScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIG9yIGRhdGV0aW1lIEZhY2V0cywgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQG1lbWJlcm9mISBGYWNldFxuICAgICAqIEB0eXBlIHtudW1iZXJ8ZGF0ZXRpbWV9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgbWludmFsOiB7XG4gICAgICBkZXBzOiBbJ21pbnZhbEFzVGV4dCcsICd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWluO1xuICAgICAgICBpZiAodGhpcy5pc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICBtaW4gPSBwYXJzZUZsb2F0KHRoaXMubWludmFsQXNUZXh0KTtcbiAgICAgICAgICBpZiAoaXNOYU4obWluKSkge1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RhdGV0aW1lKSB7XG4gICAgICAgICAgbWluID0gbW9tZW50KHRoaXMubWludmFsQXNUZXh0LCBtb21lbnQuSVNPXzg2MDEpO1xuICAgICAgICAgIGlmICghbWluLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbWluID0gbW9tZW50KCcyMDEwLTAxLTAxIDAwOjAwJywgbW9tZW50LklTT184NjAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0R1cmF0aW9uKSB7XG4gICAgICAgICAgbWluID0gbW9tZW50LmR1cmF0aW9uKHRoaXMubWludmFsQXNUZXh0KTtcbiAgICAgICAgICBpZiAoIW1vbWVudC5pc0R1cmF0aW9uKG1pbikpIHtcbiAgICAgICAgICAgIG1pbiA9IG1vbWVudC5kdXJhdGlvbigxLCAnc2Vjb25kcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMgb3IgZGF0ZXRpbWUgRmFjZXRzLCB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyb2YhIEZhY2V0XG4gICAgICogQHR5cGUge251bWJlcnxkYXRldGltZX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBtYXh2YWw6IHtcbiAgICAgIGRlcHM6IFsnbWF4dmFsQXNUZXh0JywgJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXg7XG4gICAgICAgIGlmICh0aGlzLmlzQ29udGludW91cykge1xuICAgICAgICAgIG1heCA9IHBhcnNlRmxvYXQodGhpcy5tYXh2YWxBc1RleHQpO1xuICAgICAgICAgIGlmIChpc05hTihtYXgpKSB7XG4gICAgICAgICAgICBtYXggPSAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXRldGltZSkge1xuICAgICAgICAgIG1heCA9IG1vbWVudCh0aGlzLm1heHZhbEFzVGV4dCwgbW9tZW50LklTT184NjAxKTtcbiAgICAgICAgICBpZiAoIW1heC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIG1heCA9IG1vbWVudCgnMjAyMC0wMS0wMSAwMDowMCcsIG1vbWVudC5JU09fODYwMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEdXJhdGlvbikge1xuICAgICAgICAgIG1heCA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm1heHZhbEFzVGV4dCk7XG4gICAgICAgICAgaWYgKCFtb21lbnQuaXNEdXJhdGlvbihtYXgpKSB7XG4gICAgICAgICAgICBtYXggPSBtb21lbnQuZHVyYXRpb24oMTAwLCAnc2Vjb25kcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29udGludW91cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRpbnVvdXNUcmFuc2Zvcm07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NhdGVnb3JpYWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWFsVHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXRldGltZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGV0aW1lVHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEdXJhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uVHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGZhY2V0Jyk7XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogc2V0TWluTWF4IHNldHMgdGhlIHJhbmdlIG9mIGEgY29udGludW91cyBvciB0aW1lIGZhY2V0XG4gICAqIEZvciBmYWNldHMgaW4gYSBkYXRhdmlldywgdGhlIG1pbmltdW0gaXMganVzdCB0aGUgbWluaW11bSBvZiB0aGUgZmFjZXQgb3ZlciBhbGwgYWN0aXZlIGRhdGFzZXRzLFxuICAgKiBhbmQgdGhlIHNhbWUgZm9yIHRoZSBtYXhpbXVtLlxuICAgKiBGb3IgZmFjZXRzIGluIGEgZGF0c2V0LCB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIGluIHRoZSBkYXRhc2V0IGRyaXZlci5cbiAgICpcbiAgICogQG1lbWJlcm9mISBGYWNldFxuICAgKi9cbiAgc2V0TWluTWF4OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIERhdGFzZXQgPSByZXF1aXJlKCcuL2RhdGFzZXQnKTtcbiAgICB2YXIgRGF0YXZpZXcgPSByZXF1aXJlKCcuL2RhdGF2aWV3Jyk7XG5cbiAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90O1xuXG4gICAgaWYgKGFuY2VzdG9yIGluc3RhbmNlb2YgRGF0YXZpZXcpIHtcbiAgICAgIC8vIEZhY2V0IC0+IEZhY2V0cyAtPiBEYXRhdmlldyAtPiBTcG90XG4gICAgICBzcG90ID0gdGhpcy5jb2xsZWN0aW9uLnBhcmVudC5wYXJlbnQ7XG4gICAgICBzcG90LnNldEZhY2V0TWluTWF4KHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYW5jZXN0b3IgaW5zdGFuY2VvZiBEYXRhc2V0KSB7XG4gICAgICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgICAgIHNwb3QgPSBhbmNlc3Rvci5jb2xsZWN0aW9uLnBhcmVudDtcbiAgICAgIHNwb3QuZHJpdmVyLnNldE1pbk1heChhbmNlc3RvciwgdGhpcyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogc2V0Q2F0ZWdvcmllcyBmaW5kcyBmaW5kcyBhbGwgdmFsdWVzIG9uIGFuIG9yZGluYWwgKGNhdGVnb3JpYWwpIGF4aXNcbiAgICogVXBkYXRlcyB0aGUgY2F0ZWdvcmlhbFRyYW5zZm9ybSBvZiB0aGUgZmFjZXRcbiAgICogRm9yIGZhY2V0cyBpbiBhIGRhdGF2aWV3LCB0aGlzIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2F0ZWdvcmllcyBvZiBmYWNldCBvdmVyIGFsbCBhY3RpdmUgZGF0YXNldHMuXG4gICAqIEZvciBmYWNldHMgaW4gYSBkYXRhc2V0LCB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIGluIHRoZSBkYXRhc2V0IGRyaXZlci5cbiAgICpcbiAgICogQG1lbWJlcm9mISBGYWNldFxuICAgKi9cbiAgc2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBEYXRhc2V0ID0gcmVxdWlyZSgnLi9kYXRhc2V0Jyk7XG4gICAgdmFyIERhdGF2aWV3ID0gcmVxdWlyZSgnLi9kYXRhdmlldycpO1xuXG4gICAgdmFyIGFuY2VzdG9yID0gdGhpcy5jb2xsZWN0aW9uLnBhcmVudDtcbiAgICB2YXIgc3BvdDtcblxuICAgIGlmIChhbmNlc3RvciBpbnN0YW5jZW9mIERhdGF2aWV3KSB7XG4gICAgICAvLyBGYWNldCAtPiBGYWNldHMgLT4gRGF0YXZpZXcgLT4gU3BvdFxuICAgICAgc3BvdCA9IHRoaXMuY29sbGVjdGlvbi5wYXJlbnQucGFyZW50O1xuICAgICAgc3BvdC5zZXRGYWNldENhdGVnb3JpZXModGhpcyk7XG4gICAgfSBlbHNlIGlmIChhbmNlc3RvciBpbnN0YW5jZW9mIERhdGFzZXQpIHtcbiAgICAgIC8vIEZhY2V0IC0+IEZhY2V0cyAtPiBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IFNwb3RcbiAgICAgIHNwb3QgPSBhbmNlc3Rvci5jb2xsZWN0aW9uLnBhcmVudDtcbiAgICAgIHNwb3QuZHJpdmVyLnNldENhdGVnb3JpZXMoYW5jZXN0b3IsIHRoaXMpO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4d50\n")},5066:function(module,exports,__webpack_require__){eval("/**\n * A Dataview is a join of Datasets\n *\n * @class Dataview\n * @extends Base\n */\nvar Crossfilter = __webpack_require__(/*! crossfilter2 */ \"9263\"); // TODO: only for client side datasets\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Filters = __webpack_require__(/*! ./filter/collection */ \"7fa4\");\nvar Facets = __webpack_require__(/*! ./facet/collection */ \"51fb\");\n\nfunction getData () {\n  if (this.isPaused) {\n    return;\n  }\n  console.time('Get data');\n\n  var spot = this.parent;\n\n  return spot.driver.getData(this);\n}\n\nmodule.exports = BaseModel.extend({\n  initialize: function () {\n    // first do parent class initialization\n    BaseModel.prototype.initialize.apply(this, arguments);\n\n    /**\n     * Crossfilter instance, see [here](http://square.github.io/crossfilter/)\n     * used for client side data handling.\n     *\n     * @memberof! Dataset\n     */\n    this.crossfilter = new Crossfilter([]);\n    this.countGroup = this.crossfilter.groupAll().reduceCount();\n  },\n  props: {\n    /**\n     * Total number of datapoints in the current dataview\n     *\n     * @memberof! Dataview\n     * @readonly\n     * @type {number}\n     */\n    dataTotal: ['number', true, 0],\n    /**\n     * Number of datapoints that are currently selected\n     *\n     * @memberof! Dataview\n     * @readonly\n     * @type {number}\n     */\n    dataSelected: ['number', true, 0],\n    /**\n     * DatasetId's of active datasets\n     *\n     * @memberof! Dataview\n     * @type {String[]}\n     */\n    datasetIds: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    }\n  },\n  session: {\n    /**\n     * isPaused when true, calls to getAllData are ignored.\n     * This is useful to suppres calls to getData\n     * when adding and removing a number of filters at once.\n     * @memberof! Dataview\n     * @type {boolean}\n     */\n    isPaused: ['boolean', true, false]\n  },\n  collections: {\n    /**\n     * A Facet collection holding pre defined facets\n     *\n     * @memberof! Dataview\n     * @type {Facet[]}\n     */\n    facets: Facets,\n    /**\n     * A Filter collection holding all active filters on the dataview\n     *\n     * @memberof! Dataview\n     * @type {Filter[]}\n     */\n    filters: Filters\n  },\n  /**\n   * Pause the dataview. This means calls to getData are blocked.\n   * Useful when updating a lot of filters and you are not interested in the intermediate state.\n   *\n   * @memberof! Dataview\n   */\n  pause: function () {\n    this.isPaused = true;\n  },\n  /**\n   * Unpause the dataview.\n   *\n   * @memberof! Dataview\n   */\n  play: function () {\n    this.isPaused = false;\n  },\n\n  /**\n   * Get data for all filters linked to this dataview.\n   * When data has become available for a filter, a `newData` event is triggered on that filter.\n   *\n   * @memberof! Dataview\n   * @function\n   */\n  getData: getData\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA2Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZGF0YXZpZXcuanM/NGQ0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgRGF0YXZpZXcgaXMgYSBqb2luIG9mIERhdGFzZXRzXG4gKlxuICogQGNsYXNzIERhdGF2aWV3XG4gKiBAZXh0ZW5kcyBCYXNlXG4gKi9cbnZhciBDcm9zc2ZpbHRlciA9IHJlcXVpcmUoJ2Nyb3NzZmlsdGVyMicpOyAvLyBUT0RPOiBvbmx5IGZvciBjbGllbnQgc2lkZSBkYXRhc2V0c1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlJyk7XG52YXIgRmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVyL2NvbGxlY3Rpb24nKTtcbnZhciBGYWNldHMgPSByZXF1aXJlKCcuL2ZhY2V0L2NvbGxlY3Rpb24nKTtcblxuZnVuY3Rpb24gZ2V0RGF0YSAoKSB7XG4gIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUudGltZSgnR2V0IGRhdGEnKTtcblxuICB2YXIgc3BvdCA9IHRoaXMucGFyZW50O1xuXG4gIHJldHVybiBzcG90LmRyaXZlci5nZXREYXRhKHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VNb2RlbC5leHRlbmQoe1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZmlyc3QgZG8gcGFyZW50IGNsYXNzIGluaXRpYWxpemF0aW9uXG4gICAgQmFzZU1vZGVsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcm9zc2ZpbHRlciBpbnN0YW5jZSwgc2VlIFtoZXJlXShodHRwOi8vc3F1YXJlLmdpdGh1Yi5pby9jcm9zc2ZpbHRlci8pXG4gICAgICogdXNlZCBmb3IgY2xpZW50IHNpZGUgZGF0YSBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NmaWx0ZXIgPSBuZXcgQ3Jvc3NmaWx0ZXIoW10pO1xuICAgIHRoaXMuY291bnRHcm91cCA9IHRoaXMuY3Jvc3NmaWx0ZXIuZ3JvdXBBbGwoKS5yZWR1Y2VDb3VudCgpO1xuICB9LFxuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiBkYXRhcG9pbnRzIGluIHRoZSBjdXJyZW50IGRhdGF2aWV3XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBkYXRhVG90YWw6IFsnbnVtYmVyJywgdHJ1ZSwgMF0sXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGRhdGFwb2ludHMgdGhhdCBhcmUgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBkYXRhU2VsZWN0ZWQ6IFsnbnVtYmVyJywgdHJ1ZSwgMF0sXG4gICAgLyoqXG4gICAgICogRGF0YXNldElkJ3Mgb2YgYWN0aXZlIGRhdGFzZXRzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGRhdGFzZXRJZHM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNlc3Npb246IHtcbiAgICAvKipcbiAgICAgKiBpc1BhdXNlZCB3aGVuIHRydWUsIGNhbGxzIHRvIGdldEFsbERhdGEgYXJlIGlnbm9yZWQuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gc3VwcHJlcyBjYWxscyB0byBnZXREYXRhXG4gICAgICogd2hlbiBhZGRpbmcgYW5kIHJlbW92aW5nIGEgbnVtYmVyIG9mIGZpbHRlcnMgYXQgb25jZS5cbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQYXVzZWQ6IFsnYm9vbGVhbicsIHRydWUsIGZhbHNlXVxuICB9LFxuICBjb2xsZWN0aW9uczoge1xuICAgIC8qKlxuICAgICAqIEEgRmFjZXQgY29sbGVjdGlvbiBob2xkaW5nIHByZSBkZWZpbmVkIGZhY2V0c1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mISBEYXRhdmlld1xuICAgICAqIEB0eXBlIHtGYWNldFtdfVxuICAgICAqL1xuICAgIGZhY2V0czogRmFjZXRzLFxuICAgIC8qKlxuICAgICAqIEEgRmlsdGVyIGNvbGxlY3Rpb24gaG9sZGluZyBhbGwgYWN0aXZlIGZpbHRlcnMgb24gdGhlIGRhdGF2aWV3XG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGF2aWV3XG4gICAgICogQHR5cGUge0ZpbHRlcltdfVxuICAgICAqL1xuICAgIGZpbHRlcnM6IEZpbHRlcnNcbiAgfSxcbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBkYXRhdmlldy4gVGhpcyBtZWFucyBjYWxscyB0byBnZXREYXRhIGFyZSBibG9ja2VkLlxuICAgKiBVc2VmdWwgd2hlbiB1cGRhdGluZyBhIGxvdCBvZiBmaWx0ZXJzIGFuZCB5b3UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIHRoZSBpbnRlcm1lZGlhdGUgc3RhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiEgRGF0YXZpZXdcbiAgICovXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIC8qKlxuICAgKiBVbnBhdXNlIHRoZSBkYXRhdmlldy5cbiAgICpcbiAgICogQG1lbWJlcm9mISBEYXRhdmlld1xuICAgKi9cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGRhdGEgZm9yIGFsbCBmaWx0ZXJzIGxpbmtlZCB0byB0aGlzIGRhdGF2aWV3LlxuICAgKiBXaGVuIGRhdGEgaGFzIGJlY29tZSBhdmFpbGFibGUgZm9yIGEgZmlsdGVyLCBhIGBuZXdEYXRhYCBldmVudCBpcyB0cmlnZ2VyZWQgb24gdGhhdCBmaWx0ZXIuXG4gICAqXG4gICAqIEBtZW1iZXJvZiEgRGF0YXZpZXdcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBnZXREYXRhOiBnZXREYXRhXG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5066\n")},"51fb":function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Facet = __webpack_require__(/*! ../facet */ \"4d50\");\n\nmodule.exports = Collection.extend({\n  model: Facet,\n  mainIndex: 'id',\n  indexes: ['name'],\n  session: {\n    needle: ['string', true, ''], // search string used on the Facet page\n    showSearch: ['boolean', true, false] // show/hide the search bar on the Facet page\n  },\n  comparator: function (left, right) {\n    return left.name.localeCompare(right.name);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTFmYi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY29sbGVjdGlvbi5qcz84ZWU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnYW1wZXJzYW5kLWNvbGxlY3Rpb24nKTtcbnZhciBGYWNldCA9IHJlcXVpcmUoJy4uL2ZhY2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogRmFjZXQsXG4gIG1haW5JbmRleDogJ2lkJyxcbiAgaW5kZXhlczogWyduYW1lJ10sXG4gIHNlc3Npb246IHtcbiAgICBuZWVkbGU6IFsnc3RyaW5nJywgdHJ1ZSwgJyddLCAvLyBzZWFyY2ggc3RyaW5nIHVzZWQgb24gdGhlIEZhY2V0IHBhZ2VcbiAgICBzaG93U2VhcmNoOiBbJ2Jvb2xlYW4nLCB0cnVlLCBmYWxzZV0gLy8gc2hvdy9oaWRlIHRoZSBzZWFyY2ggYmFyIG9uIHRoZSBGYWNldCBwYWdlXG4gIH0sXG4gIGNvbXBhcmF0b3I6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0Lm5hbWUubG9jYWxlQ29tcGFyZShyaWdodC5uYW1lKTtcbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51fb\n")},"544d":function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Dataset = __webpack_require__(/*! ../dataset */ \"545a\");\n\nmodule.exports = Collection.extend({\n  mainIndex: 'id',\n  indexes: ['name'],\n  model: Dataset\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ0ZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZGF0YXNldC9jb2xsZWN0aW9uLmpzPzkxZDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCdhbXBlcnNhbmQtY29sbGVjdGlvbicpO1xudmFyIERhdGFzZXQgPSByZXF1aXJlKCcuLi9kYXRhc2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtYWluSW5kZXg6ICdpZCcsXG4gIGluZGV4ZXM6IFsnbmFtZSddLFxuICBtb2RlbDogRGF0YXNldFxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///544d\n")},"545a":function(module,exports,__webpack_require__){eval("/**\n * @class Dataset\n * @extends Base\n */\nvar Crossfilter = __webpack_require__(/*! crossfilter2 */ \"9263\"); // TODO: only for client side datasets\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Facets = __webpack_require__(/*! ./facet/collection */ \"51fb\");\n\nmodule.exports = BaseModel.extend({\n  initialize: function () {\n    // first do parent class initialization\n    BaseModel.prototype.initialize.apply(this, arguments);\n\n    /**\n     * Crossfilter instance, see [here](http://square.github.io/crossfilter/)\n     * used for client side data handling.\n     *\n     * @memberof! Dataset\n     */\n    this.crossfilter = new Crossfilter([]);\n    this.countGroup = this.crossfilter.groupAll().reduceCount();\n  },\n  props: {\n    /**\n     * Name of the dataset\n     * @memberof! Dataset\n     * @type {string}\n     */\n    name: {\n      type: 'string',\n      required: true,\n      default: 'Name'\n    },\n    /**\n     * URL, fi. to paper, dataset owner, etc.\n     * @memberof! Dataset\n     * @type {string}\n     */\n    URL: {\n      type: 'string',\n      required: true,\n      default: 'URL'\n    },\n    /**\n     * Database table name for server datasets\n     * @memberof! Dataset\n     * @type {string}\n     */\n    databaseTable: {\n      type: 'string',\n      default: ''\n    },\n    /**\n     * Short description of the dataset\n     * @memberof! Dataset\n     * @type {string}\n     */\n    description: {\n      type: 'string',\n      required: true,\n      default: 'Description'\n    },\n    /**\n     * If dataset is part of the current session\n     * @memberof! Dataset\n     * @type {boolean}\n     */\n    isActive: {\n      type: 'boolean',\n      required: true,\n      default: false\n    }\n  },\n  session: {\n    /**\n     * For searching through datasets URL and description.\n     * True if this dataset matches the search paramters.\n     */\n    show: {\n      type: 'boolean',\n      required: true,\n      default: true\n    },\n    data: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    }\n  },\n  collections: {\n    /**\n     * A Facet collection holding pre defined facets\n     * @memberof! Dataset\n     * @type {Facet[]}\n     */\n    facets: Facets\n  },\n  scan: function () {\n    // Dataset -> Datasets -> spot\n    var spot = this.collection.parent;\n\n    // clear all existing facets\n    this.facets.reset();\n\n    spot.driver.scan(this);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ1YS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZGF0YXNldC5qcz9lYTcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGNsYXNzIERhdGFzZXRcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xudmFyIENyb3NzZmlsdGVyID0gcmVxdWlyZSgnY3Jvc3NmaWx0ZXIyJyk7IC8vIFRPRE86IG9ubHkgZm9yIGNsaWVudCBzaWRlIGRhdGFzZXRzXG52YXIgQmFzZU1vZGVsID0gcmVxdWlyZSgnLi91dGlsL2Jhc2UnKTtcbnZhciBGYWNldHMgPSByZXF1aXJlKCcuL2ZhY2V0L2NvbGxlY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlTW9kZWwuZXh0ZW5kKHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIGZpcnN0IGRvIHBhcmVudCBjbGFzcyBpbml0aWFsaXphdGlvblxuICAgIEJhc2VNb2RlbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLyoqXG4gICAgICogQ3Jvc3NmaWx0ZXIgaW5zdGFuY2UsIHNlZSBbaGVyZV0oaHR0cDovL3NxdWFyZS5naXRodWIuaW8vY3Jvc3NmaWx0ZXIvKVxuICAgICAqIHVzZWQgZm9yIGNsaWVudCBzaWRlIGRhdGEgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIERhdGFzZXRcbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzZmlsdGVyID0gbmV3IENyb3NzZmlsdGVyKFtdKTtcbiAgICB0aGlzLmNvdW50R3JvdXAgPSB0aGlzLmNyb3NzZmlsdGVyLmdyb3VwQWxsKCkucmVkdWNlQ291bnQoKTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBkYXRhc2V0XG4gICAgICogQG1lbWJlcm9mISBEYXRhc2V0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ05hbWUnXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVUkwsIGZpLiB0byBwYXBlciwgZGF0YXNldCBvd25lciwgZXRjLlxuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVVJMOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ1VSTCdcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERhdGFiYXNlIHRhYmxlIG5hbWUgZm9yIHNlcnZlciBkYXRhc2V0c1xuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGF0YWJhc2VUYWJsZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIGRhdGFzZXRcbiAgICAgKiBAbWVtYmVyb2YhIERhdGFzZXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ0Rlc2NyaXB0aW9uJ1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSWYgZGF0YXNldCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICAgKiBAbWVtYmVyb2YhIERhdGFzZXRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgc2Vzc2lvbjoge1xuICAgIC8qKlxuICAgICAqIEZvciBzZWFyY2hpbmcgdGhyb3VnaCBkYXRhc2V0cyBVUkwgYW5kIGRlc2NyaXB0aW9uLlxuICAgICAqIFRydWUgaWYgdGhpcyBkYXRhc2V0IG1hdGNoZXMgdGhlIHNlYXJjaCBwYXJhbXRlcnMuXG4gICAgICovXG4gICAgc2hvdzoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb2xsZWN0aW9uczoge1xuICAgIC8qKlxuICAgICAqIEEgRmFjZXQgY29sbGVjdGlvbiBob2xkaW5nIHByZSBkZWZpbmVkIGZhY2V0c1xuICAgICAqIEBtZW1iZXJvZiEgRGF0YXNldFxuICAgICAqIEB0eXBlIHtGYWNldFtdfVxuICAgICAqL1xuICAgIGZhY2V0czogRmFjZXRzXG4gIH0sXG4gIHNjYW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBEYXRhc2V0IC0+IERhdGFzZXRzIC0+IHNwb3RcbiAgICB2YXIgc3BvdCA9IHRoaXMuY29sbGVjdGlvbi5wYXJlbnQ7XG5cbiAgICAvLyBjbGVhciBhbGwgZXhpc3RpbmcgZmFjZXRzXG4gICAgdGhpcy5mYWNldHMucmVzZXQoKTtcblxuICAgIHNwb3QuZHJpdmVyLnNjYW4odGhpcyk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///545a\n")},"55a3":function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction crossfilter_identity(d) {\n  return d;\n}\n\nmodule.exports = crossfilter_identity;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTVhMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9pZGVudGl0eS5qcz81Zjg1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfaWRlbnRpdHkoZCkge1xuICByZXR1cm4gZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcm9zc2ZpbHRlcl9pZGVudGl0eTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55a3\n")},"55c1":function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction crossfilter_reduceIncrement(p) {\n  return p + 1;\n}\n\nfunction crossfilter_reduceDecrement(p) {\n  return p - 1;\n}\n\nfunction crossfilter_reduceAdd(f) {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nfunction crossfilter_reduceSubtract(f) {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nmodule.exports = {\n  reduceIncrement: crossfilter_reduceIncrement,\n  reduceDecrement: crossfilter_reduceDecrement,\n  reduceAdd: crossfilter_reduceAdd,\n  reduceSubtract: crossfilter_reduceSubtract\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTVjMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9yZWR1Y2UuanM/MjYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX3JlZHVjZUluY3JlbWVudChwKSB7XG4gIHJldHVybiBwICsgMTtcbn1cblxuZnVuY3Rpb24gY3Jvc3NmaWx0ZXJfcmVkdWNlRGVjcmVtZW50KHApIHtcbiAgcmV0dXJuIHAgLSAxO1xufVxuXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9yZWR1Y2VBZGQoZikge1xuICByZXR1cm4gZnVuY3Rpb24ocCwgdikge1xuICAgIHJldHVybiBwICsgK2Yodik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX3JlZHVjZVN1YnRyYWN0KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHAsIHYpIHtcbiAgICByZXR1cm4gcCAtIGYodik7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWR1Y2VJbmNyZW1lbnQ6IGNyb3NzZmlsdGVyX3JlZHVjZUluY3JlbWVudCxcbiAgcmVkdWNlRGVjcmVtZW50OiBjcm9zc2ZpbHRlcl9yZWR1Y2VEZWNyZW1lbnQsXG4gIHJlZHVjZUFkZDogY3Jvc3NmaWx0ZXJfcmVkdWNlQWRkLFxuICByZWR1Y2VTdWJ0cmFjdDogY3Jvc3NmaWx0ZXJfcmVkdWNlU3VidHJhY3Rcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55c1\n")},5677:function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction permute(array, index, deep) {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n\nmodule.exports = permute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY3Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9wZXJtdXRlLmpzPzc5ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBwZXJtdXRlKGFycmF5LCBpbmRleCwgZGVlcCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGluZGV4Lmxlbmd0aCwgY29weSA9IGRlZXAgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFycmF5KSkgOiBuZXcgQXJyYXkobik7IGkgPCBuOyArK2kpIHtcbiAgICBjb3B5W2ldID0gYXJyYXlbaW5kZXhbaV1dO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcm11dGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5677\n")},"58ab":function(module,exports,__webpack_require__){eval('\nmodule.exports = __webpack_require__(/*! ./socket */ "0112");\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = __webpack_require__(/*! engine.io-parser */ "aa6c");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNThhYi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanM/ZWViYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///58ab\n')},"5a80":function(module,exports,__webpack_require__){eval("/**\n * ContinuousTransfrom defines a transformation on continuous (nummerical) data.\n * Currently linear interpolation between a set of control points is implemented.\n *\n * @class ContinuousTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar misval = __webpack_require__(/*! ../util/misval */ \"bff6\");\n\nvar ControlPoint = __webpack_require__(/*! ./control-point */ \"09c5\");\nvar ControlPoints = Collection.extend({\n  model: ControlPoint\n});\n\n/**\n * Apply piecewise linear transformation\n * The function is constant outside the range spanned by the control points;\n * there it is set to value of the first, or the last, control points.\n *\n * @function\n * @memberof! ContinuousTransform\n * @param {number} x\n * @returns {number} fx\n */\nfunction transform (cps, x) {\n  if (x === misval) {\n    return misval;\n  }\n\n  var ncps = cps.models.length;\n  if (x <= cps.models[0].x) {\n    // outside range on left side\n    return cps.models[0].fx;\n  } else if (x >= cps.models[ncps - 1].x) {\n    // outside range on right side\n    return cps.models[ncps - 1].fx;\n  } else {\n    // inside range\n    var i = 0;\n    while (x > cps.models[i].x) {\n      i = i + 1;\n    }\n\n    // linear interpolate between fx_i and fx_(i+1)\n    var xm = cps.models[i].x;\n    var xp = cps.models[i + 1].x;\n    var fxm = cps.models[i].fx;\n    var fxp = cps.models[i + 1].fx;\n    if (xp === xm) {\n      return 0.5 * (fxm + fxp);\n    } else {\n      return fxm + (x - xm) * (fxp - fxm) / (xp - xm);\n    }\n  }\n}\n\n/**\n * The inverse of the transform\n *\n * @function\n * @memberof! ContinuousTransform\n * @param {number} fx\n * @returns {number} x\n */\nfunction inverse (cps, fx) {\n  if (fx === misval) {\n    return misval;\n  }\n\n  var ncps = cps.models.length;\n  if (fx <= cps.models[0].fx) {\n    // outside range on left side\n    return cps.models[0].x;\n  } else if (fx >= cps.models[ncps - 1].fx) {\n    // outside range on right side\n    return cps.models[ncps - 1].x;\n  } else {\n    // inside range\n    var i = 0;\n    while (fx > cps.models[i].fx) {\n      i = i + 1;\n    }\n\n    // linear interpolate between fx_i and fx_(i+1)\n    var xm = cps.models[i].x;\n    var xp = cps.models[i + 1].x;\n    var fxm = cps.models[i].fx;\n    var fxp = cps.models[i + 1].fx;\n    if (fxp === fxm) {\n      return 0.5 * (xm + xp);\n    } else {\n      return xm + (fx - fxm) * (xp - xm) / (fxp - fxm);\n    }\n  }\n}\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * The type of continuous transform, can be none, or percentiles\n     * Use isNone, or isPercentiles, check for transform type\n     * @memberof! ContinuousTransform\n     */\n    type: {\n      type: 'string',\n      required: true,\n      default: 'none',\n      values: ['none', 'percentiles']\n    },\n    transformedType: {\n      type: 'string',\n      required: true,\n      default: 'continuous',\n      values: ['continuous']\n    }\n  },\n  derived: {\n    isNone: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'none';\n      }\n    },\n    isPercentiles: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'percentiles';\n      }\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! ContinuousTransform\n     */\n    transformedMin: {\n      deps: ['type'],\n      fn: function () {\n        if (this.isPercentiles) {\n          return 0;\n        } else if (this.isNone) {\n          return this.parent.minval;\n        } else {\n          console.error('Invalid continuous transform');\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! ContinuousTransform\n     */\n    transformedMax: {\n      deps: ['type'],\n      fn: function () {\n        if (this.isPercentiles) {\n          return 100;\n        } else if (this.isNone) {\n          return this.parent.maxval;\n        } else {\n          console.error('Invalid continuous transform');\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! ContinuousTransform\n     */\n    transformedMinAsText: {\n      deps: ['transformedMin', 'transformedType'],\n      fn: function () {\n        var minval = this.transformedMin;\n        if (this.transformedType === 'datetime') {\n          return minval.format();\n        } else {\n          return minval.toString();\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! ContinuousTransform\n     */\n    transformedMaxAsText: {\n      deps: ['transformedMax', 'transformedType'],\n      fn: function () {\n        var maxval = this.transformedMax;\n        if (this.transformedType === 'datetime') {\n          return maxval.format();\n        } else {\n          return maxval.toString();\n        }\n      },\n      cache: false\n    }\n  },\n  collections: {\n    cps: ControlPoints\n  },\n  transform: function (x) {\n    return transform(this.cps, x);\n  },\n  inverse: function (fx) {\n    return inverse(this.cps, fx);\n  },\n  reset: function () {\n    this.type = 'none';\n    this.cps.reset();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNWE4MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY29udGludW91cy10cmFuc2Zvcm0uanM/YzgwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRpbnVvdXNUcmFuc2Zyb20gZGVmaW5lcyBhIHRyYW5zZm9ybWF0aW9uIG9uIGNvbnRpbnVvdXMgKG51bW1lcmljYWwpIGRhdGEuXG4gKiBDdXJyZW50bHkgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBhIHNldCBvZiBjb250cm9sIHBvaW50cyBpcyBpbXBsZW1lbnRlZC5cbiAqXG4gKiBAY2xhc3MgQ29udGludW91c1RyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnYW1wZXJzYW5kLWNvbGxlY3Rpb24nKTtcbnZhciBtaXN2YWwgPSByZXF1aXJlKCcuLi91dGlsL21pc3ZhbCcpO1xuXG52YXIgQ29udHJvbFBvaW50ID0gcmVxdWlyZSgnLi9jb250cm9sLXBvaW50Jyk7XG52YXIgQ29udHJvbFBvaW50cyA9IENvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgbW9kZWw6IENvbnRyb2xQb2ludFxufSk7XG5cbi8qKlxuICogQXBwbHkgcGllY2V3aXNlIGxpbmVhciB0cmFuc2Zvcm1hdGlvblxuICogVGhlIGZ1bmN0aW9uIGlzIGNvbnN0YW50IG91dHNpZGUgdGhlIHJhbmdlIHNwYW5uZWQgYnkgdGhlIGNvbnRyb2wgcG9pbnRzO1xuICogdGhlcmUgaXQgaXMgc2V0IHRvIHZhbHVlIG9mIHRoZSBmaXJzdCwgb3IgdGhlIGxhc3QsIGNvbnRyb2wgcG9pbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mISBDb250aW51b3VzVHJhbnNmb3JtXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHJldHVybnMge251bWJlcn0gZnhcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtIChjcHMsIHgpIHtcbiAgaWYgKHggPT09IG1pc3ZhbCkge1xuICAgIHJldHVybiBtaXN2YWw7XG4gIH1cblxuICB2YXIgbmNwcyA9IGNwcy5tb2RlbHMubGVuZ3RoO1xuICBpZiAoeCA8PSBjcHMubW9kZWxzWzBdLngpIHtcbiAgICAvLyBvdXRzaWRlIHJhbmdlIG9uIGxlZnQgc2lkZVxuICAgIHJldHVybiBjcHMubW9kZWxzWzBdLmZ4O1xuICB9IGVsc2UgaWYgKHggPj0gY3BzLm1vZGVsc1tuY3BzIC0gMV0ueCkge1xuICAgIC8vIG91dHNpZGUgcmFuZ2Ugb24gcmlnaHQgc2lkZVxuICAgIHJldHVybiBjcHMubW9kZWxzW25jcHMgLSAxXS5meDtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbnNpZGUgcmFuZ2VcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHggPiBjcHMubW9kZWxzW2ldLngpIHtcbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG5cbiAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGUgYmV0d2VlbiBmeF9pIGFuZCBmeF8oaSsxKVxuICAgIHZhciB4bSA9IGNwcy5tb2RlbHNbaV0ueDtcbiAgICB2YXIgeHAgPSBjcHMubW9kZWxzW2kgKyAxXS54O1xuICAgIHZhciBmeG0gPSBjcHMubW9kZWxzW2ldLmZ4O1xuICAgIHZhciBmeHAgPSBjcHMubW9kZWxzW2kgKyAxXS5meDtcbiAgICBpZiAoeHAgPT09IHhtKSB7XG4gICAgICByZXR1cm4gMC41ICogKGZ4bSArIGZ4cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmeG0gKyAoeCAtIHhtKSAqIChmeHAgLSBmeG0pIC8gKHhwIC0geG0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBpbnZlcnNlIG9mIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICogQHBhcmFtIHtudW1iZXJ9IGZ4XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB4XG4gKi9cbmZ1bmN0aW9uIGludmVyc2UgKGNwcywgZngpIHtcbiAgaWYgKGZ4ID09PSBtaXN2YWwpIHtcbiAgICByZXR1cm4gbWlzdmFsO1xuICB9XG5cbiAgdmFyIG5jcHMgPSBjcHMubW9kZWxzLmxlbmd0aDtcbiAgaWYgKGZ4IDw9IGNwcy5tb2RlbHNbMF0uZngpIHtcbiAgICAvLyBvdXRzaWRlIHJhbmdlIG9uIGxlZnQgc2lkZVxuICAgIHJldHVybiBjcHMubW9kZWxzWzBdLng7XG4gIH0gZWxzZSBpZiAoZnggPj0gY3BzLm1vZGVsc1tuY3BzIC0gMV0uZngpIHtcbiAgICAvLyBvdXRzaWRlIHJhbmdlIG9uIHJpZ2h0IHNpZGVcbiAgICByZXR1cm4gY3BzLm1vZGVsc1tuY3BzIC0gMV0ueDtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbnNpZGUgcmFuZ2VcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGZ4ID4gY3BzLm1vZGVsc1tpXS5meCkge1xuICAgICAgaSA9IGkgKyAxO1xuICAgIH1cblxuICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0ZSBiZXR3ZWVuIGZ4X2kgYW5kIGZ4XyhpKzEpXG4gICAgdmFyIHhtID0gY3BzLm1vZGVsc1tpXS54O1xuICAgIHZhciB4cCA9IGNwcy5tb2RlbHNbaSArIDFdLng7XG4gICAgdmFyIGZ4bSA9IGNwcy5tb2RlbHNbaV0uZng7XG4gICAgdmFyIGZ4cCA9IGNwcy5tb2RlbHNbaSArIDFdLmZ4O1xuICAgIGlmIChmeHAgPT09IGZ4bSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh4bSArIHhwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHhtICsgKGZ4IC0gZnhtKSAqICh4cCAtIHhtKSAvIChmeHAgLSBmeG0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFtcGVyc2FuZE1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgY29udGludW91cyB0cmFuc2Zvcm0sIGNhbiBiZSBub25lLCBvciBwZXJjZW50aWxlc1xuICAgICAqIFVzZSBpc05vbmUsIG9yIGlzUGVyY2VudGlsZXMsIGNoZWNrIGZvciB0cmFuc2Zvcm0gdHlwZVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICAgICAqL1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnbm9uZScsXG4gICAgICB2YWx1ZXM6IFsnbm9uZScsICdwZXJjZW50aWxlcyddXG4gICAgfSxcbiAgICB0cmFuc2Zvcm1lZFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnY29udGludW91cycsXG4gICAgICB2YWx1ZXM6IFsnY29udGludW91cyddXG4gICAgfVxuICB9LFxuICBkZXJpdmVkOiB7XG4gICAgaXNOb25lOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdub25lJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzUGVyY2VudGlsZXM6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3BlcmNlbnRpbGVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIENvbnRpbnVvdXNUcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1pbjoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1BlcmNlbnRpbGVzKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc05vbmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubWludmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgY29udGludW91cyB0cmFuc2Zvcm0nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdmFsdWUgdGhpcyBmYWNldCBjYW4gdGFrZSwgYWZ0ZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWF4OiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUGVyY2VudGlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gMTAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm1heHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGNvbnRpbnVvdXMgdHJhbnNmb3JtJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiEgQ29udGludW91c1RyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWluQXNUZXh0OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkTWluJywgJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1pbnZhbCA9IHRoaXMudHJhbnNmb3JtZWRNaW47XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHJldHVybiBtaW52YWwuZm9ybWF0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1pbnZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIENvbnRpbnVvdXNUcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1heEFzVGV4dDoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZE1heCcsICd0cmFuc2Zvcm1lZFR5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXh2YWwgPSB0aGlzLnRyYW5zZm9ybWVkTWF4O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICByZXR1cm4gbWF4dmFsLmZvcm1hdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXh2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgY29sbGVjdGlvbnM6IHtcbiAgICBjcHM6IENvbnRyb2xQb2ludHNcbiAgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0odGhpcy5jcHMsIHgpO1xuICB9LFxuICBpbnZlcnNlOiBmdW5jdGlvbiAoZngpIHtcbiAgICByZXR1cm4gaW52ZXJzZSh0aGlzLmNwcywgZngpO1xuICB9LFxuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHlwZSA9ICdub25lJztcbiAgICB0aGlzLmNwcy5yZXNldCgpO1xuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5a80\n")},6176:function(module,exports){eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE3Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz8xYjA4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6176\n")},"636d":function(module,exports){eval("\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM2ZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanM/ZWVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///636d\n")},"6b20":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"0d97\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"aa6c\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"914f\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"42bf\");\nvar yeast = __webpack_require__(/*! yeast */ \"c16d\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\nvar NodeWebSocket;\nif (typeof window === 'undefined') {\n  try {\n    NodeWebSocket = __webpack_require__(/*! ws */ 0);\n  } catch (e) { }\n}\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  WebSocket = NodeWebSocket;\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  if (!this.usingBrowserWebSocket) {\n    WebSocket = NodeWebSocket;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = void (0);\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done () {\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n    ('ws' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNmIyMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanM/ZGI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG52YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbnZhciBOb2RlV2ViU29ja2V0O1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQgJiYgIW9wdHMuZm9yY2VOb2RlO1xuICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgV2ViU29ja2V0ID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkICgwKTtcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPSB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6b20\n")},"6fba":function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar debug = __webpack_require__(/*! debug */ \"8233\")('socket.io-parser');\nvar json = __webpack_require__(/*! json3 */ \"3b17\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"636d\");\nvar binary = __webpack_require__(/*! ./binary */ \"ea82\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"419b\");\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  var str = '';\n  var nsp = false;\n\n  // first is type\n  str += obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    str += obj.attachments;\n    str += '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' != obj.nsp) {\n    nsp = true;\n    str += obj.nsp;\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    if (nsp) {\n      str += ',';\n      nsp = false;\n    }\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    if (nsp) str += ',';\n    str += json.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if ('string' == typeof obj) {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var p = {};\n  var i = 0;\n\n  // look up type\n  p.type = Number(str.charAt(0));\n  if (null == exports.types[p.type]) return error();\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n    var buf = '';\n    while (str.charAt(++i) != '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) != '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' == str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' == c) break;\n      p.nsp += c;\n      if (i == str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i == str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    p = tryParse(p, str.substr(i));\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(p, str) {\n  try {\n    p.data = json.parse(str);\n  } catch(e){\n    return error();\n  }\n  return p; \n};\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(data){\n  return {\n    type: exports.ERROR,\n    data: 'parser error'\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNmZiYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcz84ZjQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgcCA9IHRyeVBhcnNlKHAsIHN0ci5zdWJzdHIoaSkpO1xuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdHJ5UGFyc2UocCwgc3RyKSB7XG4gIHRyeSB7XG4gICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBlcnJvcigpO1xuICB9XG4gIHJldHVybiBwOyBcbn07XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6fba\n")},"720c":function(module,exports,__webpack_require__){eval("/**\n * Client side filtering using crossfilter\n * Due to limitation of crossfilter with array (or data that has no natrual ordering), this will not work as expected:\n * * dimension: `function (d) {return [d.x, d.y, d.z]}`\n * * group: `function (d) {return [d.x / 10 , d.y / 10, d.z / 10]}`\n *\n * Therefore, we preform grouping already in the dimension itself, and join the array to a string.\n * Strings have a natural ordering and thus can be used as dimension value.\n * * dimension: `function (d) -> \"d.x/10|d.y/10|d.z/10\"`\n * * group: `function (d) {return d;}`\n *\n * @module driver/client\n */\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\nvar utildx = __webpack_require__(/*! ../util/crossfilter */ \"adfa\");\nvar misval = __webpack_require__(/*! ../util/misval */ \"bff6\");\n\nvar grpIdxToName = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e'};\nvar aggRankToName = {1: 'aa', 2: 'bb', 3: 'cc', 4: 'dd', 5: 'ee'};\n\n/**\n * setMinMax sets the range of a continuous or time facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setMinMax (dataset, facet) {\n  // we need the value just before a transformation, so baseValueFn\n  var valFn = utildx.baseValueFn(facet);\n\n  // to be able to mark the value as missing we need it unprocessed, so rawValueFn\n  var rawValFn = utildx.rawValueFn(facet);\n\n  var lessFn;\n  var moreFn;\n  if (facet.isDatetime) {\n    lessFn = function (a, b) { return (b === misval || a.isBefore(b)); };\n    moreFn = function (a, b) { return (b === misval || b.isBefore(a)); };\n  } else {\n    lessFn = function (a, b) { return (b === misval || a < b); };\n    moreFn = function (a, b) { return (b === misval || a > b); };\n  }\n\n  var minval = misval;\n  var rawMin = misval;\n\n  var maxval = misval;\n  var rawMax = misval;\n\n  dataset.data.forEach(function (d) {\n    var rawV = rawValFn(d);\n    var v = valFn(d);\n\n    if (v !== misval) {\n      if (lessFn(v, minval)) {\n        minval = v;\n        rawMin = rawV;\n      }\n      if (moreFn(v, maxval)) {\n        maxval = v;\n        rawMax = rawV;\n      }\n    }\n  });\n\n  if (minval !== misval) {\n    if (facet.isContinuous) {\n      facet.minvalAsText = minval.toString();\n    } else if (facet.isDatetime) {\n      facet.minvalAsText = minval.toISOString();\n    } else if (facet.isDuration) {\n      facet.minvalAsText = minval.toISOString();\n    }\n    facet.rawMinval = rawMin;\n  } else {\n    facet.minvalAsText = '';\n    facet.rawMinval = misval;\n  }\n\n  if (maxval !== misval) {\n    if (facet.isContinuous) {\n      facet.maxvalAsText = maxval.toString();\n    } else if (facet.isDatetime) {\n      facet.maxvalAsText = maxval.toISOString();\n    } else if (facet.isDuration) {\n      facet.maxvalAsText = maxval.toISOString();\n    }\n    facet.rawMaxval = rawMax;\n  } else {\n    facet.maxvalAsText = '';\n    facet.rawMaxval = misval;\n  }\n}\n\n/**\n * setCategories finds finds all values on an ordinal (categorial) axis\n * Updates the categorialTransform of the facet\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setCategories (dataset, facet) {\n  // we need the value just before a transformation, so baseValueFn\n  var valFn = utildx.baseValueFn(facet);\n\n  var p = {};\n  var Plength = 0;\n  dataset.data.forEach(function (d, i) {\n    var vals = valFn(d);\n    if (vals instanceof Array) {\n      vals.forEach(function (val) {\n        if (p.hasOwnProperty(val)) {\n          p[val]++;\n        } else {\n          if (Plength < 75) { // NOTE: limit to maximally 75 categories\n            p[val] = 1;\n            Plength++;\n          }\n        }\n      });\n    } else {\n      if (p.hasOwnProperty(vals)) {\n        p[vals]++;\n      } else {\n        if (Plength < 75) { // NOTE: limit to maximally 75 categories\n          p[vals] = 1;\n          Plength++;\n        }\n      }\n    }\n  });\n\n  facet.categorialTransform.reset();\n\n  Object.keys(p).forEach(function (key) {\n    // TODO: missing data should be mapped to a misval from misvalAsText\n    var keyAsString = key.toString();\n    var groupAsString = keyAsString;\n\n    facet.categorialTransform.rules.add({expression: keyAsString, count: p[key], group: groupAsString});\n  });\n}\n\n/**\n * Calculate 100 percentiles (ie. 1,2,3,4 etc.), and initialize the `facet.continuousTransform`\n * to an approximate percentile mapping.\n * Use the recommended method from [NIST](http://www.itl.nist.gov/div898/handbook/prc/section2/prc262.htm)\n * See also the discussion on [Wikipedia](https://en.wikipedia.org/wiki/Percentile)\n *\n * @param {Dataset} dataset\n * @param {Facet} facet\n */\nfunction setPercentiles (dataset, facet) {\n  // we need the value just before a transformation, so baseValueFn\n  var basevalueFn = utildx.baseValueFn(facet);\n  var data = dataset.data;\n\n  data.sort(function (a, b) {\n    var valA = basevalueFn(a);\n    var valB = basevalueFn(b);\n\n    if (valA === valB) {\n      return 0;\n    }\n    if (valA === misval) {\n      return -1;\n    }\n    if (valB === misval) {\n      return 1;\n    }\n\n    if (valA < valB) {\n      return -1;\n    } else {\n      return 1;\n    }\n  });\n\n  var tf = facet.continuousTransform;\n  var x, i;\n\n  // drop missing values, which should be sorted at the start of the array\n  i = 0;\n  while (basevalueFn(data[i]) === misval && i < data.length) {\n    i++;\n  }\n  data.splice(0, i);\n\n  // start clean\n  tf.reset();\n\n  // add minimum value as control points p0 and p1\n  tf.cps.add({x: basevalueFn(data[0]), fx: 0});\n  tf.cps.add({x: basevalueFn(data[0]), fx: 0});\n\n  var p, value;\n  for (p = 1; p < 100; p++) {\n    x = (p * 0.01) * (data.length + 1) - 1; // indexing starts at zero, not at one\n    i = Math.trunc(x);\n    value = (1 - x + i) * basevalueFn(data[i]) + (x - i) * basevalueFn(data[i + 1]);\n    tf.cps.add({x: value, fx: p});\n  }\n\n  // add maximum value as p101 and p102\n  tf.cps.add({x: basevalueFn(data[data.length - 1]), fx: 100});\n  tf.cps.add({x: basevalueFn(data[data.length - 1]), fx: 100});\n\n  tf.type = 'percentiles';\n}\n\n/**\n * Autoconfigure a dataset:\n * 1. pick 10 random elements\n * 2. create facets for their properties\n * 3. add facets' values over the sample to the facet.description\n * 4. set range or categories\n *\n * @param {Dataset} dataset\n */\nfunction scan (dataset) {\n  function facetExists (facets, path) {\n    var exists = false;\n    facets.forEach(function (f) {\n      if (f.accessor === path || f.accessor === path + '[]') {\n        exists = true;\n      }\n    });\n    return exists;\n  }\n\n  function addValue (values, v, missing) {\n    if (v === misval) {\n      v = missing;\n    }\n    if (values.indexOf(v) === -1) {\n      values.push(v);\n    }\n  }\n\n  function guessType (values) {\n    var mytype = {\n      continuous: 0,\n      text: 0,\n      datetime: 0,\n      duration: 0,\n      categorial: 0\n    };\n    values.forEach(function (value) {\n      if (moment(value, moment.ISO_8601).isValid()) {\n        // \"2016-08-17 17:25:00+01\"\n        mytype.datetime++;\n      } else if (\n          (moment.duration(value).asMilliseconds() !== 0) &&\n          (typeof value === 'string') &&\n          (value[0].toLowerCase() === 'p')) {\n        // \"P10Y\"\n        mytype.duration++;\n      } else if (value == +value) {  // eslint-disable-line eqeqeq\n        // \"10\" or 10\n        mytype.continuous++;\n      } else {\n        // \"hello world\"\n        mytype.categorial++;\n      }\n    });\n\n    // get facetType with highest count\n    var max = -1;\n    var facetType;\n    Object.keys(mytype).forEach(function (key) {\n      if (mytype[key] > max) {\n        facetType = key;\n        max = mytype[key];\n      }\n    });\n\n    return facetType;\n  }\n\n  function tryFacet (facets, data, path, value) {\n    // Check for existence\n    if (facetExists(facets, path)) {\n      return;\n    }\n\n    // Create a new facet\n    var facet = facets.add({\n      name: path,\n      accessor: path,\n      type: 'text'\n    });\n\n    // Sample values\n    var baseValueFn = utildx.baseValueFn(facet);\n    var values = [];\n    var isArray = false;\n\n    data.forEach(function (d) {\n      var value = baseValueFn(d);\n      if (value instanceof Array) {\n        isArray = true;\n        value.forEach(function (v) {\n          addValue(values, v, facet.misval[0]);\n        });\n      } else {\n        addValue(values, value, facet.misval[0]);\n      }\n    });\n\n    // Reconfigure facet\n    facet.accessor = isArray ? facet.accessor + '[]' : facet.accessor;\n    facet.type = guessType(values);\n    facet.description = values.join(', ').match('^.{0,40}') + '...';\n    facet.isActive = true;\n  }\n\n  function recurse (facets, data, path, tree) {\n    var props = Object.getOwnPropertyNames(tree);\n    props.forEach(function (name) {\n      var subpath;\n      if (path) {\n        subpath = path + '##' + name;\n      } else {\n        subpath = name;\n      }\n\n      if (tree[name] instanceof Array) {\n        // add an array as a itself as a facet, ie. labelset, to prevent adding each element as separate facet\n        // also add the array length as facet\n        tryFacet(facets, data, subpath, tree[name]);\n        tryFacet(facets, data, subpath + '.length', tree[name].length);\n      } else if (tree[name] instanceof Object) {\n        // recurse into objects\n        recurse(facets, data, subpath, tree[name]);\n      } else {\n        // add strings and numbers as facets\n        tryFacet(facets, data, subpath, tree[name]);\n      }\n    });\n  }\n\n  // Add facets\n  var data = dataset.data.slice(0, 10);\n  data.forEach(function (d) {\n    recurse(dataset.facets, data, '', d);\n  });\n\n  dataset.facets.forEach(function (facet) {\n    if (facet.isCategorial) {\n      setCategories(dataset, facet);\n    } else if (facet.isContinuous || facet.isDatetime) {\n      setMinMax(dataset, facet);\n    }\n  });\n  dataset.trigger('syncFacets');\n}\n\n/**\n * Initialize the data filter, and construct the getData callback function on the filter.\n * @param {Dataview} dataview\n * @param {Filter} filter\n */\nfunction initDataFilter (dataview, filter) {\n  var facet;\n\n  // use the partitions as groups:\n  var groupFns = [];\n  filter.partitions.forEach(function (partition) {\n    facet = dataview.facets.get(partition.facetName, 'name');\n    var valueFn = utildx.valueFn(facet);\n    var groupFn = utildx.groupFn(partition);\n\n    var rank = partition.rank;\n    groupFns[rank - 1] = function (d) {\n      return groupFn(valueFn(d));\n    };\n  });\n\n  // and then create keys from the group values\n  var groupsKeys = function (d) {\n    var keys = [];\n\n    groupFns.forEach(function (groupFn) {\n      var result = groupFn(d);\n      var newKeys = [];\n      if (keys.length === 0) {\n        if (result instanceof Array) {\n          newKeys = result;\n        } else {\n          newKeys = [result];\n        }\n      } else {\n        if (result instanceof Array) {\n          keys.forEach(function (oldKey) {\n            result.forEach(function (key) {\n              newKeys.push(oldKey + '|' + key);\n            });\n          });\n        } else {\n          keys.forEach(function (oldKey) {\n            newKeys.push(oldKey + '|' + result);\n          });\n        }\n      }\n      keys = newKeys;\n    });\n    return keys;\n  };\n\n  // set up the facet valueFns to aggregate over\n  // and the reduction functions for them\n  var aggregateFns = [];\n  var aggregateRanks = [];\n  var reduceFns = [];\n  filter.aggregates.forEach(function (aggregate) {\n    facet = dataview.facets.get(aggregate.facetName, 'name');\n    aggregateRanks.push(aggregate.rank);\n    aggregateFns.push(utildx.valueFn(facet));\n    reduceFns.push(utildx.reduceFn(aggregate));\n  });\n\n  // setup the crossfilter dimensions and groups\n  filter.dimension = dataview.crossfilter.dimension(function (d) {\n    return groupsKeys(d);\n  }, true);\n  var crossfilterGroup = filter.dimension.group(function (d) { return d; });\n\n  crossfilterGroup.reduce(\n    // add\n    function (p, d) {\n      if (aggregateFns.length === 0) {\n        p[0] = p[0] ? p[0] : {count: 0};\n        p[0].count += 1;\n      }\n\n      aggregateFns.forEach(function (aggregateFn, i) {\n        var val = aggregateFn(d);\n        if (val !== misval) {\n          val = parseFloat(val);\n          p[i] = p[i] || {count: 0, sum: 0, sumsquares: 0};\n          p[i].count += 1;\n          p[i].sum += val;\n          p[i].sumsquares += val * val;\n        }\n      });\n      return p;\n    },\n    // subtract\n    function (p, d) {\n      if (aggregateFns.length === 0) {\n        p[0] = p[0] ? p[0] : {count: 0};\n        p[0].count -= 1;\n      }\n\n      aggregateFns.forEach(function (aggregateFn, i) {\n        var val = aggregateFn(d);\n        if (val !== misval) {\n          val = parseFloat(val);\n          p[i] = p[i] || {count: 0, sum: 0, sumsquares: 0};\n          p[i].count -= 1;\n          p[i].sum -= val;\n          p[i].sumsquares -= val * val;\n        }\n      });\n      return p;\n    },\n    // initialize\n    function () {\n      return [];\n    }\n  );\n\n  filter.getData = function () {\n    filter.data = [];\n\n    // Get data from crossfilter\n    var groups = crossfilterGroup.all();\n\n    // { key: \"group1|group2|...\",\n    //   value: [ {count: agg1, sum: agg1}\n    //            {count: agg2, sum: agg2}\n    //            {count: agg3, sum: agg3}\n    //                    ...             ]}\n    groups.forEach(function (group) {\n      var item = {};\n\n      // turn the string back into individual group values\n      var groupsKeys;\n      if (typeof group.key === 'string') {\n        groupsKeys = group.key.split('|');\n      } else {\n        // shortcut for numeric non-partitioned case\n        groupsKeys = [group.key];\n      }\n\n      // add paritioning data to the item\n      groupsKeys.forEach(function (subkey, i) {\n        item[grpIdxToName[i]] = subkey;\n      });\n\n      // add aggregated data to the item\n      reduceFns.forEach(function (reduceFn, i) {\n        var name = aggRankToName[aggregateRanks[i]];\n        item[name] = reduceFn(group.value[i]);\n      });\n\n      // add an overall count\n      // becuase the filtering removes missing data points, this is the same as\n      // the count for any one of the aggregates\n      item.count = group.value[0] ? group.value[0].count : 0;\n\n      filter.data.push(item);\n    });\n  };\n}\n\n/**\n * The opposite or initDataFilter, it should remove the filter and deallocate other configuration\n * related to the filter.\n * @param {Dataview} dataview\n * @param {Filter} filter\n */\nfunction releaseDataFilter (dataview, filter) {\n  if (filter.dimension) {\n    filter.dimension.filterAll();\n    filter.dimension.dispose();\n    delete filter.dimension;\n    delete filter.getData;\n  }\n}\n\n/**\n * Change the filter parameters for an initialized filter\n * @param {Filter} filter\n */\nfunction updateDataFilter (filter) {\n  if (filter.dimension) {\n    filter.dimension.filterFunction(filter.filterFunction());\n  }\n}\n\n/**\n * Get data for every filter, and trigger a 'newData' event\n *\n * Returns a Promise that resolves to the dataview when all data and metadata has been updated\n *\n * @param {Dataview} dataview\n * @returns {Promise}\n */\nfunction getData (dataview) {\n  dataview.filters.forEach(function (filter) {\n    if (filter.isInitialized) {\n      filter.getData();\n      filter.trigger('newData');\n    }\n  });\n\n  // update counts\n  dataview.dataTotal = dataview.crossfilter.size();\n  dataview.dataSelected = dataview.countGroup.value();\n  dataview.trigger('newMetaData');\n\n  return Promise.resolve(dataview);\n}\n\nmodule.exports = {\n  driverType: 'client',\n  scan: scan,\n  setMinMax: setMinMax,\n  setCategories: setCategories,\n  setPercentiles: setPercentiles,\n  initDataFilter: initDataFilter,\n  releaseDataFilter: releaseDataFilter,\n  updateDataFilter: updateDataFilter,\n  getData: getData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwYy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZHJpdmVyL2NsaWVudC5qcz9kZjc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2xpZW50IHNpZGUgZmlsdGVyaW5nIHVzaW5nIGNyb3NzZmlsdGVyXG4gKiBEdWUgdG8gbGltaXRhdGlvbiBvZiBjcm9zc2ZpbHRlciB3aXRoIGFycmF5IChvciBkYXRhIHRoYXQgaGFzIG5vIG5hdHJ1YWwgb3JkZXJpbmcpLCB0aGlzIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQ6XG4gKiAqIGRpbWVuc2lvbjogYGZ1bmN0aW9uIChkKSB7cmV0dXJuIFtkLngsIGQueSwgZC56XX1gXG4gKiAqIGdyb3VwOiBgZnVuY3Rpb24gKGQpIHtyZXR1cm4gW2QueCAvIDEwICwgZC55IC8gMTAsIGQueiAvIDEwXX1gXG4gKlxuICogVGhlcmVmb3JlLCB3ZSBwcmVmb3JtIGdyb3VwaW5nIGFscmVhZHkgaW4gdGhlIGRpbWVuc2lvbiBpdHNlbGYsIGFuZCBqb2luIHRoZSBhcnJheSB0byBhIHN0cmluZy5cbiAqIFN0cmluZ3MgaGF2ZSBhIG5hdHVyYWwgb3JkZXJpbmcgYW5kIHRodXMgY2FuIGJlIHVzZWQgYXMgZGltZW5zaW9uIHZhbHVlLlxuICogKiBkaW1lbnNpb246IGBmdW5jdGlvbiAoZCkgLT4gXCJkLngvMTB8ZC55LzEwfGQuei8xMFwiYFxuICogKiBncm91cDogYGZ1bmN0aW9uIChkKSB7cmV0dXJuIGQ7fWBcbiAqXG4gKiBAbW9kdWxlIGRyaXZlci9jbGllbnRcbiAqL1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuXG52YXIgdXRpbGR4ID0gcmVxdWlyZSgnLi4vdXRpbC9jcm9zc2ZpbHRlcicpO1xudmFyIG1pc3ZhbCA9IHJlcXVpcmUoJy4uL3V0aWwvbWlzdmFsJyk7XG5cbnZhciBncnBJZHhUb05hbWUgPSB7MDogJ2EnLCAxOiAnYicsIDI6ICdjJywgMzogJ2QnLCA0OiAnZSd9O1xudmFyIGFnZ1JhbmtUb05hbWUgPSB7MTogJ2FhJywgMjogJ2JiJywgMzogJ2NjJywgNDogJ2RkJywgNTogJ2VlJ307XG5cbi8qKlxuICogc2V0TWluTWF4IHNldHMgdGhlIHJhbmdlIG9mIGEgY29udGludW91cyBvciB0aW1lIGZhY2V0XG4gKlxuICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0XG4gKiBAcGFyYW0ge0ZhY2V0fSBmYWNldFxuICovXG5mdW5jdGlvbiBzZXRNaW5NYXggKGRhdGFzZXQsIGZhY2V0KSB7XG4gIC8vIHdlIG5lZWQgdGhlIHZhbHVlIGp1c3QgYmVmb3JlIGEgdHJhbnNmb3JtYXRpb24sIHNvIGJhc2VWYWx1ZUZuXG4gIHZhciB2YWxGbiA9IHV0aWxkeC5iYXNlVmFsdWVGbihmYWNldCk7XG5cbiAgLy8gdG8gYmUgYWJsZSB0byBtYXJrIHRoZSB2YWx1ZSBhcyBtaXNzaW5nIHdlIG5lZWQgaXQgdW5wcm9jZXNzZWQsIHNvIHJhd1ZhbHVlRm5cbiAgdmFyIHJhd1ZhbEZuID0gdXRpbGR4LnJhd1ZhbHVlRm4oZmFjZXQpO1xuXG4gIHZhciBsZXNzRm47XG4gIHZhciBtb3JlRm47XG4gIGlmIChmYWNldC5pc0RhdGV0aW1lKSB7XG4gICAgbGVzc0ZuID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChiID09PSBtaXN2YWwgfHwgYS5pc0JlZm9yZShiKSk7IH07XG4gICAgbW9yZUZuID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChiID09PSBtaXN2YWwgfHwgYi5pc0JlZm9yZShhKSk7IH07XG4gIH0gZWxzZSB7XG4gICAgbGVzc0ZuID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChiID09PSBtaXN2YWwgfHwgYSA8IGIpOyB9O1xuICAgIG1vcmVGbiA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYiA9PT0gbWlzdmFsIHx8IGEgPiBiKTsgfTtcbiAgfVxuXG4gIHZhciBtaW52YWwgPSBtaXN2YWw7XG4gIHZhciByYXdNaW4gPSBtaXN2YWw7XG5cbiAgdmFyIG1heHZhbCA9IG1pc3ZhbDtcbiAgdmFyIHJhd01heCA9IG1pc3ZhbDtcblxuICBkYXRhc2V0LmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIHZhciByYXdWID0gcmF3VmFsRm4oZCk7XG4gICAgdmFyIHYgPSB2YWxGbihkKTtcblxuICAgIGlmICh2ICE9PSBtaXN2YWwpIHtcbiAgICAgIGlmIChsZXNzRm4odiwgbWludmFsKSkge1xuICAgICAgICBtaW52YWwgPSB2O1xuICAgICAgICByYXdNaW4gPSByYXdWO1xuICAgICAgfVxuICAgICAgaWYgKG1vcmVGbih2LCBtYXh2YWwpKSB7XG4gICAgICAgIG1heHZhbCA9IHY7XG4gICAgICAgIHJhd01heCA9IHJhd1Y7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAobWludmFsICE9PSBtaXN2YWwpIHtcbiAgICBpZiAoZmFjZXQuaXNDb250aW51b3VzKSB7XG4gICAgICBmYWNldC5taW52YWxBc1RleHQgPSBtaW52YWwudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKGZhY2V0LmlzRGF0ZXRpbWUpIHtcbiAgICAgIGZhY2V0Lm1pbnZhbEFzVGV4dCA9IG1pbnZhbC50b0lTT1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAoZmFjZXQuaXNEdXJhdGlvbikge1xuICAgICAgZmFjZXQubWludmFsQXNUZXh0ID0gbWludmFsLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGZhY2V0LnJhd01pbnZhbCA9IHJhd01pbjtcbiAgfSBlbHNlIHtcbiAgICBmYWNldC5taW52YWxBc1RleHQgPSAnJztcbiAgICBmYWNldC5yYXdNaW52YWwgPSBtaXN2YWw7XG4gIH1cblxuICBpZiAobWF4dmFsICE9PSBtaXN2YWwpIHtcbiAgICBpZiAoZmFjZXQuaXNDb250aW51b3VzKSB7XG4gICAgICBmYWNldC5tYXh2YWxBc1RleHQgPSBtYXh2YWwudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKGZhY2V0LmlzRGF0ZXRpbWUpIHtcbiAgICAgIGZhY2V0Lm1heHZhbEFzVGV4dCA9IG1heHZhbC50b0lTT1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAoZmFjZXQuaXNEdXJhdGlvbikge1xuICAgICAgZmFjZXQubWF4dmFsQXNUZXh0ID0gbWF4dmFsLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGZhY2V0LnJhd01heHZhbCA9IHJhd01heDtcbiAgfSBlbHNlIHtcbiAgICBmYWNldC5tYXh2YWxBc1RleHQgPSAnJztcbiAgICBmYWNldC5yYXdNYXh2YWwgPSBtaXN2YWw7XG4gIH1cbn1cblxuLyoqXG4gKiBzZXRDYXRlZ29yaWVzIGZpbmRzIGZpbmRzIGFsbCB2YWx1ZXMgb24gYW4gb3JkaW5hbCAoY2F0ZWdvcmlhbCkgYXhpc1xuICogVXBkYXRlcyB0aGUgY2F0ZWdvcmlhbFRyYW5zZm9ybSBvZiB0aGUgZmFjZXRcbiAqXG4gKiBAcGFyYW0ge0RhdGFzZXR9IGRhdGFzZXRcbiAqIEBwYXJhbSB7RmFjZXR9IGZhY2V0XG4gKi9cbmZ1bmN0aW9uIHNldENhdGVnb3JpZXMgKGRhdGFzZXQsIGZhY2V0KSB7XG4gIC8vIHdlIG5lZWQgdGhlIHZhbHVlIGp1c3QgYmVmb3JlIGEgdHJhbnNmb3JtYXRpb24sIHNvIGJhc2VWYWx1ZUZuXG4gIHZhciB2YWxGbiA9IHV0aWxkeC5iYXNlVmFsdWVGbihmYWNldCk7XG5cbiAgdmFyIHAgPSB7fTtcbiAgdmFyIFBsZW5ndGggPSAwO1xuICBkYXRhc2V0LmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHZhciB2YWxzID0gdmFsRm4oZCk7XG4gICAgaWYgKHZhbHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFscy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKHAuaGFzT3duUHJvcGVydHkodmFsKSkge1xuICAgICAgICAgIHBbdmFsXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChQbGVuZ3RoIDwgNzUpIHsgLy8gTk9URTogbGltaXQgdG8gbWF4aW1hbGx5IDc1IGNhdGVnb3JpZXNcbiAgICAgICAgICAgIHBbdmFsXSA9IDE7XG4gICAgICAgICAgICBQbGVuZ3RoKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHAuaGFzT3duUHJvcGVydHkodmFscykpIHtcbiAgICAgICAgcFt2YWxzXSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFBsZW5ndGggPCA3NSkgeyAvLyBOT1RFOiBsaW1pdCB0byBtYXhpbWFsbHkgNzUgY2F0ZWdvcmllc1xuICAgICAgICAgIHBbdmFsc10gPSAxO1xuICAgICAgICAgIFBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5yZXNldCgpO1xuXG4gIE9iamVjdC5rZXlzKHApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIC8vIFRPRE86IG1pc3NpbmcgZGF0YSBzaG91bGQgYmUgbWFwcGVkIHRvIGEgbWlzdmFsIGZyb20gbWlzdmFsQXNUZXh0XG4gICAgdmFyIGtleUFzU3RyaW5nID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGdyb3VwQXNTdHJpbmcgPSBrZXlBc1N0cmluZztcblxuICAgIGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0ucnVsZXMuYWRkKHtleHByZXNzaW9uOiBrZXlBc1N0cmluZywgY291bnQ6IHBba2V5XSwgZ3JvdXA6IGdyb3VwQXNTdHJpbmd9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIDEwMCBwZXJjZW50aWxlcyAoaWUuIDEsMiwzLDQgZXRjLiksIGFuZCBpbml0aWFsaXplIHRoZSBgZmFjZXQuY29udGludW91c1RyYW5zZm9ybWBcbiAqIHRvIGFuIGFwcHJveGltYXRlIHBlcmNlbnRpbGUgbWFwcGluZy5cbiAqIFVzZSB0aGUgcmVjb21tZW5kZWQgbWV0aG9kIGZyb20gW05JU1RdKGh0dHA6Ly93d3cuaXRsLm5pc3QuZ292L2Rpdjg5OC9oYW5kYm9vay9wcmMvc2VjdGlvbjIvcHJjMjYyLmh0bSlcbiAqIFNlZSBhbHNvIHRoZSBkaXNjdXNzaW9uIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcmNlbnRpbGUpXG4gKlxuICogQHBhcmFtIHtEYXRhc2V0fSBkYXRhc2V0XG4gKiBAcGFyYW0ge0ZhY2V0fSBmYWNldFxuICovXG5mdW5jdGlvbiBzZXRQZXJjZW50aWxlcyAoZGF0YXNldCwgZmFjZXQpIHtcbiAgLy8gd2UgbmVlZCB0aGUgdmFsdWUganVzdCBiZWZvcmUgYSB0cmFuc2Zvcm1hdGlvbiwgc28gYmFzZVZhbHVlRm5cbiAgdmFyIGJhc2V2YWx1ZUZuID0gdXRpbGR4LmJhc2VWYWx1ZUZuKGZhY2V0KTtcbiAgdmFyIGRhdGEgPSBkYXRhc2V0LmRhdGE7XG5cbiAgZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHZhbEEgPSBiYXNldmFsdWVGbihhKTtcbiAgICB2YXIgdmFsQiA9IGJhc2V2YWx1ZUZuKGIpO1xuXG4gICAgaWYgKHZhbEEgPT09IHZhbEIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodmFsQSA9PT0gbWlzdmFsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh2YWxCID09PSBtaXN2YWwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICh2YWxBIDwgdmFsQikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0ZiA9IGZhY2V0LmNvbnRpbnVvdXNUcmFuc2Zvcm07XG4gIHZhciB4LCBpO1xuXG4gIC8vIGRyb3AgbWlzc2luZyB2YWx1ZXMsIHdoaWNoIHNob3VsZCBiZSBzb3J0ZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheVxuICBpID0gMDtcbiAgd2hpbGUgKGJhc2V2YWx1ZUZuKGRhdGFbaV0pID09PSBtaXN2YWwgJiYgaSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgaSsrO1xuICB9XG4gIGRhdGEuc3BsaWNlKDAsIGkpO1xuXG4gIC8vIHN0YXJ0IGNsZWFuXG4gIHRmLnJlc2V0KCk7XG5cbiAgLy8gYWRkIG1pbmltdW0gdmFsdWUgYXMgY29udHJvbCBwb2ludHMgcDAgYW5kIHAxXG4gIHRmLmNwcy5hZGQoe3g6IGJhc2V2YWx1ZUZuKGRhdGFbMF0pLCBmeDogMH0pO1xuICB0Zi5jcHMuYWRkKHt4OiBiYXNldmFsdWVGbihkYXRhWzBdKSwgZng6IDB9KTtcblxuICB2YXIgcCwgdmFsdWU7XG4gIGZvciAocCA9IDE7IHAgPCAxMDA7IHArKykge1xuICAgIHggPSAocCAqIDAuMDEpICogKGRhdGEubGVuZ3RoICsgMSkgLSAxOyAvLyBpbmRleGluZyBzdGFydHMgYXQgemVybywgbm90IGF0IG9uZVxuICAgIGkgPSBNYXRoLnRydW5jKHgpO1xuICAgIHZhbHVlID0gKDEgLSB4ICsgaSkgKiBiYXNldmFsdWVGbihkYXRhW2ldKSArICh4IC0gaSkgKiBiYXNldmFsdWVGbihkYXRhW2kgKyAxXSk7XG4gICAgdGYuY3BzLmFkZCh7eDogdmFsdWUsIGZ4OiBwfSk7XG4gIH1cblxuICAvLyBhZGQgbWF4aW11bSB2YWx1ZSBhcyBwMTAxIGFuZCBwMTAyXG4gIHRmLmNwcy5hZGQoe3g6IGJhc2V2YWx1ZUZuKGRhdGFbZGF0YS5sZW5ndGggLSAxXSksIGZ4OiAxMDB9KTtcbiAgdGYuY3BzLmFkZCh7eDogYmFzZXZhbHVlRm4oZGF0YVtkYXRhLmxlbmd0aCAtIDFdKSwgZng6IDEwMH0pO1xuXG4gIHRmLnR5cGUgPSAncGVyY2VudGlsZXMnO1xufVxuXG4vKipcbiAqIEF1dG9jb25maWd1cmUgYSBkYXRhc2V0OlxuICogMS4gcGljayAxMCByYW5kb20gZWxlbWVudHNcbiAqIDIuIGNyZWF0ZSBmYWNldHMgZm9yIHRoZWlyIHByb3BlcnRpZXNcbiAqIDMuIGFkZCBmYWNldHMnIHZhbHVlcyBvdmVyIHRoZSBzYW1wbGUgdG8gdGhlIGZhY2V0LmRlc2NyaXB0aW9uXG4gKiA0LiBzZXQgcmFuZ2Ugb3IgY2F0ZWdvcmllc1xuICpcbiAqIEBwYXJhbSB7RGF0YXNldH0gZGF0YXNldFxuICovXG5mdW5jdGlvbiBzY2FuIChkYXRhc2V0KSB7XG4gIGZ1bmN0aW9uIGZhY2V0RXhpc3RzIChmYWNldHMsIHBhdGgpIHtcbiAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgZmFjZXRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIGlmIChmLmFjY2Vzc29yID09PSBwYXRoIHx8IGYuYWNjZXNzb3IgPT09IHBhdGggKyAnW10nKSB7XG4gICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4aXN0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZhbHVlICh2YWx1ZXMsIHYsIG1pc3NpbmcpIHtcbiAgICBpZiAodiA9PT0gbWlzdmFsKSB7XG4gICAgICB2ID0gbWlzc2luZztcbiAgICB9XG4gICAgaWYgKHZhbHVlcy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgdmFsdWVzLnB1c2godik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ3Vlc3NUeXBlICh2YWx1ZXMpIHtcbiAgICB2YXIgbXl0eXBlID0ge1xuICAgICAgY29udGludW91czogMCxcbiAgICAgIHRleHQ6IDAsXG4gICAgICBkYXRldGltZTogMCxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgY2F0ZWdvcmlhbDogMFxuICAgIH07XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAobW9tZW50KHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBcIjIwMTYtMDgtMTcgMTc6MjU6MDArMDFcIlxuICAgICAgICBteXR5cGUuZGF0ZXRpbWUrKztcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgKG1vbWVudC5kdXJhdGlvbih2YWx1ZSkuYXNNaWxsaXNlY29uZHMoKSAhPT0gMCkgJiZcbiAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAodmFsdWVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnKSkge1xuICAgICAgICAvLyBcIlAxMFlcIlxuICAgICAgICBteXR5cGUuZHVyYXRpb24rKztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gK3ZhbHVlKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAvLyBcIjEwXCIgb3IgMTBcbiAgICAgICAgbXl0eXBlLmNvbnRpbnVvdXMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFwiaGVsbG8gd29ybGRcIlxuICAgICAgICBteXR5cGUuY2F0ZWdvcmlhbCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZ2V0IGZhY2V0VHlwZSB3aXRoIGhpZ2hlc3QgY291bnRcbiAgICB2YXIgbWF4ID0gLTE7XG4gICAgdmFyIGZhY2V0VHlwZTtcbiAgICBPYmplY3Qua2V5cyhteXR5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG15dHlwZVtrZXldID4gbWF4KSB7XG4gICAgICAgIGZhY2V0VHlwZSA9IGtleTtcbiAgICAgICAgbWF4ID0gbXl0eXBlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmFjZXRUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5RmFjZXQgKGZhY2V0cywgZGF0YSwgcGF0aCwgdmFsdWUpIHtcbiAgICAvLyBDaGVjayBmb3IgZXhpc3RlbmNlXG4gICAgaWYgKGZhY2V0RXhpc3RzKGZhY2V0cywgcGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgZmFjZXRcbiAgICB2YXIgZmFjZXQgPSBmYWNldHMuYWRkKHtcbiAgICAgIG5hbWU6IHBhdGgsXG4gICAgICBhY2Nlc3NvcjogcGF0aCxcbiAgICAgIHR5cGU6ICd0ZXh0J1xuICAgIH0pO1xuXG4gICAgLy8gU2FtcGxlIHZhbHVlc1xuICAgIHZhciBiYXNlVmFsdWVGbiA9IHV0aWxkeC5iYXNlVmFsdWVGbihmYWNldCk7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciBpc0FycmF5ID0gZmFsc2U7XG5cbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGJhc2VWYWx1ZUZuKGQpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBhZGRWYWx1ZSh2YWx1ZXMsIHYsIGZhY2V0Lm1pc3ZhbFswXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVmFsdWUodmFsdWVzLCB2YWx1ZSwgZmFjZXQubWlzdmFsWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlY29uZmlndXJlIGZhY2V0XG4gICAgZmFjZXQuYWNjZXNzb3IgPSBpc0FycmF5ID8gZmFjZXQuYWNjZXNzb3IgKyAnW10nIDogZmFjZXQuYWNjZXNzb3I7XG4gICAgZmFjZXQudHlwZSA9IGd1ZXNzVHlwZSh2YWx1ZXMpO1xuICAgIGZhY2V0LmRlc2NyaXB0aW9uID0gdmFsdWVzLmpvaW4oJywgJykubWF0Y2goJ14uezAsNDB9JykgKyAnLi4uJztcbiAgICBmYWNldC5pc0FjdGl2ZSA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWN1cnNlIChmYWNldHMsIGRhdGEsIHBhdGgsIHRyZWUpIHtcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0cmVlKTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgc3VicGF0aDtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHN1YnBhdGggPSBwYXRoICsgJyMjJyArIG5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyZWVbbmFtZV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAvLyBhZGQgYW4gYXJyYXkgYXMgYSBpdHNlbGYgYXMgYSBmYWNldCwgaWUuIGxhYmVsc2V0LCB0byBwcmV2ZW50IGFkZGluZyBlYWNoIGVsZW1lbnQgYXMgc2VwYXJhdGUgZmFjZXRcbiAgICAgICAgLy8gYWxzbyBhZGQgdGhlIGFycmF5IGxlbmd0aCBhcyBmYWNldFxuICAgICAgICB0cnlGYWNldChmYWNldHMsIGRhdGEsIHN1YnBhdGgsIHRyZWVbbmFtZV0pO1xuICAgICAgICB0cnlGYWNldChmYWNldHMsIGRhdGEsIHN1YnBhdGggKyAnLmxlbmd0aCcsIHRyZWVbbmFtZV0ubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAodHJlZVtuYW1lXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAvLyByZWN1cnNlIGludG8gb2JqZWN0c1xuICAgICAgICByZWN1cnNlKGZhY2V0cywgZGF0YSwgc3VicGF0aCwgdHJlZVtuYW1lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgc3RyaW5ncyBhbmQgbnVtYmVycyBhcyBmYWNldHNcbiAgICAgICAgdHJ5RmFjZXQoZmFjZXRzLCBkYXRhLCBzdWJwYXRoLCB0cmVlW25hbWVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZCBmYWNldHNcbiAgdmFyIGRhdGEgPSBkYXRhc2V0LmRhdGEuc2xpY2UoMCwgMTApO1xuICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICByZWN1cnNlKGRhdGFzZXQuZmFjZXRzLCBkYXRhLCAnJywgZCk7XG4gIH0pO1xuXG4gIGRhdGFzZXQuZmFjZXRzLmZvckVhY2goZnVuY3Rpb24gKGZhY2V0KSB7XG4gICAgaWYgKGZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgICAgc2V0Q2F0ZWdvcmllcyhkYXRhc2V0LCBmYWNldCk7XG4gICAgfSBlbHNlIGlmIChmYWNldC5pc0NvbnRpbnVvdXMgfHwgZmFjZXQuaXNEYXRldGltZSkge1xuICAgICAgc2V0TWluTWF4KGRhdGFzZXQsIGZhY2V0KTtcbiAgICB9XG4gIH0pO1xuICBkYXRhc2V0LnRyaWdnZXIoJ3N5bmNGYWNldHMnKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBkYXRhIGZpbHRlciwgYW5kIGNvbnN0cnVjdCB0aGUgZ2V0RGF0YSBjYWxsYmFjayBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyLlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEBwYXJhbSB7RmlsdGVyfSBmaWx0ZXJcbiAqL1xuZnVuY3Rpb24gaW5pdERhdGFGaWx0ZXIgKGRhdGF2aWV3LCBmaWx0ZXIpIHtcbiAgdmFyIGZhY2V0O1xuXG4gIC8vIHVzZSB0aGUgcGFydGl0aW9ucyBhcyBncm91cHM6XG4gIHZhciBncm91cEZucyA9IFtdO1xuICBmaWx0ZXIucGFydGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aXRpb24pIHtcbiAgICBmYWNldCA9IGRhdGF2aWV3LmZhY2V0cy5nZXQocGFydGl0aW9uLmZhY2V0TmFtZSwgJ25hbWUnKTtcbiAgICB2YXIgdmFsdWVGbiA9IHV0aWxkeC52YWx1ZUZuKGZhY2V0KTtcbiAgICB2YXIgZ3JvdXBGbiA9IHV0aWxkeC5ncm91cEZuKHBhcnRpdGlvbik7XG5cbiAgICB2YXIgcmFuayA9IHBhcnRpdGlvbi5yYW5rO1xuICAgIGdyb3VwRm5zW3JhbmsgLSAxXSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZ3JvdXBGbih2YWx1ZUZuKGQpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBhbmQgdGhlbiBjcmVhdGUga2V5cyBmcm9tIHRoZSBncm91cCB2YWx1ZXNcbiAgdmFyIGdyb3Vwc0tleXMgPSBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBncm91cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cEZuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ3JvdXBGbihkKTtcbiAgICAgIHZhciBuZXdLZXlzID0gW107XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgbmV3S2V5cyA9IHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdLZXlzID0gW3Jlc3VsdF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAob2xkS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIG5ld0tleXMucHVzaChvbGRLZXkgKyAnfCcgKyBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChvbGRLZXkpIHtcbiAgICAgICAgICAgIG5ld0tleXMucHVzaChvbGRLZXkgKyAnfCcgKyByZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXlzID0gbmV3S2V5cztcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBzZXQgdXAgdGhlIGZhY2V0IHZhbHVlRm5zIHRvIGFnZ3JlZ2F0ZSBvdmVyXG4gIC8vIGFuZCB0aGUgcmVkdWN0aW9uIGZ1bmN0aW9ucyBmb3IgdGhlbVxuICB2YXIgYWdncmVnYXRlRm5zID0gW107XG4gIHZhciBhZ2dyZWdhdGVSYW5rcyA9IFtdO1xuICB2YXIgcmVkdWNlRm5zID0gW107XG4gIGZpbHRlci5hZ2dyZWdhdGVzLmZvckVhY2goZnVuY3Rpb24gKGFnZ3JlZ2F0ZSkge1xuICAgIGZhY2V0ID0gZGF0YXZpZXcuZmFjZXRzLmdldChhZ2dyZWdhdGUuZmFjZXROYW1lLCAnbmFtZScpO1xuICAgIGFnZ3JlZ2F0ZVJhbmtzLnB1c2goYWdncmVnYXRlLnJhbmspO1xuICAgIGFnZ3JlZ2F0ZUZucy5wdXNoKHV0aWxkeC52YWx1ZUZuKGZhY2V0KSk7XG4gICAgcmVkdWNlRm5zLnB1c2godXRpbGR4LnJlZHVjZUZuKGFnZ3JlZ2F0ZSkpO1xuICB9KTtcblxuICAvLyBzZXR1cCB0aGUgY3Jvc3NmaWx0ZXIgZGltZW5zaW9ucyBhbmQgZ3JvdXBzXG4gIGZpbHRlci5kaW1lbnNpb24gPSBkYXRhdmlldy5jcm9zc2ZpbHRlci5kaW1lbnNpb24oZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZ3JvdXBzS2V5cyhkKTtcbiAgfSwgdHJ1ZSk7XG4gIHZhciBjcm9zc2ZpbHRlckdyb3VwID0gZmlsdGVyLmRpbWVuc2lvbi5ncm91cChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZDsgfSk7XG5cbiAgY3Jvc3NmaWx0ZXJHcm91cC5yZWR1Y2UoXG4gICAgLy8gYWRkXG4gICAgZnVuY3Rpb24gKHAsIGQpIHtcbiAgICAgIGlmIChhZ2dyZWdhdGVGbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdID8gcFswXSA6IHtjb3VudDogMH07XG4gICAgICAgIHBbMF0uY291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgYWdncmVnYXRlRm5zLmZvckVhY2goZnVuY3Rpb24gKGFnZ3JlZ2F0ZUZuLCBpKSB7XG4gICAgICAgIHZhciB2YWwgPSBhZ2dyZWdhdGVGbihkKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gbWlzdmFsKSB7XG4gICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgIHBbaV0gPSBwW2ldIHx8IHtjb3VudDogMCwgc3VtOiAwLCBzdW1zcXVhcmVzOiAwfTtcbiAgICAgICAgICBwW2ldLmNvdW50ICs9IDE7XG4gICAgICAgICAgcFtpXS5zdW0gKz0gdmFsO1xuICAgICAgICAgIHBbaV0uc3Vtc3F1YXJlcyArPSB2YWwgKiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICAvLyBzdWJ0cmFjdFxuICAgIGZ1bmN0aW9uIChwLCBkKSB7XG4gICAgICBpZiAoYWdncmVnYXRlRm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwWzBdID0gcFswXSA/IHBbMF0gOiB7Y291bnQ6IDB9O1xuICAgICAgICBwWzBdLmNvdW50IC09IDE7XG4gICAgICB9XG5cbiAgICAgIGFnZ3JlZ2F0ZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChhZ2dyZWdhdGVGbiwgaSkge1xuICAgICAgICB2YXIgdmFsID0gYWdncmVnYXRlRm4oZCk7XG4gICAgICAgIGlmICh2YWwgIT09IG1pc3ZhbCkge1xuICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICBwW2ldID0gcFtpXSB8fCB7Y291bnQ6IDAsIHN1bTogMCwgc3Vtc3F1YXJlczogMH07XG4gICAgICAgICAgcFtpXS5jb3VudCAtPSAxO1xuICAgICAgICAgIHBbaV0uc3VtIC09IHZhbDtcbiAgICAgICAgICBwW2ldLnN1bXNxdWFyZXMgLT0gdmFsICogdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICk7XG5cbiAgZmlsdGVyLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmlsdGVyLmRhdGEgPSBbXTtcblxuICAgIC8vIEdldCBkYXRhIGZyb20gY3Jvc3NmaWx0ZXJcbiAgICB2YXIgZ3JvdXBzID0gY3Jvc3NmaWx0ZXJHcm91cC5hbGwoKTtcblxuICAgIC8vIHsga2V5OiBcImdyb3VwMXxncm91cDJ8Li4uXCIsXG4gICAgLy8gICB2YWx1ZTogWyB7Y291bnQ6IGFnZzEsIHN1bTogYWdnMX1cbiAgICAvLyAgICAgICAgICAgIHtjb3VudDogYWdnMiwgc3VtOiBhZ2cyfVxuICAgIC8vICAgICAgICAgICAge2NvdW50OiBhZ2czLCBzdW06IGFnZzN9XG4gICAgLy8gICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICBdfVxuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgdmFyIGl0ZW0gPSB7fTtcblxuICAgICAgLy8gdHVybiB0aGUgc3RyaW5nIGJhY2sgaW50byBpbmRpdmlkdWFsIGdyb3VwIHZhbHVlc1xuICAgICAgdmFyIGdyb3Vwc0tleXM7XG4gICAgICBpZiAodHlwZW9mIGdyb3VwLmtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ3JvdXBzS2V5cyA9IGdyb3VwLmtleS5zcGxpdCgnfCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvcnRjdXQgZm9yIG51bWVyaWMgbm9uLXBhcnRpdGlvbmVkIGNhc2VcbiAgICAgICAgZ3JvdXBzS2V5cyA9IFtncm91cC5rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcGFyaXRpb25pbmcgZGF0YSB0byB0aGUgaXRlbVxuICAgICAgZ3JvdXBzS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJrZXksIGkpIHtcbiAgICAgICAgaXRlbVtncnBJZHhUb05hbWVbaV1dID0gc3Via2V5O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBhZ2dyZWdhdGVkIGRhdGEgdG8gdGhlIGl0ZW1cbiAgICAgIHJlZHVjZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWR1Y2VGbiwgaSkge1xuICAgICAgICB2YXIgbmFtZSA9IGFnZ1JhbmtUb05hbWVbYWdncmVnYXRlUmFua3NbaV1dO1xuICAgICAgICBpdGVtW25hbWVdID0gcmVkdWNlRm4oZ3JvdXAudmFsdWVbaV0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBhbiBvdmVyYWxsIGNvdW50XG4gICAgICAvLyBiZWN1YXNlIHRoZSBmaWx0ZXJpbmcgcmVtb3ZlcyBtaXNzaW5nIGRhdGEgcG9pbnRzLCB0aGlzIGlzIHRoZSBzYW1lIGFzXG4gICAgICAvLyB0aGUgY291bnQgZm9yIGFueSBvbmUgb2YgdGhlIGFnZ3JlZ2F0ZXNcbiAgICAgIGl0ZW0uY291bnQgPSBncm91cC52YWx1ZVswXSA/IGdyb3VwLnZhbHVlWzBdLmNvdW50IDogMDtcblxuICAgICAgZmlsdGVyLmRhdGEucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb3IgaW5pdERhdGFGaWx0ZXIsIGl0IHNob3VsZCByZW1vdmUgdGhlIGZpbHRlciBhbmQgZGVhbGxvY2F0ZSBvdGhlciBjb25maWd1cmF0aW9uXG4gKiByZWxhdGVkIHRvIHRoZSBmaWx0ZXIuXG4gKiBAcGFyYW0ge0RhdGF2aWV3fSBkYXRhdmlld1xuICogQHBhcmFtIHtGaWx0ZXJ9IGZpbHRlclxuICovXG5mdW5jdGlvbiByZWxlYXNlRGF0YUZpbHRlciAoZGF0YXZpZXcsIGZpbHRlcikge1xuICBpZiAoZmlsdGVyLmRpbWVuc2lvbikge1xuICAgIGZpbHRlci5kaW1lbnNpb24uZmlsdGVyQWxsKCk7XG4gICAgZmlsdGVyLmRpbWVuc2lvbi5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIGZpbHRlci5kaW1lbnNpb247XG4gICAgZGVsZXRlIGZpbHRlci5nZXREYXRhO1xuICB9XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBmaWx0ZXIgcGFyYW1ldGVycyBmb3IgYW4gaW5pdGlhbGl6ZWQgZmlsdGVyXG4gKiBAcGFyYW0ge0ZpbHRlcn0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZURhdGFGaWx0ZXIgKGZpbHRlcikge1xuICBpZiAoZmlsdGVyLmRpbWVuc2lvbikge1xuICAgIGZpbHRlci5kaW1lbnNpb24uZmlsdGVyRnVuY3Rpb24oZmlsdGVyLmZpbHRlckZ1bmN0aW9uKCkpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGRhdGEgZm9yIGV2ZXJ5IGZpbHRlciwgYW5kIHRyaWdnZXIgYSAnbmV3RGF0YScgZXZlbnRcbiAqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkYXRhdmlldyB3aGVuIGFsbCBkYXRhIGFuZCBtZXRhZGF0YSBoYXMgYmVlbiB1cGRhdGVkXG4gKlxuICogQHBhcmFtIHtEYXRhdmlld30gZGF0YXZpZXdcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhdmlldykge1xuICBkYXRhdmlldy5maWx0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuaXNJbml0aWFsaXplZCkge1xuICAgICAgZmlsdGVyLmdldERhdGEoKTtcbiAgICAgIGZpbHRlci50cmlnZ2VyKCduZXdEYXRhJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyB1cGRhdGUgY291bnRzXG4gIGRhdGF2aWV3LmRhdGFUb3RhbCA9IGRhdGF2aWV3LmNyb3NzZmlsdGVyLnNpemUoKTtcbiAgZGF0YXZpZXcuZGF0YVNlbGVjdGVkID0gZGF0YXZpZXcuY291bnRHcm91cC52YWx1ZSgpO1xuICBkYXRhdmlldy50cmlnZ2VyKCduZXdNZXRhRGF0YScpO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YXZpZXcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJpdmVyVHlwZTogJ2NsaWVudCcsXG4gIHNjYW46IHNjYW4sXG4gIHNldE1pbk1heDogc2V0TWluTWF4LFxuICBzZXRDYXRlZ29yaWVzOiBzZXRDYXRlZ29yaWVzLFxuICBzZXRQZXJjZW50aWxlczogc2V0UGVyY2VudGlsZXMsXG4gIGluaXREYXRhRmlsdGVyOiBpbml0RGF0YUZpbHRlcixcbiAgcmVsZWFzZURhdGFGaWx0ZXI6IHJlbGVhc2VEYXRhRmlsdGVyLFxuICB1cGRhdGVEYXRhRmlsdGVyOiB1cGRhdGVEYXRhRmlsdGVyLFxuICBnZXREYXRhOiBnZXREYXRhXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///720c\n")},"753f":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar crossfilter_identity = __webpack_require__(/*! ./identity */ "55a3");\n\nfunction insertionsort_by(f) {\n\n  function insertionsort(a, lo, hi) {\n    for (var i = lo + 1; i < hi; ++i) {\n      for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n        a[j] = a[j - 1];\n      }\n      a[j] = t;\n    }\n    return a;\n  }\n\n  return insertionsort;\n}\n\nmodule.exports = insertionsort_by(crossfilter_identity);\nmodule.exports.by = insertionsort_by;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUzZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9pbnNlcnRpb25zb3J0LmpzPzJkNmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3Jvc3NmaWx0ZXJfaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbmZ1bmN0aW9uIGluc2VydGlvbnNvcnRfYnkoZikge1xuXG4gIGZ1bmN0aW9uIGluc2VydGlvbnNvcnQoYSwgbG8sIGhpKSB7XG4gICAgZm9yICh2YXIgaSA9IGxvICsgMTsgaSA8IGhpOyArK2kpIHtcbiAgICAgIGZvciAodmFyIGogPSBpLCB0ID0gYVtpXSwgeCA9IGYodCk7IGogPiBsbyAmJiBmKGFbaiAtIDFdKSA+IHg7IC0taikge1xuICAgICAgICBhW2pdID0gYVtqIC0gMV07XG4gICAgICB9XG4gICAgICBhW2pdID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICByZXR1cm4gaW5zZXJ0aW9uc29ydDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRpb25zb3J0X2J5KGNyb3NzZmlsdGVyX2lkZW50aXR5KTtcbm1vZHVsZS5leHBvcnRzLmJ5ID0gaW5zZXJ0aW9uc29ydF9ieTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///753f\n')},"780f":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module dependencies.\n */\n\nvar parseuri = __webpack_require__(/*! parseuri */ \"64a0\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url (uri, loc) {\n  var obj = uri;\n\n  // default to window.location\n  loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' === typeof uri) {\n    if ('/' === uri.charAt(0)) {\n      if ('/' === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' !== typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgwZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzPzAwMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCAodXJpLCBsb2MpIHtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgdmFyIGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKCc6JykgIT09IC0xO1xuICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///780f\n")},"7d91":function(module,exports){eval("\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiN2Q5MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcz83NTljIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7d91\n")},"7fa4":function(module,exports,__webpack_require__){eval('var Collection = __webpack_require__(/*! ampersand-collection */ "7bd3");\nvar Filter = __webpack_require__(/*! ../filter */ "9476");\n\nmodule.exports = Collection.extend({\n  mainIndex: \'id\',\n  model: Filter,\n  comparator: function (a, b) {\n    if (a.row > b.row || a.row === b.row && a.col > b.col) {\n      return 1;\n    }\n    if (a.col === b.col) {\n      return 0;\n    }\n    return -1;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiN2ZhNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmlsdGVyL2NvbGxlY3Rpb24uanM/ODgyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtYWluSW5kZXg6ICdpZCcsXG4gIG1vZGVsOiBGaWx0ZXIsXG4gIGNvbXBhcmF0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEucm93ID4gYi5yb3cgfHwgYS5yb3cgPT09IGIucm93ICYmIGEuY29sID4gYi5jb2wpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYS5jb2wgPT09IGIuY29sKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7fa4\n')},8191:function(module,exports,__webpack_require__){eval("/**\n * Partition\n *\n * Describes a partitioning of the data, based on the values a Facet can take.\n *\n * @class Partition\n * @extends Base\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Groups = __webpack_require__(/*! ./partition/group-collection */ \"0056\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar selection = __webpack_require__(/*! ./util/selection */ \"1278\");\nvar util = __webpack_require__(/*! ./util/time */ \"d45b\");\n\n/*\n * @param {Partition} partition\n * @param {Group[]} groups\n * @memberof! Partition\n */\nfunction setDatetimeGroups (partition, groups) {\n  var timeStart = partition.minval;\n  var timeEnd = partition.maxval;\n  var timeRes = util.getDatetimeResolution(timeStart, timeEnd);\n  var timeZone = partition.zone;\n\n  var current = moment(timeStart);\n  while ((!current.isAfter(timeEnd)) && groups.length < 500) {\n    groups.add({\n      min: moment(current).tz(timeZone).startOf(timeRes),\n      max: moment(current).tz(timeZone).endOf(timeRes),\n      value: moment(current).tz(timeZone).startOf(timeRes).format(),\n      label: moment(current).tz(timeZone).startOf(timeRes).format()\n    });\n    current.add(1, timeRes);\n  }\n}\n\n/*\n * @param {Partition} partition\n * @param {Group[]} groups\n * @memberof! Partition\n */\nfunction setDurationGroups (partition, groups) {\n  var dStart = partition.minval;\n  var dEnd = partition.maxval;\n  var dRes = util.getDurationResolution(dStart, dEnd);\n\n  var current = Math.floor(parseFloat(dStart.as(dRes)));\n  var last = Math.floor(parseFloat(dEnd.as(dRes)));\n\n  while (current < last) {\n    groups.add({\n      min: moment.duration(current, dRes),\n      max: moment.duration(current + 1, dRes),\n      value: moment.duration(current, dRes).toISOString(),\n      label: moment.duration(current, dRes).toISOString()\n    });\n\n    current = current + 1;\n  }\n}\n\n/*\n * Setup a grouping based on the `partition.groupingContinuous`, `partition.minval`,\n * `partition.maxval`, and the `partition.groupingParam`.\n * @memberof! Partition\n * @param {Partition} partition\n * @param {Group[]} groups\n */\nfunction setContinuousGroups (partition, groups) {\n  var param = partition.groupingParam;\n  var x0, x1, size, nbins;\n\n  if (partition.groupFixedN) {\n    // A fixed number of equally sized bins\n    nbins = param;\n    x0 = partition.minval;\n    x1 = partition.maxval;\n    size = (x1 - x0) / nbins;\n  } else if (partition.groupFixedS) {\n    // A fixed bin size\n    size = param;\n    x0 = Math.floor(partition.minval / size) * size;\n    x1 = Math.ceil(partition.maxval / size) * size;\n    nbins = (x1 - x0) / size;\n  } else if (partition.groupFixedSC) {\n    // A fixed bin size, centered on 0\n    size = param;\n    x0 = (Math.floor(partition.minval / size) - 0.5) * size;\n    x1 = (Math.ceil(partition.maxval / size) + 0.5) * size;\n    nbins = (x1 - x0) / size;\n  } else if (partition.groupLog) {\n    // Fixed number of logarithmically (base 10) sized bins\n    nbins = param;\n    x0 = Math.log(partition.minval) / Math.log(10.0);\n    x1 = Math.log(partition.maxval) / Math.log(10.0);\n    size = (x1 - x0) / nbins;\n  }\n\n  function unlog (x) {\n    return Math.exp(x * Math.log(10));\n  }\n\n  var i;\n  for (i = 0; i < nbins; i++) {\n    var start = x0 + i * size;\n    var end = x0 + (i + 1) * size;\n    var mid = 0.5 * (start + end);\n\n    if (partition.groupLog) {\n      groups.add({\n        min: unlog(start),\n        max: unlog(end),\n        value: unlog(start),\n        label: unlog(end).toPrecision(5)\n      });\n    } else {\n      groups.add({\n        min: start,\n        max: end,\n        value: mid,\n        label: mid.toPrecision(5)\n      });\n    }\n  }\n}\n\n/*\n * Setup a grouping based on the `partition.categorialTransform`\n * @memberof! Partition\n * @param {Partition} partition\n * @param {Group[]} groups\n */\nfunction setCategorialGroups (partition, groups) {\n  // dataview -> filters -> filter -> partitions -> partition\n  //          -> facets\n\n  var dataview;\n  var facet;\n  try {\n    dataview = partition.collection.parent.collection.parent;\n    facet = dataview.facets.get(partition.facetName, 'name');\n  } catch (e) {\n    console.error('setCategorialGroups: cannot locate facet for this partition');\n    return;\n  }\n\n  if (facet.isCategorial) {\n    // default: a categorial facet, with a categorial parittion\n    facet.categorialTransform.rules.forEach(function (rule, i) {\n      groups.add({\n        value: rule.group,\n        label: rule.group,\n        count: rule.count\n      });\n    });\n  } else if (facet.isDatetime) {\n    var format = facet.datetimeTransform.transformedFormat;\n    var timePart = util.timeParts.get(format, 'description');\n\n    timePart.groups.forEach(function (g, i) {\n      groups.add({\n        value: g,\n        label: g,\n        count: 0\n      });\n    });\n  } else {\n    console.warn('Not implemented');\n  }\n}\n\n/**\n * Reset type, minimum and maximum values\n * @params {Partition} partition\n * @params {Object} Options - silent do not trigger change events\n * @memberof! Partition\n */\nfunction reset (options) {\n  var partition = this;\n  // partition -> partitions -> filter -> filters -> dataview\n  var filter = partition.collection.parent;\n  var dataview = filter.collection.parent;\n  var facet = dataview.facets.get(partition.facetName, 'name');\n  options = options || {};\n\n  partition.set({\n    type: facet.transform.transformedType,\n    minval: facet.transform.transformedMin,\n    maxval: facet.transform.transformedMax\n  }, options);\n}\n\nmodule.exports = BaseModel.extend({\n  dataTypes: {\n    'numberDatetimeOrDuration': {\n      set: function (value) {\n        var newValue;\n\n        // check for momentjs objects\n        if (moment.isDuration(value)) {\n          return {\n            val: moment.duration(value),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (moment.isMoment(value)) {\n          return {\n            val: value.clone(),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to create momentjs objects\n        newValue = moment(value, moment.ISO_8601);\n        if (newValue.isValid()) {\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (typeof value === 'string' && value[0].toLowerCase() === 'p') {\n          newValue = moment.duration(value);\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to set a number\n        if (value === +value) {\n          return {\n            val: +value,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // failed..\n        return {\n          val: value,\n          type: typeof value\n        };\n      },\n      compare: function (currentVal, newVal) {\n        if (currentVal instanceof moment) {\n          return currentVal.isSame(newVal);\n        } else {\n          return +currentVal === +newVal;\n        }\n      }\n    }\n  },\n  props: {\n    /**\n     * Label for displaying on plots\n     * @memberof! Partition\n     * @type {string}\n     */\n    label: {\n      type: 'string',\n      required: true,\n      default: ''\n    },\n    /**\n     * Show a legend for this partition\n     * @memberof! Partition\n     * @type {string}\n     */\n    showLegend: {\n      type: 'boolean',\n      required: false,\n      default: true\n    },\n    /**\n     * Show an axis label for this partition\n     * @memberof! Partition\n     * @type {string}\n     */\n    showLabel: {\n      type: 'boolean',\n      required: false,\n      default: true\n    },\n\n    /**\n     * Timezone for partitioning\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    zone: {\n      type: 'string',\n      required: 'true',\n      default: function () {\n        return moment.tz.guess();\n      }\n    },\n\n    /**\n     * Type of this partition\n     * @memberof! Partition\n     * @type {string}\n     */\n    type: {\n      type: 'string',\n      required: true,\n      default: 'categorial',\n      values: ['constant', 'continuous', 'categorial', 'datetime', 'duration', 'text']\n    },\n\n    /**\n     * The name of the facet to partition over\n     * @memberof! Partition\n     * @type {string}\n     */\n    facetName: 'string',\n\n    /**\n     * When part of a partitioning, this deterimines the ordering\n     * @memberof! Partition\n     * @type {number}\n     */\n    rank: {\n      type: 'number',\n      required: true\n    },\n\n    /**\n     * For categorial and text Facets, the ordering can be alfabetical or by count\n     * @memberof! Partition\n     */\n    ordering: {\n      type: 'string',\n      values: ['count', 'value'],\n      required: true,\n      default: 'value'\n    },\n\n    /**\n     * For continuous or datetime Facets, the minimum value. Values lower than this are grouped to 'missing'\n     * @memberof! Partition\n     * @type {number|moment}\n     */\n    minval: 'numberDatetimeOrDuration',\n\n    /**\n     * For continuous or datetime Facets, the maximum value. Values higher than this are grouped to 'missing'\n     * @memberof! Partition\n     * @type {number|moment}\n     */\n    maxval: 'numberDatetimeOrDuration',\n\n    /**\n     * Extra parameter used in the grouping strategy: either the number of bins, or the bin size.\n     * @memberof! Partition\n     * @type {number}\n     */\n    groupingParam: ['number', true, 20],\n\n    /**\n     * Grouping strategy:\n     *  * `fixedn`  fixed number of bins in the interval [minval, maxval]\n     *  * `fixedsc` a fixed binsize, centered on zero\n     *  * `fixeds`  a fixed binsize, starting at zero\n     *  * `log`     fixed number of bins but on a logarithmic scale\n     * Don't use directly but check grouping via the groupFixedN, groupFixedSC,\n     * groupFixedS, and groupLog properties\n     * @memberof! Partition\n     * @type {number}\n     */\n    groupingContinuous: {\n      type: 'string',\n      required: true,\n      default: 'fixedn',\n      values: ['fixedn', 'fixedsc', 'fixeds', 'log']\n    },\n\n    /**\n     * Depending on the type of partition, this can be an array of the selected groups,\n     * or a numberic interval [start, end]\n     * @memberof! Partition\n     * @type {array}\n     */\n    // NOTE: for categorial facets, contains rule.group\n    selected: {\n      type: 'array',\n      required: true,\n      default: function () {\n        return [];\n      }\n    }\n  },\n  derived: {\n    // properties for: type\n    isConstant: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'constant';\n      }\n    },\n    isContinuous: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'continuous';\n      }\n    },\n    isCategorial: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'categorial';\n      }\n    },\n    isDatetime: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'datetime';\n      }\n    },\n    isDuration: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'duration';\n      }\n    },\n    isText: {\n      deps: ['type'],\n      fn: function () {\n        return this.type === 'text';\n      }\n    },\n    // properties for grouping-continuous\n    groupFixedN: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'fixedn';\n      }\n    },\n    groupFixedSC: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'fixedsc';\n      }\n    },\n    groupFixedS: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'fixeds';\n      }\n    },\n    groupLog: {\n      deps: ['groupingContinuous'],\n      fn: function () {\n        return this.groupingContinuous === 'log';\n      }\n    },\n    /**\n     * The (ordered) set of groups this Partition can take, making up this partition.\n     * The list is recalculated when any of the partition's properties change:\n     * 'groupingContinuous', 'groupingParam', 'minval', 'maxval', 'type', 'zone' change\n     * The list keeps itself sorted according to the partition.ordering\n     *\n     * Can be used for plotting etc.\n     * @memberof! Partition\n     * @type {Group[]}\n     */\n    groups: {\n      deps: ['groupingContinuous', 'groupingParam', 'minval', 'maxval', 'type', 'zone'],\n      fn: function () {\n        var partition = this;\n        var groups = new Groups([], {\n          parent: partition\n        });\n\n        if (partition.isCategorial) {\n          setCategorialGroups(partition, groups);\n        } else if (partition.isContinuous) {\n          setContinuousGroups(partition, groups);\n        } else if (partition.isDatetime) {\n          setDatetimeGroups(partition, groups);\n        } else if (partition.isDuration) {\n          setDurationGroups(partition, groups);\n        } else if (partition.isText) {\n          // no-op\n        } else {\n          console.error('Cannot set groups for partition', partition.getId());\n        }\n\n        return groups;\n      }\n    }\n  },\n  updateSelection: function (group) {\n    selection.updateSelection(this, group);\n  },\n  filterFunction: function () {\n    return selection.filterFunction(this);\n  },\n  reset: reset\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE5MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uLmpzPzUzODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJ0aXRpb25cbiAqXG4gKiBEZXNjcmliZXMgYSBwYXJ0aXRpb25pbmcgb2YgdGhlIGRhdGEsIGJhc2VkIG9uIHRoZSB2YWx1ZXMgYSBGYWNldCBjYW4gdGFrZS5cbiAqXG4gKiBAY2xhc3MgUGFydGl0aW9uXG4gKiBAZXh0ZW5kcyBCYXNlXG4gKi9cbnZhciBCYXNlTW9kZWwgPSByZXF1aXJlKCcuL3V0aWwvYmFzZScpO1xudmFyIEdyb3VwcyA9IHJlcXVpcmUoJy4vcGFydGl0aW9uL2dyb3VwLWNvbGxlY3Rpb24nKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCcuL3V0aWwvc2VsZWN0aW9uJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC90aW1lJyk7XG5cbi8qXG4gKiBAcGFyYW0ge1BhcnRpdGlvbn0gcGFydGl0aW9uXG4gKiBAcGFyYW0ge0dyb3VwW119IGdyb3Vwc1xuICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAqL1xuZnVuY3Rpb24gc2V0RGF0ZXRpbWVHcm91cHMgKHBhcnRpdGlvbiwgZ3JvdXBzKSB7XG4gIHZhciB0aW1lU3RhcnQgPSBwYXJ0aXRpb24ubWludmFsO1xuICB2YXIgdGltZUVuZCA9IHBhcnRpdGlvbi5tYXh2YWw7XG4gIHZhciB0aW1lUmVzID0gdXRpbC5nZXREYXRldGltZVJlc29sdXRpb24odGltZVN0YXJ0LCB0aW1lRW5kKTtcbiAgdmFyIHRpbWVab25lID0gcGFydGl0aW9uLnpvbmU7XG5cbiAgdmFyIGN1cnJlbnQgPSBtb21lbnQodGltZVN0YXJ0KTtcbiAgd2hpbGUgKCghY3VycmVudC5pc0FmdGVyKHRpbWVFbmQpKSAmJiBncm91cHMubGVuZ3RoIDwgNTAwKSB7XG4gICAgZ3JvdXBzLmFkZCh7XG4gICAgICBtaW46IG1vbWVudChjdXJyZW50KS50eih0aW1lWm9uZSkuc3RhcnRPZih0aW1lUmVzKSxcbiAgICAgIG1heDogbW9tZW50KGN1cnJlbnQpLnR6KHRpbWVab25lKS5lbmRPZih0aW1lUmVzKSxcbiAgICAgIHZhbHVlOiBtb21lbnQoY3VycmVudCkudHoodGltZVpvbmUpLnN0YXJ0T2YodGltZVJlcykuZm9ybWF0KCksXG4gICAgICBsYWJlbDogbW9tZW50KGN1cnJlbnQpLnR6KHRpbWVab25lKS5zdGFydE9mKHRpbWVSZXMpLmZvcm1hdCgpXG4gICAgfSk7XG4gICAgY3VycmVudC5hZGQoMSwgdGltZVJlcyk7XG4gIH1cbn1cblxuLypcbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7R3JvdXBbXX0gZ3JvdXBzXG4gKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICovXG5mdW5jdGlvbiBzZXREdXJhdGlvbkdyb3VwcyAocGFydGl0aW9uLCBncm91cHMpIHtcbiAgdmFyIGRTdGFydCA9IHBhcnRpdGlvbi5taW52YWw7XG4gIHZhciBkRW5kID0gcGFydGl0aW9uLm1heHZhbDtcbiAgdmFyIGRSZXMgPSB1dGlsLmdldER1cmF0aW9uUmVzb2x1dGlvbihkU3RhcnQsIGRFbmQpO1xuXG4gIHZhciBjdXJyZW50ID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KGRTdGFydC5hcyhkUmVzKSkpO1xuICB2YXIgbGFzdCA9IE1hdGguZmxvb3IocGFyc2VGbG9hdChkRW5kLmFzKGRSZXMpKSk7XG5cbiAgd2hpbGUgKGN1cnJlbnQgPCBsYXN0KSB7XG4gICAgZ3JvdXBzLmFkZCh7XG4gICAgICBtaW46IG1vbWVudC5kdXJhdGlvbihjdXJyZW50LCBkUmVzKSxcbiAgICAgIG1heDogbW9tZW50LmR1cmF0aW9uKGN1cnJlbnQgKyAxLCBkUmVzKSxcbiAgICAgIHZhbHVlOiBtb21lbnQuZHVyYXRpb24oY3VycmVudCwgZFJlcykudG9JU09TdHJpbmcoKSxcbiAgICAgIGxhYmVsOiBtb21lbnQuZHVyYXRpb24oY3VycmVudCwgZFJlcykudG9JU09TdHJpbmcoKVxuICAgIH0pO1xuXG4gICAgY3VycmVudCA9IGN1cnJlbnQgKyAxO1xuICB9XG59XG5cbi8qXG4gKiBTZXR1cCBhIGdyb3VwaW5nIGJhc2VkIG9uIHRoZSBgcGFydGl0aW9uLmdyb3VwaW5nQ29udGludW91c2AsIGBwYXJ0aXRpb24ubWludmFsYCxcbiAqIGBwYXJ0aXRpb24ubWF4dmFsYCwgYW5kIHRoZSBgcGFydGl0aW9uLmdyb3VwaW5nUGFyYW1gLlxuICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7R3JvdXBbXX0gZ3JvdXBzXG4gKi9cbmZ1bmN0aW9uIHNldENvbnRpbnVvdXNHcm91cHMgKHBhcnRpdGlvbiwgZ3JvdXBzKSB7XG4gIHZhciBwYXJhbSA9IHBhcnRpdGlvbi5ncm91cGluZ1BhcmFtO1xuICB2YXIgeDAsIHgxLCBzaXplLCBuYmlucztcblxuICBpZiAocGFydGl0aW9uLmdyb3VwRml4ZWROKSB7XG4gICAgLy8gQSBmaXhlZCBudW1iZXIgb2YgZXF1YWxseSBzaXplZCBiaW5zXG4gICAgbmJpbnMgPSBwYXJhbTtcbiAgICB4MCA9IHBhcnRpdGlvbi5taW52YWw7XG4gICAgeDEgPSBwYXJ0aXRpb24ubWF4dmFsO1xuICAgIHNpemUgPSAoeDEgLSB4MCkgLyBuYmlucztcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uZ3JvdXBGaXhlZFMpIHtcbiAgICAvLyBBIGZpeGVkIGJpbiBzaXplXG4gICAgc2l6ZSA9IHBhcmFtO1xuICAgIHgwID0gTWF0aC5mbG9vcihwYXJ0aXRpb24ubWludmFsIC8gc2l6ZSkgKiBzaXplO1xuICAgIHgxID0gTWF0aC5jZWlsKHBhcnRpdGlvbi5tYXh2YWwgLyBzaXplKSAqIHNpemU7XG4gICAgbmJpbnMgPSAoeDEgLSB4MCkgLyBzaXplO1xuICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5ncm91cEZpeGVkU0MpIHtcbiAgICAvLyBBIGZpeGVkIGJpbiBzaXplLCBjZW50ZXJlZCBvbiAwXG4gICAgc2l6ZSA9IHBhcmFtO1xuICAgIHgwID0gKE1hdGguZmxvb3IocGFydGl0aW9uLm1pbnZhbCAvIHNpemUpIC0gMC41KSAqIHNpemU7XG4gICAgeDEgPSAoTWF0aC5jZWlsKHBhcnRpdGlvbi5tYXh2YWwgLyBzaXplKSArIDAuNSkgKiBzaXplO1xuICAgIG5iaW5zID0gKHgxIC0geDApIC8gc2l6ZTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uZ3JvdXBMb2cpIHtcbiAgICAvLyBGaXhlZCBudW1iZXIgb2YgbG9nYXJpdGhtaWNhbGx5IChiYXNlIDEwKSBzaXplZCBiaW5zXG4gICAgbmJpbnMgPSBwYXJhbTtcbiAgICB4MCA9IE1hdGgubG9nKHBhcnRpdGlvbi5taW52YWwpIC8gTWF0aC5sb2coMTAuMCk7XG4gICAgeDEgPSBNYXRoLmxvZyhwYXJ0aXRpb24ubWF4dmFsKSAvIE1hdGgubG9nKDEwLjApO1xuICAgIHNpemUgPSAoeDEgLSB4MCkgLyBuYmlucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubG9nICh4KSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKHggKiBNYXRoLmxvZygxMCkpO1xuICB9XG5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBuYmluczsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0ID0geDAgKyBpICogc2l6ZTtcbiAgICB2YXIgZW5kID0geDAgKyAoaSArIDEpICogc2l6ZTtcbiAgICB2YXIgbWlkID0gMC41ICogKHN0YXJ0ICsgZW5kKTtcblxuICAgIGlmIChwYXJ0aXRpb24uZ3JvdXBMb2cpIHtcbiAgICAgIGdyb3Vwcy5hZGQoe1xuICAgICAgICBtaW46IHVubG9nKHN0YXJ0KSxcbiAgICAgICAgbWF4OiB1bmxvZyhlbmQpLFxuICAgICAgICB2YWx1ZTogdW5sb2coc3RhcnQpLFxuICAgICAgICBsYWJlbDogdW5sb2coZW5kKS50b1ByZWNpc2lvbig1KVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwcy5hZGQoe1xuICAgICAgICBtaW46IHN0YXJ0LFxuICAgICAgICBtYXg6IGVuZCxcbiAgICAgICAgdmFsdWU6IG1pZCxcbiAgICAgICAgbGFiZWw6IG1pZC50b1ByZWNpc2lvbig1KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qXG4gKiBTZXR1cCBhIGdyb3VwaW5nIGJhc2VkIG9uIHRoZSBgcGFydGl0aW9uLmNhdGVnb3JpYWxUcmFuc2Zvcm1gXG4gKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICogQHBhcmFtIHtQYXJ0aXRpb259IHBhcnRpdGlvblxuICogQHBhcmFtIHtHcm91cFtdfSBncm91cHNcbiAqL1xuZnVuY3Rpb24gc2V0Q2F0ZWdvcmlhbEdyb3VwcyAocGFydGl0aW9uLCBncm91cHMpIHtcbiAgLy8gZGF0YXZpZXcgLT4gZmlsdGVycyAtPiBmaWx0ZXIgLT4gcGFydGl0aW9ucyAtPiBwYXJ0aXRpb25cbiAgLy8gICAgICAgICAgLT4gZmFjZXRzXG5cbiAgdmFyIGRhdGF2aWV3O1xuICB2YXIgZmFjZXQ7XG4gIHRyeSB7XG4gICAgZGF0YXZpZXcgPSBwYXJ0aXRpb24uY29sbGVjdGlvbi5wYXJlbnQuY29sbGVjdGlvbi5wYXJlbnQ7XG4gICAgZmFjZXQgPSBkYXRhdmlldy5mYWNldHMuZ2V0KHBhcnRpdGlvbi5mYWNldE5hbWUsICduYW1lJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdzZXRDYXRlZ29yaWFsR3JvdXBzOiBjYW5ub3QgbG9jYXRlIGZhY2V0IGZvciB0aGlzIHBhcnRpdGlvbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmYWNldC5pc0NhdGVnb3JpYWwpIHtcbiAgICAvLyBkZWZhdWx0OiBhIGNhdGVnb3JpYWwgZmFjZXQsIHdpdGggYSBjYXRlZ29yaWFsIHBhcml0dGlvblxuICAgIGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0ucnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSwgaSkge1xuICAgICAgZ3JvdXBzLmFkZCh7XG4gICAgICAgIHZhbHVlOiBydWxlLmdyb3VwLFxuICAgICAgICBsYWJlbDogcnVsZS5ncm91cCxcbiAgICAgICAgY291bnQ6IHJ1bGUuY291bnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZhY2V0LmlzRGF0ZXRpbWUpIHtcbiAgICB2YXIgZm9ybWF0ID0gZmFjZXQuZGF0ZXRpbWVUcmFuc2Zvcm0udHJhbnNmb3JtZWRGb3JtYXQ7XG4gICAgdmFyIHRpbWVQYXJ0ID0gdXRpbC50aW1lUGFydHMuZ2V0KGZvcm1hdCwgJ2Rlc2NyaXB0aW9uJyk7XG5cbiAgICB0aW1lUGFydC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZywgaSkge1xuICAgICAgZ3JvdXBzLmFkZCh7XG4gICAgICAgIHZhbHVlOiBnLFxuICAgICAgICBsYWJlbDogZyxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldCB0eXBlLCBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlc1xuICogQHBhcmFtcyB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEBwYXJhbXMge09iamVjdH0gT3B0aW9ucyAtIHNpbGVudCBkbyBub3QgdHJpZ2dlciBjaGFuZ2UgZXZlbnRzXG4gKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICovXG5mdW5jdGlvbiByZXNldCAob3B0aW9ucykge1xuICB2YXIgcGFydGl0aW9uID0gdGhpcztcbiAgLy8gcGFydGl0aW9uIC0+IHBhcnRpdGlvbnMgLT4gZmlsdGVyIC0+IGZpbHRlcnMgLT4gZGF0YXZpZXdcbiAgdmFyIGZpbHRlciA9IHBhcnRpdGlvbi5jb2xsZWN0aW9uLnBhcmVudDtcbiAgdmFyIGRhdGF2aWV3ID0gZmlsdGVyLmNvbGxlY3Rpb24ucGFyZW50O1xuICB2YXIgZmFjZXQgPSBkYXRhdmlldy5mYWNldHMuZ2V0KHBhcnRpdGlvbi5mYWNldE5hbWUsICduYW1lJyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHBhcnRpdGlvbi5zZXQoe1xuICAgIHR5cGU6IGZhY2V0LnRyYW5zZm9ybS50cmFuc2Zvcm1lZFR5cGUsXG4gICAgbWludmFsOiBmYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNaW4sXG4gICAgbWF4dmFsOiBmYWNldC50cmFuc2Zvcm0udHJhbnNmb3JtZWRNYXhcbiAgfSwgb3B0aW9ucyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIGRhdGFUeXBlczoge1xuICAgICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nOiB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1vbWVudGpzIG9iamVjdHNcbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG1vbWVudC5kdXJhdGlvbih2YWx1ZSksXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsOiB2YWx1ZS5jbG9uZSgpLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBtb21lbnRqcyBvYmplY3RzXG4gICAgICAgIG5ld1ZhbHVlID0gbW9tZW50KHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpO1xuICAgICAgICBpZiAobmV3VmFsdWUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogbmV3VmFsdWUsXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBtb21lbnQuZHVyYXRpb24odmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHNldCBhIG51bWJlclxuICAgICAgICBpZiAodmFsdWUgPT09ICt2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6ICt2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWxlZC4uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlOiB0eXBlb2YgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsIGluc3RhbmNlb2YgbW9tZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWwuaXNTYW1lKG5ld1ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICtjdXJyZW50VmFsID09PSArbmV3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIExhYmVsIGZvciBkaXNwbGF5aW5nIG9uIHBsb3RzXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxhYmVsOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3cgYSBsZWdlbmQgZm9yIHRoaXMgcGFydGl0aW9uXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNob3dMZWdlbmQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3cgYW4gYXhpcyBsYWJlbCBmb3IgdGhpcyBwYXJ0aXRpb25cbiAgICAgKiBAbWVtYmVyb2YhIFBhcnRpdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2hvd0xhYmVsOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGZvciBwYXJ0aXRpb25pbmdcbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6b25lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiAndHJ1ZScsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQudHouZ3Vlc3MoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGlzIHBhcnRpdGlvblxuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ2NhdGVnb3JpYWwnLFxuICAgICAgdmFsdWVzOiBbJ2NvbnN0YW50JywgJ2NvbnRpbnVvdXMnLCAnY2F0ZWdvcmlhbCcsICdkYXRldGltZScsICdkdXJhdGlvbicsICd0ZXh0J11cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZhY2V0IHRvIHBhcnRpdGlvbiBvdmVyXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZhY2V0TmFtZTogJ3N0cmluZycsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHBhcnQgb2YgYSBwYXJ0aXRpb25pbmcsIHRoaXMgZGV0ZXJpbWluZXMgdGhlIG9yZGVyaW5nXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJhbms6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNhdGVnb3JpYWwgYW5kIHRleHQgRmFjZXRzLCB0aGUgb3JkZXJpbmcgY2FuIGJlIGFsZmFiZXRpY2FsIG9yIGJ5IGNvdW50XG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKi9cbiAgICBvcmRlcmluZzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICB2YWx1ZXM6IFsnY291bnQnLCAndmFsdWUnXSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ3ZhbHVlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgY29udGludW91cyBvciBkYXRldGltZSBGYWNldHMsIHRoZSBtaW5pbXVtIHZhbHVlLiBWYWx1ZXMgbG93ZXIgdGhhbiB0aGlzIGFyZSBncm91cGVkIHRvICdtaXNzaW5nJ1xuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge251bWJlcnxtb21lbnR9XG4gICAgICovXG4gICAgbWludmFsOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIG9yIGRhdGV0aW1lIEZhY2V0cywgdGhlIG1heGltdW0gdmFsdWUuIFZhbHVlcyBoaWdoZXIgdGhhbiB0aGlzIGFyZSBncm91cGVkIHRvICdtaXNzaW5nJ1xuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge251bWJlcnxtb21lbnR9XG4gICAgICovXG4gICAgbWF4dmFsOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhIHBhcmFtZXRlciB1c2VkIGluIHRoZSBncm91cGluZyBzdHJhdGVneTogZWl0aGVyIHRoZSBudW1iZXIgb2YgYmlucywgb3IgdGhlIGJpbiBzaXplLlxuICAgICAqIEBtZW1iZXJvZiEgUGFydGl0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBncm91cGluZ1BhcmFtOiBbJ251bWJlcicsIHRydWUsIDIwXSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwaW5nIHN0cmF0ZWd5OlxuICAgICAqICAqIGBmaXhlZG5gICBmaXhlZCBudW1iZXIgb2YgYmlucyBpbiB0aGUgaW50ZXJ2YWwgW21pbnZhbCwgbWF4dmFsXVxuICAgICAqICAqIGBmaXhlZHNjYCBhIGZpeGVkIGJpbnNpemUsIGNlbnRlcmVkIG9uIHplcm9cbiAgICAgKiAgKiBgZml4ZWRzYCAgYSBmaXhlZCBiaW5zaXplLCBzdGFydGluZyBhdCB6ZXJvXG4gICAgICogICogYGxvZ2AgICAgIGZpeGVkIG51bWJlciBvZiBiaW5zIGJ1dCBvbiBhIGxvZ2FyaXRobWljIHNjYWxlXG4gICAgICogRG9uJ3QgdXNlIGRpcmVjdGx5IGJ1dCBjaGVjayBncm91cGluZyB2aWEgdGhlIGdyb3VwRml4ZWROLCBncm91cEZpeGVkU0MsXG4gICAgICogZ3JvdXBGaXhlZFMsIGFuZCBncm91cExvZyBwcm9wZXJ0aWVzXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdyb3VwaW5nQ29udGludW91czoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICdmaXhlZG4nLFxuICAgICAgdmFsdWVzOiBbJ2ZpeGVkbicsICdmaXhlZHNjJywgJ2ZpeGVkcycsICdsb2cnXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgcGFydGl0aW9uLCB0aGlzIGNhbiBiZSBhbiBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgZ3JvdXBzLFxuICAgICAqIG9yIGEgbnVtYmVyaWMgaW50ZXJ2YWwgW3N0YXJ0LCBlbmRdXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICovXG4gICAgLy8gTk9URTogZm9yIGNhdGVnb3JpYWwgZmFjZXRzLCBjb250YWlucyBydWxlLmdyb3VwXG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVyaXZlZDoge1xuICAgIC8vIHByb3BlcnRpZXMgZm9yOiB0eXBlXG4gICAgaXNDb25zdGFudDoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnY29uc3RhbnQnO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNDb250aW51b3VzOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdjb250aW51b3VzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQ2F0ZWdvcmlhbDoge1xuICAgICAgZGVwczogWyd0eXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnY2F0ZWdvcmlhbCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0RhdGV0aW1lOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdkYXRldGltZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0R1cmF0aW9uOiB7XG4gICAgICBkZXBzOiBbJ3R5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdkdXJhdGlvbic7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1RleHQ6IHtcbiAgICAgIGRlcHM6IFsndHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3RleHQnO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gcHJvcGVydGllcyBmb3IgZ3JvdXBpbmctY29udGludW91c1xuICAgIGdyb3VwRml4ZWROOiB7XG4gICAgICBkZXBzOiBbJ2dyb3VwaW5nQ29udGludW91cyddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBpbmdDb250aW51b3VzID09PSAnZml4ZWRuJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGdyb3VwRml4ZWRTQzoge1xuICAgICAgZGVwczogWydncm91cGluZ0NvbnRpbnVvdXMnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwaW5nQ29udGludW91cyA9PT0gJ2ZpeGVkc2MnO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ3JvdXBGaXhlZFM6IHtcbiAgICAgIGRlcHM6IFsnZ3JvdXBpbmdDb250aW51b3VzJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cGluZ0NvbnRpbnVvdXMgPT09ICdmaXhlZHMnO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ3JvdXBMb2c6IHtcbiAgICAgIGRlcHM6IFsnZ3JvdXBpbmdDb250aW51b3VzJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cGluZ0NvbnRpbnVvdXMgPT09ICdsb2cnO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChvcmRlcmVkKSBzZXQgb2YgZ3JvdXBzIHRoaXMgUGFydGl0aW9uIGNhbiB0YWtlLCBtYWtpbmcgdXAgdGhpcyBwYXJ0aXRpb24uXG4gICAgICogVGhlIGxpc3QgaXMgcmVjYWxjdWxhdGVkIHdoZW4gYW55IG9mIHRoZSBwYXJ0aXRpb24ncyBwcm9wZXJ0aWVzIGNoYW5nZTpcbiAgICAgKiAnZ3JvdXBpbmdDb250aW51b3VzJywgJ2dyb3VwaW5nUGFyYW0nLCAnbWludmFsJywgJ21heHZhbCcsICd0eXBlJywgJ3pvbmUnIGNoYW5nZVxuICAgICAqIFRoZSBsaXN0IGtlZXBzIGl0c2VsZiBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwYXJ0aXRpb24ub3JkZXJpbmdcbiAgICAgKlxuICAgICAqIENhbiBiZSB1c2VkIGZvciBwbG90dGluZyBldGMuXG4gICAgICogQG1lbWJlcm9mISBQYXJ0aXRpb25cbiAgICAgKiBAdHlwZSB7R3JvdXBbXX1cbiAgICAgKi9cbiAgICBncm91cHM6IHtcbiAgICAgIGRlcHM6IFsnZ3JvdXBpbmdDb250aW51b3VzJywgJ2dyb3VwaW5nUGFyYW0nLCAnbWludmFsJywgJ21heHZhbCcsICd0eXBlJywgJ3pvbmUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJ0aXRpb24gPSB0aGlzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gbmV3IEdyb3VwcyhbXSwge1xuICAgICAgICAgIHBhcmVudDogcGFydGl0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXJ0aXRpb24uaXNDYXRlZ29yaWFsKSB7XG4gICAgICAgICAgc2V0Q2F0ZWdvcmlhbEdyb3VwcyhwYXJ0aXRpb24sIGdyb3Vwcyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzQ29udGludW91cykge1xuICAgICAgICAgIHNldENvbnRpbnVvdXNHcm91cHMocGFydGl0aW9uLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc0RhdGV0aW1lKSB7XG4gICAgICAgICAgc2V0RGF0ZXRpbWVHcm91cHMocGFydGl0aW9uLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc0R1cmF0aW9uKSB7XG4gICAgICAgICAgc2V0RHVyYXRpb25Hcm91cHMocGFydGl0aW9uLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc1RleHQpIHtcbiAgICAgICAgICAvLyBuby1vcFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBzZXQgZ3JvdXBzIGZvciBwYXJ0aXRpb24nLCBwYXJ0aXRpb24uZ2V0SWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICBzZWxlY3Rpb24udXBkYXRlU2VsZWN0aW9uKHRoaXMsIGdyb3VwKTtcbiAgfSxcbiAgZmlsdGVyRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uLmZpbHRlckZ1bmN0aW9uKHRoaXMpO1xuICB9LFxuICByZXNldDogcmVzZXRcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8191\n")},8233:function(module,exports,__webpack_require__){eval("\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"bb16\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIzMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvYnJvd3Nlci5qcz80ZDVhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8233\n")},"834b":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "86e3");\nvar XHR = __webpack_require__(/*! ./polling-xhr */ "108d");\nvar JSONP = __webpack_require__(/*! ./polling-jsonp */ "2dce");\nvar websocket = __webpack_require__(/*! ./websocket */ "6b20");\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = \'https:\' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname !== location.hostname || port !== opts.port;\n    xs = opts.secure !== isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if (\'open\' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error(\'JSONP disabled\');\n    return new JSONP(opts);\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "698d")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM0Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcz84OTk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFhIUiA9IHJlcXVpcmUoJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IHJlcXVpcmUoJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyAob3B0cykge1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9PSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///834b\n')},"86e3":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module\n\nvar hasCORS = __webpack_require__(/*! has-cors */ \"0392\");\n\nmodule.exports = function (opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');\n    } catch (e) { }\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODZlMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanM/NzY2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///86e3\n")},9083:function(module,exports,__webpack_require__){eval("/**\n * A `Group` represents a value a `Facet` can take using a partitioning.\n * For continuous or time facets, it represents an interval.\n * For categorial facets, it is a single label.\n *\n * The `Facet.groups` collection is used for plotting, to deterime the postion along the axis.\n * Selections can be updated using a `Group`.\n *\n * @extends Base\n * @class Group\n */\nvar Base = __webpack_require__(/*! ../util/base */ \"3902\");\nvar moment = __webpack_require__(/*! moment */ \"da01\");\n\nmodule.exports = Base.extend({\n  dataTypes: {\n    'numberDatetimeOrDuration': {\n      set: function (value) {\n        var newValue;\n\n        // check for momentjs objects\n        if (moment.isDuration(value)) {\n          return {\n            val: moment.duration(value),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (moment.isMoment(value)) {\n          return {\n            val: moment(value),\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to create momentjs objects\n        newValue = moment(value, moment.ISO_8601);\n        if (newValue.isValid()) {\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n        if (typeof value === 'string' && value[0].toLowerCase() === 'p') {\n          newValue = moment.duration(value);\n          return {\n            val: newValue,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // try to set a number\n        if (value === +value) {\n          return {\n            val: +value,\n            type: 'numberDatetimeOrDuration'\n          };\n        }\n\n        // failed..\n        return {\n          val: value,\n          type: typeof value\n        };\n      },\n      compare: function (currentVal, newVal) {\n        if (currentVal instanceof moment) {\n          return currentVal.isSame(newVal);\n        } else {\n          return +currentVal === +newVal;\n        }\n      }\n    }\n  },\n  props: {\n    /**\n     * For continuous, datetime, or duration facets. Lower limit of interval\n     * @type {number|moment}\n     * @memberof! Group\n     */\n    min: 'numberDatetimeOrDuration',\n\n    /**\n     * For continuous, datetime, or duration facets. Upper limit of interval\n     * @type {number|moment}\n     * @memberof! Group\n     */\n    max: 'numberDatetimeOrDuration',\n\n    /**\n     * Number of times this transform is used\n     * @type {number}\n     * @memberof! Group\n     */\n    count: ['number', true, 0],\n\n    /**\n     * Label for display\n     * @type {string}\n     * @memberof! Group\n     */\n    label: ['string', true, 'label'],\n\n    /**\n     * A value guaranteed to be in this group, used to check if this group is currently selected.\n     * moments and durations should be stored as moment.format() and duration.toISOString()\n     * @type {string|number}\n     * @memberof! Group\n     */\n    value: 'any',\n\n    /**\n     * Index, cached version of groups.models.indexOf(group)\n     * @type {number}\n     * @memberof! Group\n     */\n    groupIndex: 'number'\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA4My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uL2dyb3VwLmpzPzEwNGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBHcm91cGAgcmVwcmVzZW50cyBhIHZhbHVlIGEgYEZhY2V0YCBjYW4gdGFrZSB1c2luZyBhIHBhcnRpdGlvbmluZy5cbiAqIEZvciBjb250aW51b3VzIG9yIHRpbWUgZmFjZXRzLCBpdCByZXByZXNlbnRzIGFuIGludGVydmFsLlxuICogRm9yIGNhdGVnb3JpYWwgZmFjZXRzLCBpdCBpcyBhIHNpbmdsZSBsYWJlbC5cbiAqXG4gKiBUaGUgYEZhY2V0Lmdyb3Vwc2AgY29sbGVjdGlvbiBpcyB1c2VkIGZvciBwbG90dGluZywgdG8gZGV0ZXJpbWUgdGhlIHBvc3Rpb24gYWxvbmcgdGhlIGF4aXMuXG4gKiBTZWxlY3Rpb25zIGNhbiBiZSB1cGRhdGVkIHVzaW5nIGEgYEdyb3VwYC5cbiAqXG4gKiBAZXh0ZW5kcyBCYXNlXG4gKiBAY2xhc3MgR3JvdXBcbiAqL1xudmFyIEJhc2UgPSByZXF1aXJlKCcuLi91dGlsL2Jhc2UnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG4gIGRhdGFUeXBlczoge1xuICAgICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nOiB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1vbWVudGpzIG9iamVjdHNcbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG1vbWVudC5kdXJhdGlvbih2YWx1ZSksXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsOiBtb21lbnQodmFsdWUpLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBtb21lbnRqcyBvYmplY3RzXG4gICAgICAgIG5ld1ZhbHVlID0gbW9tZW50KHZhbHVlLCBtb21lbnQuSVNPXzg2MDEpO1xuICAgICAgICBpZiAobmV3VmFsdWUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogbmV3VmFsdWUsXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyRGF0ZXRpbWVPckR1cmF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBtb21lbnQuZHVyYXRpb24odmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgdHlwZTogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHNldCBhIG51bWJlclxuICAgICAgICBpZiAodmFsdWUgPT09ICt2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWw6ICt2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWxlZC4uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlOiB0eXBlb2YgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoY3VycmVudFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsIGluc3RhbmNlb2YgbW9tZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWwuaXNTYW1lKG5ld1ZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICtjdXJyZW50VmFsID09PSArbmV3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzLCBkYXRldGltZSwgb3IgZHVyYXRpb24gZmFjZXRzLiBMb3dlciBsaW1pdCBvZiBpbnRlcnZhbFxuICAgICAqIEB0eXBlIHtudW1iZXJ8bW9tZW50fVxuICAgICAqIEBtZW1iZXJvZiEgR3JvdXBcbiAgICAgKi9cbiAgICBtaW46ICdudW1iZXJEYXRldGltZU9yRHVyYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbnRpbnVvdXMsIGRhdGV0aW1lLCBvciBkdXJhdGlvbiBmYWNldHMuIFVwcGVyIGxpbWl0IG9mIGludGVydmFsXG4gICAgICogQHR5cGUge251bWJlcnxtb21lbnR9XG4gICAgICogQG1lbWJlcm9mISBHcm91cFxuICAgICAqL1xuICAgIG1heDogJ251bWJlckRhdGV0aW1lT3JEdXJhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdGltZXMgdGhpcyB0cmFuc2Zvcm0gaXMgdXNlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBHcm91cFxuICAgICAqL1xuICAgIGNvdW50OiBbJ251bWJlcicsIHRydWUsIDBdLFxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgZm9yIGRpc3BsYXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiEgR3JvdXBcbiAgICAgKi9cbiAgICBsYWJlbDogWydzdHJpbmcnLCB0cnVlLCAnbGFiZWwnXSxcblxuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgZ3VhcmFudGVlZCB0byBiZSBpbiB0aGlzIGdyb3VwLCB1c2VkIHRvIGNoZWNrIGlmIHRoaXMgZ3JvdXAgaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqIG1vbWVudHMgYW5kIGR1cmF0aW9ucyBzaG91bGQgYmUgc3RvcmVkIGFzIG1vbWVudC5mb3JtYXQoKSBhbmQgZHVyYXRpb24udG9JU09TdHJpbmcoKVxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgR3JvdXBcbiAgICAgKi9cbiAgICB2YWx1ZTogJ2FueScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCwgY2FjaGVkIHZlcnNpb24gb2YgZ3JvdXBzLm1vZGVscy5pbmRleE9mKGdyb3VwKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBHcm91cFxuICAgICAqL1xuICAgIGdyb3VwSW5kZXg6ICdudW1iZXInXG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9083\n")},9263:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./src/crossfilter */ "4573").crossfilter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI2My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL2luZGV4LmpzP2U3MTEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvY3Jvc3NmaWx0ZXJcIikuY3Jvc3NmaWx0ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9263\n')},"939f":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var a = new Blob(['hi']);\n    return a.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if Blob constructor supports ArrayBufferViews\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\n */\n\nvar blobSupportsArrayBufferView = blobSupported && (function() {\n  try {\n    var b = new Blob([new Uint8Array([1,2])]);\n    return b.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\n/**\n * Helper function that maps ArrayBufferViews to ArrayBuffers\n * Used by BlobBuilder constructor and old browsers that didn't\n * support it in the Blob constructor.\n */\n\nfunction mapArrayBufferViews(ary) {\n  for (var i = 0; i < ary.length; i++) {\n    var chunk = ary[i];\n    if (chunk.buffer instanceof ArrayBuffer) {\n      var buf = chunk.buffer;\n\n      // if this is a subarray, make a copy so we only\n      // include the subarray region from the underlying buffer\n      if (chunk.byteLength !== buf.byteLength) {\n        var copy = new Uint8Array(chunk.byteLength);\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n        buf = copy.buffer;\n      }\n\n      ary[i] = buf;\n    }\n  }\n}\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  mapArrayBufferViews(ary);\n\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nfunction BlobConstructor(ary, options) {\n  mapArrayBufferViews(ary);\n  return new Blob(ary, options || {});\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM5Zi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcz8yMTA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///939f\n")},9476:function(module,exports,__webpack_require__){eval("/**\n * A filter provides a chart with an interface to the data.\n * The filter contains a number of `Partition`s and `Aggregate`s.\n * It takes care of calling the relevant functions provided by a `Dataset`.\n *\n * @class Filter\n * @extends Base\n */\n\n/**\n * @typedef {Object} DataRecord - Object holding the plot data, partitions are labelled with a single small letter, aggregates with a double small letter\n * @property {string} DataRecord.a Value of first partition\n * @property {string} DataRecord.b Value of second partition\n * @property {string} DataRecord.c Value of third partition, etc.\n * @property {string} DataRecord.aa Value of first aggregate\n * @property {string} DataRecord.bb Value of second aggregate, etc.\n */\n\n/**\n * @typedef {DataRecord[]} Data - Array of DataRecords\n */\n\nvar Base = __webpack_require__(/*! ./util/base */ \"3902\");\nvar Aggregates = __webpack_require__(/*! ./aggregate/collection */ \"fbef\");\nvar Partitions = __webpack_require__(/*! ./partition/collection */ \"e59a\");\n\nmodule.exports = Base.extend({\n  props: {\n    /**\n     * Hint for the client (website) how to visualize this filter\n     * @memberof! Filter\n     * @type {string}\n     */\n    chartType: {\n      type: 'string',\n      required: true,\n      default: 'barchart',\n      values: ['piechart', 'horizontalbarchart', 'barchart', 'linechart', 'radarchart', 'polarareachart', 'bubbleplot', 'scatterchart', 'networkchart']\n    },\n    /**\n     * Title for displaying purposes\n     * @memberof! Filter\n     * @type {string}\n     */\n    title: ['string', true, ''],\n    /**\n     * Hint for the client (website) how to position the chart for this filter\n     * position (col, row) and size (size_x, size_y) of chart\n     */\n    col: 'number',\n    row: 'number',\n    size_x: 'number',\n    size_y: 'number'\n  },\n  collections: {\n    /**\n     * @memberof! Filter\n     * @type {Partitions[]}\n     */\n    partitions: Partitions,\n    /**\n     * @memberof! Filter\n     * @type {Aggregate[]}\n     */\n    aggregates: Aggregates\n  },\n  // Session properties are not typically persisted to the server,\n  // and are not returned by calls to toJSON() or serialize().\n  session: {\n    /**\n     * Array containing the data to plot\n     * @memberof! Filter\n     * @type {Data}\n     */\n    data: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    },\n    /*\n     * Call this function to request new data.\n     * The dataset backing the facet will copy the data to Filter.data.\n     * A newData event is fired when the data is ready to be plotted.\n     *\n     * @function\n     * @virtual\n     * @private\n     * @memberof! Filter\n     * @emits newData\n     */\n    getData: {\n      type: 'any'\n    },\n    /**\n     * A history of the current drill-down (ie. partitions.toJSON())\n     */\n    zoomHistory: {\n      type: 'array',\n      default: function () {\n        return [];\n      }\n    },\n    /**\n     * Boolean indicating if the filter is initialized\n     */\n    isInitialized: {\n      type: 'boolean',\n      required: true,\n      default: false\n    }\n  },\n  initialize: function () {\n    // set up callback to free internal state on remove\n    this.on('remove', function () {\n      this.releaseDataFilter();\n    });\n  },\n  zoomIn: function () {\n    this.releaseDataFilter();\n\n    // save current state\n    this.zoomHistory.push(JSON.stringify(this.partitions.toJSON()));\n\n    this.partitions.forEach(function (partition) {\n      if ((partition.selected.length === 2) && (partition.isDatetime || partition.isContinuous)) {\n        if (partition.groupFixedS || partition.groupFixedSC) {\n          // scale down binsize\n          var newSize = partition.selected[1] - partition.selected[0];\n          var oldSize = partition.maxval - partition.minval;\n          partition.groupingParam = partition.groupingParam * newSize / oldSize;\n        }\n        // zoom to selected range, if possible\n        partition.set({\n          minval: partition.selected[0],\n          maxval: partition.selected[1]\n        });\n      } else if (partition.selected.length > 0 && (partition.isCategorial)) {\n        // zoom to selected categories, if possible\n        partition.groups.reset();\n        partition.selected.forEach(function (value) {\n          partition.groups.add({\n            value: value,\n            label: value,\n            count: 0,\n            isSelected: true\n          });\n        });\n      }\n      // select all\n      partition.updateSelection();\n    });\n    this.initDataFilter();\n    this.updateDataFilter(); // also triggers a getAllData()\n  },\n  zoomOut: function () {\n    var doReset = true;\n\n    // clear current selection\n    this.partitions.forEach(function (partition) {\n      if (partition.selected.length > 0) {\n        partition.updateSelection();\n        doReset = false;\n      }\n    });\n\n    if (doReset) {\n      this.releaseDataFilter();\n      if (this.zoomHistory.length > 0) {\n        // nothing was selected and we have drilled down: go up\n        var state = JSON.parse(this.zoomHistory.pop());\n        this.partitions.reset(state);\n      } else {\n        // nothing was selected and no drill down: reset partitioning\n        this.partitions.forEach(function (partition) {\n          if (partition.isDatetime || partition.isContinuous) {\n            partition.reset();\n          }\n        });\n      }\n      this.initDataFilter();\n    }\n    this.updateDataFilter(); // also triggers a getAllData()\n  },\n  // Apply the separate filterFunctions from each partition in a single function\n  filterFunction: function () {\n    var fs = [];\n    this.partitions.forEach(function (partition) {\n      fs.push(partition.filterFunction());\n    });\n    return function (d) {\n      if (typeof d === 'string') {\n        var groups = d.split('|');\n        return fs.every(function (f, i) { return f(groups[i]); });\n      } else {\n        // shortcut for non-partitioned numeric data\n        return fs[0](d);\n      }\n    };\n  },\n  /**\n   * Initialize the data filter, and construct the getData callback function on the filter.\n   *\n   * @memberof! Filter\n   */\n  initDataFilter: function () {\n    var dataview = this.collection.parent;\n    var spot = dataview.parent;\n\n    spot.driver.releaseDataFilter(dataview, this);\n    spot.driver.initDataFilter(dataview, this);\n    spot.driver.updateDataFilter(this);\n\n    this.isInitialized = true;\n  },\n  /**\n   * The opposite or initDataFilter, it should remove the filter and deallocate other configuration\n   * related to the filter.\n   *\n   * @memberof! Filter\n   */\n  releaseDataFilter: function () {\n    var dataview = this.collection.parent;\n    var spot = dataview.parent;\n\n    spot.driver.releaseDataFilter(dataview, this);\n\n    this.isInitialized = false;\n  },\n  /**\n   * Apply changes to the filter (like selecting groups)\n   *\n   * @memberof! Filter\n   */\n  updateDataFilter: function () {\n    var dataview = this.collection.parent;\n    var spot = dataview.parent;\n\n    spot.driver.updateDataFilter(this);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ3Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmlsdGVyLmpzPzM4ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGZpbHRlciBwcm92aWRlcyBhIGNoYXJ0IHdpdGggYW4gaW50ZXJmYWNlIHRvIHRoZSBkYXRhLlxuICogVGhlIGZpbHRlciBjb250YWlucyBhIG51bWJlciBvZiBgUGFydGl0aW9uYHMgYW5kIGBBZ2dyZWdhdGVgcy5cbiAqIEl0IHRha2VzIGNhcmUgb2YgY2FsbGluZyB0aGUgcmVsZXZhbnQgZnVuY3Rpb25zIHByb3ZpZGVkIGJ5IGEgYERhdGFzZXRgLlxuICpcbiAqIEBjbGFzcyBGaWx0ZXJcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERhdGFSZWNvcmQgLSBPYmplY3QgaG9sZGluZyB0aGUgcGxvdCBkYXRhLCBwYXJ0aXRpb25zIGFyZSBsYWJlbGxlZCB3aXRoIGEgc2luZ2xlIHNtYWxsIGxldHRlciwgYWdncmVnYXRlcyB3aXRoIGEgZG91YmxlIHNtYWxsIGxldHRlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IERhdGFSZWNvcmQuYSBWYWx1ZSBvZiBmaXJzdCBwYXJ0aXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBEYXRhUmVjb3JkLmIgVmFsdWUgb2Ygc2Vjb25kIHBhcnRpdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IERhdGFSZWNvcmQuYyBWYWx1ZSBvZiB0aGlyZCBwYXJ0aXRpb24sIGV0Yy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBEYXRhUmVjb3JkLmFhIFZhbHVlIG9mIGZpcnN0IGFnZ3JlZ2F0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IERhdGFSZWNvcmQuYmIgVmFsdWUgb2Ygc2Vjb25kIGFnZ3JlZ2F0ZSwgZXRjLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0RhdGFSZWNvcmRbXX0gRGF0YSAtIEFycmF5IG9mIERhdGFSZWNvcmRzXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL3V0aWwvYmFzZScpO1xudmFyIEFnZ3JlZ2F0ZXMgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0ZS9jb2xsZWN0aW9uJyk7XG52YXIgUGFydGl0aW9ucyA9IHJlcXVpcmUoJy4vcGFydGl0aW9uL2NvbGxlY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogSGludCBmb3IgdGhlIGNsaWVudCAod2Vic2l0ZSkgaG93IHRvIHZpc3VhbGl6ZSB0aGlzIGZpbHRlclxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjaGFydFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnYmFyY2hhcnQnLFxuICAgICAgdmFsdWVzOiBbJ3BpZWNoYXJ0JywgJ2hvcml6b250YWxiYXJjaGFydCcsICdiYXJjaGFydCcsICdsaW5lY2hhcnQnLCAncmFkYXJjaGFydCcsICdwb2xhcmFyZWFjaGFydCcsICdidWJibGVwbG90JywgJ3NjYXR0ZXJjaGFydCcsICduZXR3b3JrY2hhcnQnXVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGl0bGUgZm9yIGRpc3BsYXlpbmcgcHVycG9zZXNcbiAgICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGl0bGU6IFsnc3RyaW5nJywgdHJ1ZSwgJyddLFxuICAgIC8qKlxuICAgICAqIEhpbnQgZm9yIHRoZSBjbGllbnQgKHdlYnNpdGUpIGhvdyB0byBwb3NpdGlvbiB0aGUgY2hhcnQgZm9yIHRoaXMgZmlsdGVyXG4gICAgICogcG9zaXRpb24gKGNvbCwgcm93KSBhbmQgc2l6ZSAoc2l6ZV94LCBzaXplX3kpIG9mIGNoYXJ0XG4gICAgICovXG4gICAgY29sOiAnbnVtYmVyJyxcbiAgICByb3c6ICdudW1iZXInLFxuICAgIHNpemVfeDogJ251bWJlcicsXG4gICAgc2l6ZV95OiAnbnVtYmVyJ1xuICB9LFxuICBjb2xsZWN0aW9uczoge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge1BhcnRpdGlvbnNbXX1cbiAgICAgKi9cbiAgICBwYXJ0aXRpb25zOiBQYXJ0aXRpb25zLFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge0FnZ3JlZ2F0ZVtdfVxuICAgICAqL1xuICAgIGFnZ3JlZ2F0ZXM6IEFnZ3JlZ2F0ZXNcbiAgfSxcbiAgLy8gU2Vzc2lvbiBwcm9wZXJ0aWVzIGFyZSBub3QgdHlwaWNhbGx5IHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLFxuICAvLyBhbmQgYXJlIG5vdCByZXR1cm5lZCBieSBjYWxscyB0byB0b0pTT04oKSBvciBzZXJpYWxpemUoKS5cbiAgc2Vzc2lvbjoge1xuICAgIC8qKlxuICAgICAqIEFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gcGxvdFxuICAgICAqIEBtZW1iZXJvZiEgRmlsdGVyXG4gICAgICogQHR5cGUge0RhdGF9XG4gICAgICovXG4gICAgZGF0YToge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgLypcbiAgICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gcmVxdWVzdCBuZXcgZGF0YS5cbiAgICAgKiBUaGUgZGF0YXNldCBiYWNraW5nIHRoZSBmYWNldCB3aWxsIGNvcHkgdGhlIGRhdGEgdG8gRmlsdGVyLmRhdGEuXG4gICAgICogQSBuZXdEYXRhIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGRhdGEgaXMgcmVhZHkgdG8gYmUgcGxvdHRlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgICAqIEBlbWl0cyBuZXdEYXRhXG4gICAgICovXG4gICAgZ2V0RGF0YToge1xuICAgICAgdHlwZTogJ2FueSdcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEEgaGlzdG9yeSBvZiB0aGUgY3VycmVudCBkcmlsbC1kb3duIChpZS4gcGFydGl0aW9ucy50b0pTT04oKSlcbiAgICAgKi9cbiAgICB6b29tSGlzdG9yeToge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBmaWx0ZXIgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBpc0luaXRpYWxpemVkOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2V0IHVwIGNhbGxiYWNrIHRvIGZyZWUgaW50ZXJuYWwgc3RhdGUgb24gcmVtb3ZlXG4gICAgdGhpcy5vbigncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZWxlYXNlRGF0YUZpbHRlcigpO1xuICAgIH0pO1xuICB9LFxuICB6b29tSW46IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbGVhc2VEYXRhRmlsdGVyKCk7XG5cbiAgICAvLyBzYXZlIGN1cnJlbnQgc3RhdGVcbiAgICB0aGlzLnpvb21IaXN0b3J5LnB1c2goSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJ0aXRpb25zLnRvSlNPTigpKSk7XG5cbiAgICB0aGlzLnBhcnRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGFydGl0aW9uKSB7XG4gICAgICBpZiAoKHBhcnRpdGlvbi5zZWxlY3RlZC5sZW5ndGggPT09IDIpICYmIChwYXJ0aXRpb24uaXNEYXRldGltZSB8fCBwYXJ0aXRpb24uaXNDb250aW51b3VzKSkge1xuICAgICAgICBpZiAocGFydGl0aW9uLmdyb3VwRml4ZWRTIHx8IHBhcnRpdGlvbi5ncm91cEZpeGVkU0MpIHtcbiAgICAgICAgICAvLyBzY2FsZSBkb3duIGJpbnNpemVcbiAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHBhcnRpdGlvbi5zZWxlY3RlZFsxXSAtIHBhcnRpdGlvbi5zZWxlY3RlZFswXTtcbiAgICAgICAgICB2YXIgb2xkU2l6ZSA9IHBhcnRpdGlvbi5tYXh2YWwgLSBwYXJ0aXRpb24ubWludmFsO1xuICAgICAgICAgIHBhcnRpdGlvbi5ncm91cGluZ1BhcmFtID0gcGFydGl0aW9uLmdyb3VwaW5nUGFyYW0gKiBuZXdTaXplIC8gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB6b29tIHRvIHNlbGVjdGVkIHJhbmdlLCBpZiBwb3NzaWJsZVxuICAgICAgICBwYXJ0aXRpb24uc2V0KHtcbiAgICAgICAgICBtaW52YWw6IHBhcnRpdGlvbi5zZWxlY3RlZFswXSxcbiAgICAgICAgICBtYXh2YWw6IHBhcnRpdGlvbi5zZWxlY3RlZFsxXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocGFydGl0aW9uLnNlbGVjdGVkLmxlbmd0aCA+IDAgJiYgKHBhcnRpdGlvbi5pc0NhdGVnb3JpYWwpKSB7XG4gICAgICAgIC8vIHpvb20gdG8gc2VsZWN0ZWQgY2F0ZWdvcmllcywgaWYgcG9zc2libGVcbiAgICAgICAgcGFydGl0aW9uLmdyb3Vwcy5yZXNldCgpO1xuICAgICAgICBwYXJ0aXRpb24uc2VsZWN0ZWQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBwYXJ0aXRpb24uZ3JvdXBzLmFkZCh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUsXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBzZWxlY3QgYWxsXG4gICAgICBwYXJ0aXRpb24udXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgfSk7XG4gICAgdGhpcy5pbml0RGF0YUZpbHRlcigpO1xuICAgIHRoaXMudXBkYXRlRGF0YUZpbHRlcigpOyAvLyBhbHNvIHRyaWdnZXJzIGEgZ2V0QWxsRGF0YSgpXG4gIH0sXG4gIHpvb21PdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9SZXNldCA9IHRydWU7XG5cbiAgICAvLyBjbGVhciBjdXJyZW50IHNlbGVjdGlvblxuICAgIHRoaXMucGFydGl0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aXRpb24pIHtcbiAgICAgIGlmIChwYXJ0aXRpb24uc2VsZWN0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0aXRpb24udXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIGRvUmVzZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChkb1Jlc2V0KSB7XG4gICAgICB0aGlzLnJlbGVhc2VEYXRhRmlsdGVyKCk7XG4gICAgICBpZiAodGhpcy56b29tSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgd2FzIHNlbGVjdGVkIGFuZCB3ZSBoYXZlIGRyaWxsZWQgZG93bjogZ28gdXBcbiAgICAgICAgdmFyIHN0YXRlID0gSlNPTi5wYXJzZSh0aGlzLnpvb21IaXN0b3J5LnBvcCgpKTtcbiAgICAgICAgdGhpcy5wYXJ0aXRpb25zLnJlc2V0KHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgd2FzIHNlbGVjdGVkIGFuZCBubyBkcmlsbCBkb3duOiByZXNldCBwYXJ0aXRpb25pbmdcbiAgICAgICAgdGhpcy5wYXJ0aXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpdGlvbikge1xuICAgICAgICAgIGlmIChwYXJ0aXRpb24uaXNEYXRldGltZSB8fCBwYXJ0aXRpb24uaXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICBwYXJ0aXRpb24ucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0RGF0YUZpbHRlcigpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZURhdGFGaWx0ZXIoKTsgLy8gYWxzbyB0cmlnZ2VycyBhIGdldEFsbERhdGEoKVxuICB9LFxuICAvLyBBcHBseSB0aGUgc2VwYXJhdGUgZmlsdGVyRnVuY3Rpb25zIGZyb20gZWFjaCBwYXJ0aXRpb24gaW4gYSBzaW5nbGUgZnVuY3Rpb25cbiAgZmlsdGVyRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnMgPSBbXTtcbiAgICB0aGlzLnBhcnRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocGFydGl0aW9uKSB7XG4gICAgICBmcy5wdXNoKHBhcnRpdGlvbi5maWx0ZXJGdW5jdGlvbigpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IGQuc3BsaXQoJ3wnKTtcbiAgICAgICAgcmV0dXJuIGZzLmV2ZXJ5KGZ1bmN0aW9uIChmLCBpKSB7IHJldHVybiBmKGdyb3Vwc1tpXSk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvcnRjdXQgZm9yIG5vbi1wYXJ0aXRpb25lZCBudW1lcmljIGRhdGFcbiAgICAgICAgcmV0dXJuIGZzWzBdKGQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkYXRhIGZpbHRlciwgYW5kIGNvbnN0cnVjdCB0aGUgZ2V0RGF0YSBjYWxsYmFjayBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgKi9cbiAgaW5pdERhdGFGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YXZpZXcgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90ID0gZGF0YXZpZXcucGFyZW50O1xuXG4gICAgc3BvdC5kcml2ZXIucmVsZWFzZURhdGFGaWx0ZXIoZGF0YXZpZXcsIHRoaXMpO1xuICAgIHNwb3QuZHJpdmVyLmluaXREYXRhRmlsdGVyKGRhdGF2aWV3LCB0aGlzKTtcbiAgICBzcG90LmRyaXZlci51cGRhdGVEYXRhRmlsdGVyKHRoaXMpO1xuXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBvcHBvc2l0ZSBvciBpbml0RGF0YUZpbHRlciwgaXQgc2hvdWxkIHJlbW92ZSB0aGUgZmlsdGVyIGFuZCBkZWFsbG9jYXRlIG90aGVyIGNvbmZpZ3VyYXRpb25cbiAgICogcmVsYXRlZCB0byB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YhIEZpbHRlclxuICAgKi9cbiAgcmVsZWFzZURhdGFGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YXZpZXcgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90ID0gZGF0YXZpZXcucGFyZW50O1xuXG4gICAgc3BvdC5kcml2ZXIucmVsZWFzZURhdGFGaWx0ZXIoZGF0YXZpZXcsIHRoaXMpO1xuXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIH0sXG4gIC8qKlxuICAgKiBBcHBseSBjaGFuZ2VzIHRvIHRoZSBmaWx0ZXIgKGxpa2Ugc2VsZWN0aW5nIGdyb3VwcylcbiAgICpcbiAgICogQG1lbWJlcm9mISBGaWx0ZXJcbiAgICovXG4gIHVwZGF0ZURhdGFGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YXZpZXcgPSB0aGlzLmNvbGxlY3Rpb24ucGFyZW50O1xuICAgIHZhciBzcG90ID0gZGF0YXZpZXcucGFyZW50O1xuXG4gICAgc3BvdC5kcml2ZXIudXBkYXRlRGF0YUZpbHRlcih0aGlzKTtcbiAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9476\n")},"9b75":function(module,exports,__webpack_require__){eval("/**\n * CategorialTransfrom defines a transformation on categorial and textual data,\n * and is implemented as a collection of rules.\n *\n * @class CategorialTransform\n */\nvar Model = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\n\nvar Rule = __webpack_require__(/*! ./categorial-rule */ \"ba23\");\nvar Rules = Collection.extend({\n  indexes: ['expression'],\n  model: Rule\n});\n\n/**\n * Apply the first applicable transformation rule.\n * When no matching rule is found, return 'Other'\n *\n * @function\n * @memberof! CategorialTransform\n * @param {string} text\n * @returns {string} text The transformed text\n */\nfunction transform (rules, text) {\n  var i;\n  for (i = 0; i < rules.length; i++) {\n    var group = rules.models[i].match(text);\n    if (group) {\n      return group;\n    }\n  }\n  return 'Other';\n}\n\nmodule.exports = Model.extend({\n  props: {\n    transformedType: {\n      type: 'string',\n      required: true,\n      default: 'categorial',\n      values: ['categorial']\n    },\n    transformedMin: {\n      type: 'number',\n      required: true,\n      default: 0\n    },\n    transformedMax: {\n      type: 'number',\n      required: true,\n      default: 100\n    },\n    transformedMinAsText: {\n      type: 'string',\n      required: true,\n      default: '0'\n    },\n    transformedMaxAsText: {\n      type: 'string',\n      required: true,\n      default: '100'\n    }\n  },\n  collections: {\n    rules: Rules\n  },\n  transform: function (labels) {\n    if (!this.rules) {\n      return labels;\n    }\n    if (labels instanceof Array) {\n      labels.forEach(function (label, i) {\n        labels[i] = transform(this.rules, label);\n      }, this);\n    } else {\n      labels = transform(this.rules, labels);\n    }\n    return labels;\n  },\n  reset: function () {\n    this.rules.reset();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOWI3NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY2F0ZWdvcmlhbC10cmFuc2Zvcm0uanM/MzBlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENhdGVnb3JpYWxUcmFuc2Zyb20gZGVmaW5lcyBhIHRyYW5zZm9ybWF0aW9uIG9uIGNhdGVnb3JpYWwgYW5kIHRleHR1YWwgZGF0YSxcbiAqIGFuZCBpcyBpbXBsZW1lbnRlZCBhcyBhIGNvbGxlY3Rpb24gb2YgcnVsZXMuXG4gKlxuICogQGNsYXNzIENhdGVnb3JpYWxUcmFuc2Zvcm1cbiAqL1xudmFyIE1vZGVsID0gcmVxdWlyZSgnYW1wZXJzYW5kLW1vZGVsJyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG5cbnZhciBSdWxlID0gcmVxdWlyZSgnLi9jYXRlZ29yaWFsLXJ1bGUnKTtcbnZhciBSdWxlcyA9IENvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgaW5kZXhlczogWydleHByZXNzaW9uJ10sXG4gIG1vZGVsOiBSdWxlXG59KTtcblxuLyoqXG4gKiBBcHBseSB0aGUgZmlyc3QgYXBwbGljYWJsZSB0cmFuc2Zvcm1hdGlvbiBydWxlLlxuICogV2hlbiBubyBtYXRjaGluZyBydWxlIGlzIGZvdW5kLCByZXR1cm4gJ090aGVyJ1xuICpcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mISBDYXRlZ29yaWFsVHJhbnNmb3JtXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybnMge3N0cmluZ30gdGV4dCBUaGUgdHJhbnNmb3JtZWQgdGV4dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0gKHJ1bGVzLCB0ZXh0KSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JvdXAgPSBydWxlcy5tb2RlbHNbaV0ubWF0Y2godGV4dCk7XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9XG4gIHJldHVybiAnT3RoZXInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgdHJhbnNmb3JtZWRUeXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJ2NhdGVnb3JpYWwnLFxuICAgICAgdmFsdWVzOiBbJ2NhdGVnb3JpYWwnXVxuICAgIH0sXG4gICAgdHJhbnNmb3JtZWRNaW46IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICB0cmFuc2Zvcm1lZE1heDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IDEwMFxuICAgIH0sXG4gICAgdHJhbnNmb3JtZWRNaW5Bc1RleHQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnMCdcbiAgICB9LFxuICAgIHRyYW5zZm9ybWVkTWF4QXNUZXh0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJzEwMCdcbiAgICB9XG4gIH0sXG4gIGNvbGxlY3Rpb25zOiB7XG4gICAgcnVsZXM6IFJ1bGVzXG4gIH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKGxhYmVscykge1xuICAgIGlmICghdGhpcy5ydWxlcykge1xuICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9XG4gICAgaWYgKGxhYmVscyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwsIGkpIHtcbiAgICAgICAgbGFiZWxzW2ldID0gdHJhbnNmb3JtKHRoaXMucnVsZXMsIGxhYmVsKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbHMgPSB0cmFuc2Zvcm0odGhpcy5ydWxlcywgbGFiZWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVscztcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJ1bGVzLnJlc2V0KCk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9b75\n")},"9d63":function(module,exports,__webpack_require__){eval("/**\n * The Aggregate class describes how to aggregate data, as described by a `Facet` into a single value.\n * For example, you can sum or average over numbers, or count the number of different labels.\n *\n * @class Aggregate\n * @extends Base\n */\nvar BaseModel = __webpack_require__(/*! ./util/base */ \"3902\");\n\nmodule.exports = BaseModel.extend({\n  props: {\n    /**\n     * The name of the facet to aggregate over\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    facetName: 'string',\n\n    /**\n     * Label for displaying on plots\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    label: {\n      type: 'string',\n      required: true,\n      default: ''\n    },\n\n    /**\n     * When part of a aggregates, this deterimines the ordering\n     * @memberof! Aggregate\n     * @type {number}\n     */\n    rank: {\n      type: 'number',\n      required: true\n    },\n\n    /**\n     * Operation:\n     *  * `count`  count the number of elements in the group\n     *  * `sum`    sum the elements in the group\n     *  * `avg`    take the average of the elements in the group\n     *  * `stddev`  take the sample\n     *  * `min`    minum value of the elements in the group\n     *  * `max`    maximum value of the elements in the group\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    operation: {\n      type: 'string',\n      required: true,\n      default: 'avg',\n      values: ['count', 'avg', 'sum', 'stddev', 'min', 'max']\n    },\n    // NOTE: properties for reduction, should be a valid SQL aggregation function\n\n    /**\n     * Normalization: TODO\n     *  * `none`      data in same units as the original data\n     *  * `relative`  data is in percentages of the total; for subgroups in percentage of the parent group\n     * @memberof! Aggregate\n     * @type {string}\n     */\n    normalization: {\n      type: 'string',\n      required: true,\n      default: 'none',\n      values: ['none', 'percentage']\n    }\n  },\n  derived: {\n    // operation values\n    doSum: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'sum';\n      }\n    },\n    doCount: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'count';\n      }\n    },\n    doAverage: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'avg';\n      }\n    },\n    doStddev: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'stddev';\n      }\n    },\n    doMin: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'min';\n      }\n    },\n    doMax: {\n      deps: ['operation'],\n      fn: function () {\n        return this.operation === 'max';\n      }\n    },\n\n    // normalization values\n    normalizeNone: {\n      deps: ['normalization'],\n      fn: function () {\n        return this.normalization === 'absolute';\n      }\n    },\n    normalizePercentage: {\n      deps: ['normalization'],\n      fn: function () {\n        return this.normalization === 'percentage';\n      }\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOWQ2My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvYWdncmVnYXRlLmpzP2JkNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgQWdncmVnYXRlIGNsYXNzIGRlc2NyaWJlcyBob3cgdG8gYWdncmVnYXRlIGRhdGEsIGFzIGRlc2NyaWJlZCBieSBhIGBGYWNldGAgaW50byBhIHNpbmdsZSB2YWx1ZS5cbiAqIEZvciBleGFtcGxlLCB5b3UgY2FuIHN1bSBvciBhdmVyYWdlIG92ZXIgbnVtYmVycywgb3IgY291bnQgdGhlIG51bWJlciBvZiBkaWZmZXJlbnQgbGFiZWxzLlxuICpcbiAqIEBjbGFzcyBBZ2dyZWdhdGVcbiAqIEBleHRlbmRzIEJhc2VcbiAqL1xudmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZU1vZGVsLmV4dGVuZCh7XG4gIHByb3BzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZhY2V0IHRvIGFnZ3JlZ2F0ZSBvdmVyXG4gICAgICogQG1lbWJlcm9mISBBZ2dyZWdhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZhY2V0TmFtZTogJ3N0cmluZycsXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBmb3IgZGlzcGxheWluZyBvbiBwbG90c1xuICAgICAqIEBtZW1iZXJvZiEgQWdncmVnYXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsYWJlbDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGFydCBvZiBhIGFnZ3JlZ2F0ZXMsIHRoaXMgZGV0ZXJpbWluZXMgdGhlIG9yZGVyaW5nXG4gICAgICogQG1lbWJlcm9mISBBZ2dyZWdhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJhbms6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uOlxuICAgICAqICAqIGBjb3VudGAgIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGdyb3VwXG4gICAgICogICogYHN1bWAgICAgc3VtIHRoZSBlbGVtZW50cyBpbiB0aGUgZ3JvdXBcbiAgICAgKiAgKiBgYXZnYCAgICB0YWtlIHRoZSBhdmVyYWdlIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgZ3JvdXBcbiAgICAgKiAgKiBgc3RkZGV2YCAgdGFrZSB0aGUgc2FtcGxlXG4gICAgICogICogYG1pbmAgICAgbWludW0gdmFsdWUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBncm91cFxuICAgICAqICAqIGBtYXhgICAgIG1heGltdW0gdmFsdWUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBncm91cFxuICAgICAqIEBtZW1iZXJvZiEgQWdncmVnYXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnYXZnJyxcbiAgICAgIHZhbHVlczogWydjb3VudCcsICdhdmcnLCAnc3VtJywgJ3N0ZGRldicsICdtaW4nLCAnbWF4J11cbiAgICB9LFxuICAgIC8vIE5PVEU6IHByb3BlcnRpZXMgZm9yIHJlZHVjdGlvbiwgc2hvdWxkIGJlIGEgdmFsaWQgU1FMIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemF0aW9uOiBUT0RPXG4gICAgICogICogYG5vbmVgICAgICAgZGF0YSBpbiBzYW1lIHVuaXRzIGFzIHRoZSBvcmlnaW5hbCBkYXRhXG4gICAgICogICogYHJlbGF0aXZlYCAgZGF0YSBpcyBpbiBwZXJjZW50YWdlcyBvZiB0aGUgdG90YWw7IGZvciBzdWJncm91cHMgaW4gcGVyY2VudGFnZSBvZiB0aGUgcGFyZW50IGdyb3VwXG4gICAgICogQG1lbWJlcm9mISBBZ2dyZWdhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5vcm1hbGl6YXRpb246IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAnbm9uZScsXG4gICAgICB2YWx1ZXM6IFsnbm9uZScsICdwZXJjZW50YWdlJ11cbiAgICB9XG4gIH0sXG4gIGRlcml2ZWQ6IHtcbiAgICAvLyBvcGVyYXRpb24gdmFsdWVzXG4gICAgZG9TdW06IHtcbiAgICAgIGRlcHM6IFsnb3BlcmF0aW9uJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb24gPT09ICdzdW0nO1xuICAgICAgfVxuICAgIH0sXG4gICAgZG9Db3VudDoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ2NvdW50JztcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvQXZlcmFnZToge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ2F2Zyc7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb1N0ZGRldjoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ3N0ZGRldic7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb01pbjoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ21pbic7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb01heDoge1xuICAgICAgZGVwczogWydvcGVyYXRpb24nXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ21heCc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIG5vcm1hbGl6YXRpb24gdmFsdWVzXG4gICAgbm9ybWFsaXplTm9uZToge1xuICAgICAgZGVwczogWydub3JtYWxpemF0aW9uJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uID09PSAnYWJzb2x1dGUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybWFsaXplUGVyY2VudGFnZToge1xuICAgICAgZGVwczogWydub3JtYWxpemF0aW9uJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uID09PSAncGVyY2VudGFnZSc7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9d63\n")},a0ca:function(module,exports,__webpack_require__){eval("/**\n * DatetimeTransform defines a transformation on time or dates with timezones\n *\n * @class DatetimeTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar util = __webpack_require__(/*! ../util/time */ \"d45b\");\nvar misval = __webpack_require__(/*! ../util/misval */ \"bff6\");\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * Timezone to use when parsing, for when timezone information is absent or incorrect.\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    zone: ['string', true, 'ISO8601'],\n\n    /**\n     * Format indentifier to use when parsing, when not in ISO8601 format\n     * Mappings are defined in util/time.js => timeParts.description\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    format: ['string', true, 'ISO8601'],\n\n    /**\n     * Reformats to a string using the momentjs or postgreSQL format specifiers.\n     * This allows a transformation to day of the year, or day of week etc.\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedFormat: ['string', true, 'ISO8601'],\n\n    /**\n     * Controls conversion to duration by subtracting this date\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedReference: 'string',\n\n    /**\n     * Reference timezone for conversion from datetime to duration\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedZone: ['string', true, 'ISO8601']\n\n  },\n  derived: {\n    // reference momentjs for duration <-> datetime conversion\n    referenceMoment: {\n      deps: ['transformedReference', 'transformedZone'],\n      fn: function () {\n        var tz;\n        if (this.transformedZone === 'ISO8601') {\n          tz = moment.tz.guess();\n        } else {\n          var timeZone = util.timeZones.get(this.transformedZone, 'description');\n          if (timeZone && timeZone.format) {\n            tz = timeZone.format;\n          } else {\n            tz = moment.tz.guess();\n          }\n        }\n        if (this.transformedReference) {\n          return moment.tz(this.transformedReference, tz);\n        }\n        return null;\n      }\n    },\n    /**\n     * The type of the facet after the transformation has been applied\n     * @memberof! DatetimeTransform\n     */\n    transformedType: {\n      deps: ['transformedFormat', 'transformedReference'],\n      fn: function () {\n        if (this.transformedReference) {\n          // datetime -> duration\n          return 'duration';\n        } else if (this.transformedFormat === 'ISO8601') {\n          // datetime -> datetime\n          return 'datetime';\n        } else {\n          // datetime -> time part\n          var timePart = util.timeParts.get(this.transformedFormat, 'description');\n          if (timePart && timePart.type) {\n            return timePart.type;\n          }\n        }\n        return 'datetime';\n      },\n      cache: false\n    },\n    /**\n     * The minium value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! DatetimeTransform\n     */\n    transformedMin: {\n      deps: ['transformedType'],\n      fn: function () {\n        var timePart;\n        if (this.transformedType === 'datetime' || this.transformedType === 'duration') {\n          return this.transform(this.parent.minval);\n        }\n        timePart = util.timeParts.get(this.transformedFormat, 'description');\n        if (timePart.calcualte) {\n          return this.transform(this.parent.minval);\n        } else {\n          return timePart.min;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     * @type {number}\n     * @memberof! DatetimeTransform\n     */\n    transformedMax: {\n      deps: ['transformedType'],\n      fn: function () {\n        var timePart;\n        if (this.transformedType === 'datetime' || this.transformedType === 'duration') {\n          return this.transform(this.parent.maxval);\n        }\n        timePart = util.timeParts.get(this.transformedFormat, 'description');\n        if (timePart.calcualte) {\n          return this.transform(this.parent.maxval);\n        } else {\n          return timePart.max;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! DatetimeTransform\n     */\n    transformedMinAsText: {\n      deps: ['transformedMin', 'transformedType'],\n      fn: function () {\n        var minval = this.transformedMin;\n        if (this.transformedType === 'datetime') {\n          return minval.format();\n        } else {\n          return minval.toString();\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! DatetimeTransform\n     */\n    transformedMaxAsText: {\n      deps: ['transformedMax', 'transformedType'],\n      fn: function () {\n        var maxval = this.transformedMax;\n        if (this.transformedType === 'datetime') {\n          return maxval.format();\n        } else {\n          return maxval.toString();\n        }\n      },\n      cache: false\n    }\n  },\n\n  /**\n   * @function\n   * @memberof! DatetimeTransform\n   * @param {Object} momentjs\n   * @returns {Object} momentjs\n   */\n  transform: function transform (inval) {\n    if (typeof inval === 'undefined') {\n      return misval;\n    }\n\n    var d = inval.clone();\n    var timePart;\n\n    if (this.referenceMoment) {\n      // datetime -> duration\n      return moment.duration(d.diff(this.referenceMoment, 'milliseconds', true), 'milliseconds');\n    } else if (this.transformedFormat !== 'ISO8601') {\n      timePart = util.timeParts.get(this.transformedFormat, 'description');\n      if (timePart && timePart.momentFormat) {\n        return d.format(timePart.momentFormat);\n      }\n      return d;\n    } else {\n      return d;\n    }\n  },\n  reset: function () {\n    this.unset(['zone', 'transformedFormat', 'transformedZone', 'transformedReference']);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYTBjYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvZGF0ZXRpbWUtdHJhbnNmb3JtLmpzPzM1YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRldGltZVRyYW5zZm9ybSBkZWZpbmVzIGEgdHJhbnNmb3JtYXRpb24gb24gdGltZSBvciBkYXRlcyB3aXRoIHRpbWV6b25lc1xuICpcbiAqIEBjbGFzcyBEYXRldGltZVRyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lJyk7XG52YXIgbWlzdmFsID0gcmVxdWlyZSgnLi4vdXRpbC9taXN2YWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbXBlcnNhbmRNb2RlbC5leHRlbmQoe1xuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIHRvIHVzZSB3aGVuIHBhcnNpbmcsIGZvciB3aGVuIHRpbWV6b25lIGluZm9ybWF0aW9uIGlzIGFic2VudCBvciBpbmNvcnJlY3QuXG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgem9uZTogWydzdHJpbmcnLCB0cnVlLCAnSVNPODYwMSddLFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGluZGVudGlmaWVyIHRvIHVzZSB3aGVuIHBhcnNpbmcsIHdoZW4gbm90IGluIElTTzg2MDEgZm9ybWF0XG4gICAgICogTWFwcGluZ3MgYXJlIGRlZmluZWQgaW4gdXRpbC90aW1lLmpzID0+IHRpbWVQYXJ0cy5kZXNjcmlwdGlvblxuICAgICAqIEBtZW1iZXJvZiEgRGF0ZXRpbWVUcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdDogWydzdHJpbmcnLCB0cnVlLCAnSVNPODYwMSddLFxuXG4gICAgLyoqXG4gICAgICogUmVmb3JtYXRzIHRvIGEgc3RyaW5nIHVzaW5nIHRoZSBtb21lbnRqcyBvciBwb3N0Z3JlU1FMIGZvcm1hdCBzcGVjaWZpZXJzLlxuICAgICAqIFRoaXMgYWxsb3dzIGEgdHJhbnNmb3JtYXRpb24gdG8gZGF5IG9mIHRoZSB5ZWFyLCBvciBkYXkgb2Ygd2VlayBldGMuXG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRGb3JtYXQ6IFsnc3RyaW5nJywgdHJ1ZSwgJ0lTTzg2MDEnXSxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIGNvbnZlcnNpb24gdG8gZHVyYXRpb24gYnkgc3VidHJhY3RpbmcgdGhpcyBkYXRlXG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRSZWZlcmVuY2U6ICdzdHJpbmcnLFxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRpbWV6b25lIGZvciBjb252ZXJzaW9uIGZyb20gZGF0ZXRpbWUgdG8gZHVyYXRpb25cbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFpvbmU6IFsnc3RyaW5nJywgdHJ1ZSwgJ0lTTzg2MDEnXVxuXG4gIH0sXG4gIGRlcml2ZWQ6IHtcbiAgICAvLyByZWZlcmVuY2UgbW9tZW50anMgZm9yIGR1cmF0aW9uIDwtPiBkYXRldGltZSBjb252ZXJzaW9uXG4gICAgcmVmZXJlbmNlTW9tZW50OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkUmVmZXJlbmNlJywgJ3RyYW5zZm9ybWVkWm9uZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR6O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFpvbmUgPT09ICdJU084NjAxJykge1xuICAgICAgICAgIHR6ID0gbW9tZW50LnR6Lmd1ZXNzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRpbWVab25lID0gdXRpbC50aW1lWm9uZXMuZ2V0KHRoaXMudHJhbnNmb3JtZWRab25lLCAnZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICBpZiAodGltZVpvbmUgJiYgdGltZVpvbmUuZm9ybWF0KSB7XG4gICAgICAgICAgICB0eiA9IHRpbWVab25lLmZvcm1hdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHogPSBtb21lbnQudHouZ3Vlc3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50LnR6KHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UsIHR6KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBmYWNldCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqIEBtZW1iZXJvZiEgRGF0ZXRpbWVUcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFR5cGU6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRGb3JtYXQnLCAndHJhbnNmb3JtZWRSZWZlcmVuY2UnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgLy8gZGF0ZXRpbWUgLT4gZHVyYXRpb25cbiAgICAgICAgICByZXR1cm4gJ2R1cmF0aW9uJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zZm9ybWVkRm9ybWF0ID09PSAnSVNPODYwMScpIHtcbiAgICAgICAgICAvLyBkYXRldGltZSAtPiBkYXRldGltZVxuICAgICAgICAgIHJldHVybiAnZGF0ZXRpbWUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRhdGV0aW1lIC0+IHRpbWUgcGFydFxuICAgICAgICAgIHZhciB0aW1lUGFydCA9IHV0aWwudGltZVBhcnRzLmdldCh0aGlzLnRyYW5zZm9ybWVkRm9ybWF0LCAnZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICBpZiAodGltZVBhcnQgJiYgdGltZVBhcnQudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVQYXJ0LnR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZGF0ZXRpbWUnO1xuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1pbml1bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWluOiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVQYXJ0O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScgfHwgdGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkdXJhdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odGhpcy5wYXJlbnQubWludmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lUGFydCA9IHV0aWwudGltZVBhcnRzLmdldCh0aGlzLnRyYW5zZm9ybWVkRm9ybWF0LCAnZGVzY3JpcHRpb24nKTtcbiAgICAgICAgaWYgKHRpbWVQYXJ0LmNhbGN1YWx0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0aGlzLnBhcmVudC5taW52YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aW1lUGFydC5taW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRNYXg6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRUeXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGltZVBhcnQ7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJyB8fCB0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2R1cmF0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0aGlzLnBhcmVudC5tYXh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVQYXJ0ID0gdXRpbC50aW1lUGFydHMuZ2V0KHRoaXMudHJhbnNmb3JtZWRGb3JtYXQsICdkZXNjcmlwdGlvbicpO1xuICAgICAgICBpZiAodGltZVBhcnQuY2FsY3VhbHRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHRoaXMucGFyZW50Lm1heHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRpbWVQYXJ0Lm1heDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gdmFsdWUgdGhpcyBmYWNldCBjYW4gdGFrZSwgYWZ0ZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mISBEYXRldGltZVRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWluQXNUZXh0OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkTWluJywgJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1pbnZhbCA9IHRoaXMudHJhbnNmb3JtZWRNaW47XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHJldHVybiBtaW52YWwuZm9ybWF0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1pbnZhbC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRNYXhBc1RleHQ6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRNYXgnLCAndHJhbnNmb3JtZWRUeXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4dmFsID0gdGhpcy50cmFuc2Zvcm1lZE1heDtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRUeXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1heHZhbC5mb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWF4dmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YhIERhdGV0aW1lVHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb21lbnRqc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtb21lbnRqc1xuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0gKGludmFsKSB7XG4gICAgaWYgKHR5cGVvZiBpbnZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBpbnZhbC5jbG9uZSgpO1xuICAgIHZhciB0aW1lUGFydDtcblxuICAgIGlmICh0aGlzLnJlZmVyZW5jZU1vbWVudCkge1xuICAgICAgLy8gZGF0ZXRpbWUgLT4gZHVyYXRpb25cbiAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZC5kaWZmKHRoaXMucmVmZXJlbmNlTW9tZW50LCAnbWlsbGlzZWNvbmRzJywgdHJ1ZSksICdtaWxsaXNlY29uZHMnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNmb3JtZWRGb3JtYXQgIT09ICdJU084NjAxJykge1xuICAgICAgdGltZVBhcnQgPSB1dGlsLnRpbWVQYXJ0cy5nZXQodGhpcy50cmFuc2Zvcm1lZEZvcm1hdCwgJ2Rlc2NyaXB0aW9uJyk7XG4gICAgICBpZiAodGltZVBhcnQgJiYgdGltZVBhcnQubW9tZW50Rm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBkLmZvcm1hdCh0aW1lUGFydC5tb21lbnRGb3JtYXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVuc2V0KFsnem9uZScsICd0cmFuc2Zvcm1lZEZvcm1hdCcsICd0cmFuc2Zvcm1lZFpvbmUnLCAndHJhbnNmb3JtZWRSZWZlcmVuY2UnXSk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a0ca\n")},a376:function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction crossfilter_filterExact(bisect, value) {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nfunction crossfilter_filterRange(bisect, range) {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nfunction crossfilter_filterAll(values) {\n  return [0, values.length];\n}\n\nmodule.exports = {\n  filterExact: crossfilter_filterExact,\n  filterRange: crossfilter_filterRange,\n  filterAll: crossfilter_filterAll\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYTM3Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9maWx0ZXIuanM/MzFmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNyb3NzZmlsdGVyX2ZpbHRlckV4YWN0KGJpc2VjdCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICByZXR1cm4gW2Jpc2VjdC5sZWZ0KHZhbHVlcywgdmFsdWUsIDAsIG4pLCBiaXNlY3QucmlnaHQodmFsdWVzLCB2YWx1ZSwgMCwgbildO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9maWx0ZXJSYW5nZShiaXNlY3QsIHJhbmdlKSB7XG4gIHZhciBtaW4gPSByYW5nZVswXSxcbiAgICAgIG1heCA9IHJhbmdlWzFdO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHJldHVybiBbYmlzZWN0LmxlZnQodmFsdWVzLCBtaW4sIDAsIG4pLCBiaXNlY3QubGVmdCh2YWx1ZXMsIG1heCwgMCwgbildO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9maWx0ZXJBbGwodmFsdWVzKSB7XG4gIHJldHVybiBbMCwgdmFsdWVzLmxlbmd0aF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaWx0ZXJFeGFjdDogY3Jvc3NmaWx0ZXJfZmlsdGVyRXhhY3QsXG4gIGZpbHRlclJhbmdlOiBjcm9zc2ZpbHRlcl9maWx0ZXJSYW5nZSxcbiAgZmlsdGVyQWxsOiBjcm9zc2ZpbHRlcl9maWx0ZXJBbGxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///a376\n")},a74f:function(module,exports,__webpack_require__){"use strict";eval('\n\nvar crossfilter_identity = __webpack_require__(/*! ./identity */ "55a3");\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nmodule.exports = heap_by(crossfilter_identity);\nmodule.exports.by = heap_by;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYTc0Zi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9oZWFwLmpzP2RiY2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3Jvc3NmaWx0ZXJfaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbmZ1bmN0aW9uIGhlYXBfYnkoZikge1xuXG4gIC8vIEJ1aWxkcyBhIGJpbmFyeSBoZWFwIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGFycmF5IGFbbG86aGldLiBUaGUgaGVhcCBoYXMgdGhlXG4gIC8vIHByb3BlcnR5IHN1Y2ggdGhhdCB0aGUgcGFyZW50IGFbbG8raV0gaXMgYWx3YXlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBpdHNcbiAgLy8gdHdvIGNoaWxkcmVuOiBhW2xvKzIqaSsxXSBhbmQgYVtsbysyKmkrMl0uXG4gIGZ1bmN0aW9uIGhlYXAoYSwgbG8sIGhpKSB7XG4gICAgdmFyIG4gPSBoaSAtIGxvLFxuICAgICAgICBpID0gKG4gPj4+IDEpICsgMTtcbiAgICB3aGlsZSAoLS1pID4gMCkgc2lmdChhLCBpLCBuLCBsbyk7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICAvLyBTb3J0cyB0aGUgc3BlY2lmaWVkIGFycmF5IGFbbG86aGldIGluIGRlc2NlbmRpbmcgb3JkZXIsIGFzc3VtaW5nIGl0IGlzXG4gIC8vIGFscmVhZHkgYSBoZWFwLlxuICBmdW5jdGlvbiBzb3J0KGEsIGxvLCBoaSkge1xuICAgIHZhciBuID0gaGkgLSBsbyxcbiAgICAgICAgdDtcbiAgICB3aGlsZSAoLS1uID4gMCkgdCA9IGFbbG9dLCBhW2xvXSA9IGFbbG8gKyBuXSwgYVtsbyArIG5dID0gdCwgc2lmdChhLCAxLCBuLCBsbyk7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICAvLyBTaWZ0cyB0aGUgZWxlbWVudCBhW2xvK2ktMV0gZG93biB0aGUgaGVhcCwgd2hlcmUgdGhlIGhlYXAgaXMgdGhlIGNvbnRpZ3VvdXNcbiAgLy8gc2xpY2Ugb2YgYXJyYXkgYVtsbzpsbytuXS4gVGhpcyBtZXRob2QgY2FuIGFsc28gYmUgdXNlZCB0byB1cGRhdGUgdGhlIGhlYXBcbiAgLy8gaW5jcmVtZW50YWxseSwgd2l0aG91dCBpbmN1cnJpbmcgdGhlIGZ1bGwgY29zdCBvZiByZWNvbnN0cnVjdGluZyB0aGUgaGVhcC5cbiAgZnVuY3Rpb24gc2lmdChhLCBpLCBuLCBsbykge1xuICAgIHZhciBkID0gYVstLWxvICsgaV0sXG4gICAgICAgIHggPSBmKGQpLFxuICAgICAgICBjaGlsZDtcbiAgICB3aGlsZSAoKGNoaWxkID0gaSA8PCAxKSA8PSBuKSB7XG4gICAgICBpZiAoY2hpbGQgPCBuICYmIGYoYVtsbyArIGNoaWxkXSkgPiBmKGFbbG8gKyBjaGlsZCArIDFdKSkgY2hpbGQrKztcbiAgICAgIGlmICh4IDw9IGYoYVtsbyArIGNoaWxkXSkpIGJyZWFrO1xuICAgICAgYVtsbyArIGldID0gYVtsbyArIGNoaWxkXTtcbiAgICAgIGkgPSBjaGlsZDtcbiAgICB9XG4gICAgYVtsbyArIGldID0gZDtcbiAgfVxuXG4gIGhlYXAuc29ydCA9IHNvcnQ7XG4gIHJldHVybiBoZWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhlYXBfYnkoY3Jvc3NmaWx0ZXJfaWRlbnRpdHkpO1xubW9kdWxlLmV4cG9ydHMuYnkgPSBoZWFwX2J5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///a74f\n')},a8db:function(module){eval('module.exports = {"_from":"git://github.com/crossfilter/crossfilter.git#37b03d13f52c28b5dcfbca4673f795c225aa9095","_id":"crossfilter2@1.4.6","_inBundle":false,"_integrity":"","_location":"/spot-framework/crossfilter2","_phantomChildren":{},"_requested":{"type":"git","raw":"crossfilter2@git://github.com/crossfilter/crossfilter.git#37b03d13f52c28b5dcfbca4673f795c225aa9095","name":"crossfilter2","escapedName":"crossfilter2","rawSpec":"git://github.com/crossfilter/crossfilter.git#37b03d13f52c28b5dcfbca4673f795c225aa9095","saveSpec":"git://github.com/crossfilter/crossfilter.git#37b03d13f52c28b5dcfbca4673f795c225aa9095","fetchSpec":"git://github.com/crossfilter/crossfilter.git","gitCommittish":"37b03d13f52c28b5dcfbca4673f795c225aa9095"},"_requiredBy":["/spot-framework"],"_resolved":"git://github.com/crossfilter/crossfilter.git#37b03d13f52c28b5dcfbca4673f795c225aa9095","_spec":"crossfilter2@git://github.com/crossfilter/crossfilter.git#37b03d13f52c28b5dcfbca4673f795c225aa9095","_where":"/home/fdiblen/nlesc/projects/idark/SPOT/spot/node_modules/spot-framework","author":{"name":"Mike Bostock","url":"http://bost.ocks.org/mike"},"bugs":{"url":"https://github.com/crossfilter/crossfilter/issues"},"bundleDependencies":false,"contributors":[{"name":"Jason Davies","url":"http://www.jasondavies.com/"}],"dependencies":{"lodash.result":"^4.4.0"},"deprecated":false,"description":"Fast multidimensional filtering for coordinated views.","devDependencies":{"browserify":"^13.0.0","d3":"3.5","eslint":"2.10.2","package-json-versionify":"1.0.2","semver":"^5.3.0","sinon":"^4.0.2","uglify-js":"2.4.0","vows":"0.7.0"},"eslintConfig":{"env":{"browser":true,"node":true},"globals":{"Uint8Array":true,"Uint16Array":true,"Uint32Array":true},"extends":"eslint:recommended"},"files":["src","index.js","index.d.ts","crossfilter.js","crossfilter.min.js"],"homepage":"https://crossfilter.github.io/crossfilter/","keywords":["analytics","visualization","crossfilter"],"license":"Apache-2.0","main":"./index.js","maintainers":[{"name":"Gordon Woodhull","url":"https://github.com/gordonwoodhull"},{"name":"Tanner Linsley","url":"https://github.com/tannerlinsley"},{"name":"Ethan Jewett","url":"https://github.com/esjewett"}],"name":"crossfilter2","repository":{"type":"git","url":"git+ssh://git@github.com/crossfilter/crossfilter.git"},"scripts":{"benchmark":"node test/benchmark.js","build":"browserify index.js -t package-json-versionify --standalone crossfilter -o crossfilter.js && uglifyjs --compress --mangle --screw-ie8 crossfilter.js -o crossfilter.min.js","clean":"rm -f crossfilter.js crossfilter.min.js","test":"vows --verbose && eslint src/"},"types":"./index.d.ts","unpkg":"./crossfilter.min.js","version":"1.4.6"};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYThkYi5qcyIsInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///a8db\n')},aa6c:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar keys = __webpack_require__(/*! ./keys */ \"7d91\");\nvar hasBinary = __webpack_require__(/*! has-binary */ \"d304\");\nvar sliceBuffer = __webpack_require__(/*! arraybuffer.slice */ \"ef13\");\nvar after = __webpack_require__(/*! after */ \"4aa5\");\nvar utf8 = __webpack_require__(/*! wtf-8 */ \"943e\");\n\nvar base64encoder;\nif (global && global.ArrayBuffer) {\n  base64encoder = __webpack_require__(/*! base64-arraybuffer */ \"21de\");\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = __webpack_require__(/*! blob */ \"939f\");\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof global.Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data == 'string') {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data);\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWE2Yy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcz9hZjAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd3dGYtOCcpO1xuXG52YXIgYmFzZTY0ZW5jb2RlcjtcbmlmIChnbG9iYWwgJiYgZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgZGF0YSA9IHRyeURlY29kZShkYXRhKTtcbiAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICB0cnkge1xuICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghYmFzZTY0ZW5jb2Rlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///aa6c\n")},adfa:function(module,exports,__webpack_require__){eval("/**\n * Utility functions for crossfilter datasets\n * We roughly follow the crossfilter design of dimensions and groups, but we\n * add extra steps to allow transformations on the data.\n * 1. a datum is turned into a raw value, ie. string or number etc. by rawValueFn\n * 2. it is then cast to the correct type value using baseValFn\n * 3. a further transfrom can be applied with valueFn\n * 4. a value is grouped using groupFn; this value must be either a number or a string.\n *\n * @module client/util-crossfilter\n * @see rawValueFn, baseValueFn, valueFn, groupFn\n */\nvar misval = __webpack_require__(/*! ./misval */ \"bff6\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar util = __webpack_require__(/*! ../util/time */ \"d45b\");\n\n/**\n * @typedef {Object} SubgroupValue\n * @property {number} count The count of the number of elements in this subgroup\n * @property {number} sum The sum of all elements in this subgroup\n */\n\n/**\n * Reduce a SubgroupValue to a single number\n *\n * @callback reduceCB\n * @param {SubgroupValue} d SubgroupValue\n * @returns {number} Reduced value\n */\n/**\n\n/**\n * Returns a function for further reducing the crossfilter group\n * to a single value, depending on sum/count/average settings of\n * the Aggregate class.\n * @param {Aggregate} facet - The Aggregate class for which to create the reduction function\n * @returns {cb} The required reduction function\n */\nfunction reduceFn (aggregate) {\n  if (aggregate.doSum) {\n    /**\n     * @callback subgroupSum\n     * @param {SubgroupValue} d\n     * @returns {number} sum\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n      if (d.count > 0) {\n        return d.sum;\n      } else {\n        return misval;\n      }\n    };\n  } else if (aggregate.doCount) {\n    /**\n     * @callback subgroupCount\n     * @param {SubgroupValue} d\n     * @returns {number} count\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n      if (d.count > 0) {\n        return d.count;\n      } else {\n        return misval;\n      }\n    };\n  } else if (aggregate.doAverage) {\n    /**\n     * @callback subgroupAverage\n     * @param {SubgroupValue} d\n     * @returns {number} d.sum/d.count\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n\n      if (d.count > 0) {\n        return d.sum / d.count;\n      } else {\n        return misval;\n      }\n    };\n  } else if (aggregate.doStddev) {\n    /**\n     * @callback subgroupStddev\n     * @param {SubgroupValue} d\n     * @returns {number} stddev(d)\n     */\n    return function (d) {\n      if (d === misval || d == null) {\n        return misval;\n      }\n\n      // \\sum_i (x_i - \\bar x)^2 =\n      //   \\sum_i (x_i^2 - 2x_i\\bar x + (\\bar x)^2) =\n      //   \\sum_i (x_i^2) - 2 N (\\bar x)^2 + N(\\bar x)^2 =\n      //   \\sum_i (x_i^2) - N (\\bar x)^2\n      if (d.count > 1) {\n        return Math.sqrt((d.sumsquares - (d.sum * d.sum / d.count)) / (d.count - 1));\n      } else {\n        return misval;\n      }\n    };\n  }\n\n  console.error('Operation not implemented for this Aggregate', aggregate);\n  return function (d) {\n    if (d === misval || d == null) {\n      return misval;\n    }\n    if (d.count > 0) {\n      return d.count;\n    } else {\n      return misval;\n    }\n  };\n}\n\n// ********************************************************\n// Facet transform utility function\n// ********************************************************\n\n/**\n * Returns the base value for a datum\n *\n * @callback baseValueCB\n * @param {Object} d Raw data record\n * @returns {Object} base value\n */\n\n/**\n * Raw value for given facet\n * @param {Facet} facet\n * @returns {rawValueCB} Raw value function for this facet\n */\nfunction rawValueFn (facet) {\n  var accessor;\n\n  // Array dimensions have a [] appended to the accessor,\n  // remove it to get to the actual accessor\n  var path = facet.accessor;\n  if (path.match(/\\[]$/)) {\n    path = path.substring(0, path.length - 2);\n  }\n\n  var misvals = {};\n  facet.misval.forEach(function (val) {\n    misvals[val] = true;\n  });\n\n  // Access nested properties via a double hash sign, this to prevent collision with regular keys; fi. 'person.name'\n  path = path.split('##');\n\n  if (path.length === 1) {\n    // Use a simple direct accessor, as it is probably faster than the more general case\n    // and it was implemented already\n    if (facet.misval.length > 0) {\n      accessor = function (d) {\n        var value = d[path[0]];\n        if (value === undefined || value === null || value in misvals) {\n          return misval;\n        }\n        return value;\n      };\n    } else {\n      accessor = function (d) {\n        var value = d[path[0]];\n        if (value === undefined || value === null) {\n          return misval;\n        }\n        return value;\n      };\n    }\n  } else {\n    // Recursively follow the crumbs to the desired property\n    accessor = function (d) {\n      var i = 0;\n      var value = d;\n\n      for (i = 0; i < path.length; i++) {\n        if (value && value[path[i]] !== undefined) {\n          value = value[path[i]];\n        } else {\n          return misval;\n        }\n      }\n\n      if (value === null || value in misvals) {\n        value = misval;\n      }\n      return value;\n    };\n  }\n\n  return accessor;\n}\n\n/**\n * Base value for given facet, ie. cast to correct type or object.\n * @param {Facet} facet\n * @returns {vaseValueCB} Base value function for this facet\n */\nfunction baseValueFn (facet) {\n  var rawValFn = rawValueFn(facet);\n\n  if (facet.isContinuous) {\n    /*\n     * Continuous facets:\n     * Parse numeric value from base value\n     */\n    return function (d) {\n      var val = parseFloat(rawValFn(d));\n      if (isNaN(val) || val === Infinity || val === -Infinity) {\n        return misval;\n      }\n      return val;\n    };\n  } else if (facet.isCategorial) {\n    return function (d) {\n      var vals = rawValFn(d);\n      if (vals !== misval) {\n        if (vals instanceof Array) {\n          vals.forEach(function (val, i) {\n            vals[i] = val.toString();\n          });\n        } else {\n          vals = vals.toString();\n        }\n        return vals;\n      }\n      return misval;\n    };\n  } else if (facet.isDatetime) {\n    /*\n     * Time parsing:\n     * 1. moment parses the string using the given format, but defaults to\n     *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)\n     * 2. Note that if the string contains timezone information, that is parsed too.\n     * 3. The time is transformed to requested timezone, defaulting the locale default\n     *    when no zone is set\n    */\n    var timeFormat = facet.datetimeTransform.format;\n    if (timeFormat === 'ISO8601') {\n      // use default ISO formatting\n      timeFormat = moment.ISO_8601;\n    }\n\n    var timeZone = facet.datetimeTransform.zone;\n    if (timeZone === 'ISO8601') {\n      // use default locale timezone, get overridden if a string contains a timezone\n      timeZone = moment.tz.guess();\n    } else {\n      timeZone = util.timeZones.get(timeZone, 'description').format;\n    }\n\n    return function (d) {\n      var value = rawValFn(d);\n      if (value !== misval) {\n        var m = moment.tz(value, timeFormat, timeZone);\n        if (m.isValid()) {\n          return m;\n        }\n      }\n      return misval;\n    };\n  } else if (facet.isDuration) {\n    /*\n     * Duration parsing:\n     * 1. If no format is given, the string parsed using\n     *    the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601)\n     * 2. If a format is given, the string is parsed as float and interpreted in the given units\n     */\n    var units = facet.durationTransform.units;\n    if (units === 'ISO8601') {\n      return function (d) {\n        var value = rawValFn(d);\n\n        // parse string if necessary\n        if (value !== misval && typeof value === 'string' && value[0].toLowerCase() === 'p') {\n          value = moment.duration(value);\n        }\n\n        // check for valid duration\n        if (moment.isDuration(value)) {\n          return value;\n        }\n\n        return misval;\n      };\n    } else {\n      units = util.durationUnits.get(units, 'description').momentFormat;\n      return function (d) {\n        var value = rawValFn(d);\n\n        // parse string if necessary\n        if (value !== misval && !isNaN(value)) {\n          // NOTE: isNaN('0') is false, if that gives problems, we could use:\n          // value == +value) { // eslint-disable-line eqeqeq\n          value = moment.duration(parseFloat(value), units);\n        }\n\n        // check for valid duration\n        if (moment.isDuration(value)) {\n          return value;\n        }\n\n        return misval;\n      };\n    }\n  }\n\n  // isCategorial, isText\n  // no casting or constructing necessary, return the raw value\n  return rawValFn;\n}\n\n/**\n * Returns the transformed value from a base value\n *\n * @callback valueCB\n * @param {Object} d Base value\n * @returns {Object} Transformed value\n */\n\n/**\n * Create a function that returns the transformed value for this facet\n * @param {Facet} facet\n * @returns {valueCB} Value function for this facet\n */\nfunction valueFn (facet) {\n  // get base value function\n  var baseValFn = baseValueFn(facet);\n\n  if (facet.isConstant) {\n    return function () { return '1'; };\n  } else if (facet.isContinuous) {\n    // do we have a continuous transform?\n    if (facet.continuousTransform && facet.continuousTransform.type !== 'none') {\n      // yes, use it\n      return function (d) {\n        var val = facet.continuousTransform.transform(parseFloat(baseValFn(d)));\n        if (isNaN(val) || val === Infinity || val === -Infinity) {\n          return misval;\n        }\n        return val;\n      };\n    }\n  } else if (facet.isCategorial) {\n    // do we have a categorial transform?\n    if (facet.categorialTransform && facet.categorialTransform.rules.length > 0) {\n      // yes, use it\n      return function (d) {\n        var val = baseValFn(d);\n        return val === misval ? misval : facet.categorialTransform.transform(baseValFn(d));\n      };\n    }\n  } else if (facet.isDatetime) {\n    // always use the transform, so we do not have to repeat the yes/no transfrom logic here\n    return function (d) {\n      var val = baseValFn(d);\n      return val === misval ? misval : facet.datetimeTransform.transform(val);\n    };\n  } else if (facet.isDuration) {\n    // always use the transform, so we do not have to repeat the yes/no transfrom logic here\n    return function (d) {\n      var val = baseValFn(d);\n      return val === misval ? misval : facet.durationTransform.transform(val);\n    };\n  }\n\n  // no transfrom, return base value\n  return baseValFn;\n}\n\nfunction continuousGroupFn (partition) {\n  return function (d) {\n    if (d === misval) {\n      return d;\n    }\n\n    var ngroups = partition.groups.length;\n    if (d < partition.minval || d > partition.maxval) {\n      return misval;\n    }\n\n    // bins include their lower bound, but not their upper bound\n    var i = 0;\n    while (i < ngroups && d >= partition.groups.models[i].max) {\n      i++;\n    }\n    // special case last bin includes also upperbound d === partition.maxval\n    if (i === ngroups) {\n      return partition.groups.models[i - 1].value;\n    }\n    return partition.groups.models[i].value;\n  };\n}\n\n/*\n * Round the datetime to the specified resolution\n * see:\n * http://momentjs.com/docs/#/manipulating/start-of/\n * http://momentjs.com/docs/#/displaying/as-javascript-date/\n */\nfunction datetimeGroupFn (partition) {\n  var timeStep = util.getDatetimeResolution(partition.minval, partition.maxval);\n  return function (d) {\n    if (d === misval) {\n      return misval;\n    }\n    if (d.isBefore(partition.minval) || d.isAfter(partition.maxval)) {\n      return misval;\n    }\n    var grouped = moment(d).startOf(timeStep).format();\n    return grouped;\n  };\n}\n\n/*\n * Round the duration to the specified resolution\n */\nfunction durationGroupFn (partition) {\n  var timeStep = util.getDurationResolution(partition.minval, partition.maxval);\n  return function (d) {\n    if (d === misval) {\n      return misval;\n    }\n    if (d < partition.minval || d > partition.maxval) {\n      return misval;\n    }\n    var rounded = Math.floor(parseFloat(d.as(timeStep)));\n    return moment.duration(rounded, timeStep).toISOString();\n  };\n}\n\n/*\n * Don't do any grouping; that is done in the step from base value to value.\n * Matching of facet value and group could lead to a different ordering,\n * which is not allowed by crossfilter\n */\nfunction categorialGroupFn (partition) {\n  return function (d) { return d; };\n}\n\n/**\n * Returns the grouped value for a transformed value\n *\n * @callback groupCB\n * @param {Object} d Transformed value\n * @returns {Object} Group\n */\n\n/**\n * Create a function that returns the group value for a partition\n * @param {Partition} partition\n * @returns {cb} Group function for this partition, taking a `Data`\n */\nfunction groupFn (partition) {\n  if (partition.isConstant) {\n    return function () { return '1'; };\n  } else if (partition.isContinuous) {\n    return continuousGroupFn(partition);\n  } else if (partition.isCategorial) {\n    return categorialGroupFn(partition);\n  } else if (partition.isDatetime) {\n    return datetimeGroupFn(partition);\n  } else if (partition.isDuration) {\n    return durationGroupFn(partition);\n  } else if (partition.isText) {\n    return function (d) { return d.toString(); };\n  } else {\n    console.error('Group function not implemented for partition', partition);\n  }\n}\n\nmodule.exports = {\n  rawValueFn: rawValueFn,\n  baseValueFn: baseValueFn,\n  valueFn: valueFn,\n  groupFn: groupFn,\n\n  reduceFn: reduceFn\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRmYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9jcm9zc2ZpbHRlci5qcz8xZjdhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNyb3NzZmlsdGVyIGRhdGFzZXRzXG4gKiBXZSByb3VnaGx5IGZvbGxvdyB0aGUgY3Jvc3NmaWx0ZXIgZGVzaWduIG9mIGRpbWVuc2lvbnMgYW5kIGdyb3VwcywgYnV0IHdlXG4gKiBhZGQgZXh0cmEgc3RlcHMgdG8gYWxsb3cgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBkYXRhLlxuICogMS4gYSBkYXR1bSBpcyB0dXJuZWQgaW50byBhIHJhdyB2YWx1ZSwgaWUuIHN0cmluZyBvciBudW1iZXIgZXRjLiBieSByYXdWYWx1ZUZuXG4gKiAyLiBpdCBpcyB0aGVuIGNhc3QgdG8gdGhlIGNvcnJlY3QgdHlwZSB2YWx1ZSB1c2luZyBiYXNlVmFsRm5cbiAqIDMuIGEgZnVydGhlciB0cmFuc2Zyb20gY2FuIGJlIGFwcGxpZWQgd2l0aCB2YWx1ZUZuXG4gKiA0LiBhIHZhbHVlIGlzIGdyb3VwZWQgdXNpbmcgZ3JvdXBGbjsgdGhpcyB2YWx1ZSBtdXN0IGJlIGVpdGhlciBhIG51bWJlciBvciBhIHN0cmluZy5cbiAqXG4gKiBAbW9kdWxlIGNsaWVudC91dGlsLWNyb3NzZmlsdGVyXG4gKiBAc2VlIHJhd1ZhbHVlRm4sIGJhc2VWYWx1ZUZuLCB2YWx1ZUZuLCBncm91cEZuXG4gKi9cbnZhciBtaXN2YWwgPSByZXF1aXJlKCcuL21pc3ZhbCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3RpbWUnKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdWJncm91cFZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0gY291bnQgVGhlIGNvdW50IG9mIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhpcyBzdWJncm91cFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN1bSBUaGUgc3VtIG9mIGFsbCBlbGVtZW50cyBpbiB0aGlzIHN1Ymdyb3VwXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgYSBTdWJncm91cFZhbHVlIHRvIGEgc2luZ2xlIG51bWJlclxuICpcbiAqIEBjYWxsYmFjayByZWR1Y2VDQlxuICogQHBhcmFtIHtTdWJncm91cFZhbHVlfSBkIFN1Ymdyb3VwVmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlZHVjZWQgdmFsdWVcbiAqL1xuLyoqXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmdXJ0aGVyIHJlZHVjaW5nIHRoZSBjcm9zc2ZpbHRlciBncm91cFxuICogdG8gYSBzaW5nbGUgdmFsdWUsIGRlcGVuZGluZyBvbiBzdW0vY291bnQvYXZlcmFnZSBzZXR0aW5ncyBvZlxuICogdGhlIEFnZ3JlZ2F0ZSBjbGFzcy5cbiAqIEBwYXJhbSB7QWdncmVnYXRlfSBmYWNldCAtIFRoZSBBZ2dyZWdhdGUgY2xhc3MgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcmVkdWN0aW9uIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Y2J9IFRoZSByZXF1aXJlZCByZWR1Y3Rpb24gZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVkdWNlRm4gKGFnZ3JlZ2F0ZSkge1xuICBpZiAoYWdncmVnYXRlLmRvU3VtKSB7XG4gICAgLyoqXG4gICAgICogQGNhbGxiYWNrIHN1Ymdyb3VwU3VtXG4gICAgICogQHBhcmFtIHtTdWJncm91cFZhbHVlfSBkXG4gICAgICogQHJldHVybnMge251bWJlcn0gc3VtXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoZCA9PT0gbWlzdmFsIHx8IGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgICAgaWYgKGQuY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkLnN1bTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhZ2dyZWdhdGUuZG9Db3VudCkge1xuICAgIC8qKlxuICAgICAqIEBjYWxsYmFjayBzdWJncm91cENvdW50XG4gICAgICogQHBhcmFtIHtTdWJncm91cFZhbHVlfSBkXG4gICAgICogQHJldHVybnMge251bWJlcn0gY291bnRcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwgfHwgZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG4gICAgICBpZiAoZC5jb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGQuY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYWdncmVnYXRlLmRvQXZlcmFnZSkge1xuICAgIC8qKlxuICAgICAqIEBjYWxsYmFjayBzdWJncm91cEF2ZXJhZ2VcbiAgICAgKiBAcGFyYW0ge1N1Ymdyb3VwVmFsdWV9IGRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBkLnN1bS9kLmNvdW50XG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoZCA9PT0gbWlzdmFsIHx8IGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZC5jb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGQuc3VtIC8gZC5jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhZ2dyZWdhdGUuZG9TdGRkZXYpIHtcbiAgICAvKipcbiAgICAgKiBAY2FsbGJhY2sgc3ViZ3JvdXBTdGRkZXZcbiAgICAgKiBAcGFyYW0ge1N1Ymdyb3VwVmFsdWV9IGRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzdGRkZXYoZClcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChkID09PSBtaXN2YWwgfHwgZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFxcc3VtX2kgKHhfaSAtIFxcYmFyIHgpXjIgPVxuICAgICAgLy8gICBcXHN1bV9pICh4X2leMiAtIDJ4X2lcXGJhciB4ICsgKFxcYmFyIHgpXjIpID1cbiAgICAgIC8vICAgXFxzdW1faSAoeF9pXjIpIC0gMiBOIChcXGJhciB4KV4yICsgTihcXGJhciB4KV4yID1cbiAgICAgIC8vICAgXFxzdW1faSAoeF9pXjIpIC0gTiAoXFxiYXIgeCleMlxuICAgICAgaWYgKGQuY291bnQgPiAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKGQuc3Vtc3F1YXJlcyAtIChkLnN1bSAqIGQuc3VtIC8gZC5jb3VudCkpIC8gKGQuY291bnQgLSAxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb25zb2xlLmVycm9yKCdPcGVyYXRpb24gbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEFnZ3JlZ2F0ZScsIGFnZ3JlZ2F0ZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkID09PSBtaXN2YWwgfHwgZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cbiAgICBpZiAoZC5jb3VudCA+IDApIHtcbiAgICAgIHJldHVybiBkLmNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIEZhY2V0IHRyYW5zZm9ybSB1dGlsaXR5IGZ1bmN0aW9uXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgdmFsdWUgZm9yIGEgZGF0dW1cbiAqXG4gKiBAY2FsbGJhY2sgYmFzZVZhbHVlQ0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIFJhdyBkYXRhIHJlY29yZFxuICogQHJldHVybnMge09iamVjdH0gYmFzZSB2YWx1ZVxuICovXG5cbi8qKlxuICogUmF3IHZhbHVlIGZvciBnaXZlbiBmYWNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqIEByZXR1cm5zIHtyYXdWYWx1ZUNCfSBSYXcgdmFsdWUgZnVuY3Rpb24gZm9yIHRoaXMgZmFjZXRcbiAqL1xuZnVuY3Rpb24gcmF3VmFsdWVGbiAoZmFjZXQpIHtcbiAgdmFyIGFjY2Vzc29yO1xuXG4gIC8vIEFycmF5IGRpbWVuc2lvbnMgaGF2ZSBhIFtdIGFwcGVuZGVkIHRvIHRoZSBhY2Nlc3NvcixcbiAgLy8gcmVtb3ZlIGl0IHRvIGdldCB0byB0aGUgYWN0dWFsIGFjY2Vzc29yXG4gIHZhciBwYXRoID0gZmFjZXQuYWNjZXNzb3I7XG4gIGlmIChwYXRoLm1hdGNoKC9cXFtdJC8pKSB7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMik7XG4gIH1cblxuICB2YXIgbWlzdmFscyA9IHt9O1xuICBmYWNldC5taXN2YWwuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgbWlzdmFsc1t2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgLy8gQWNjZXNzIG5lc3RlZCBwcm9wZXJ0aWVzIHZpYSBhIGRvdWJsZSBoYXNoIHNpZ24sIHRoaXMgdG8gcHJldmVudCBjb2xsaXNpb24gd2l0aCByZWd1bGFyIGtleXM7IGZpLiAncGVyc29uLm5hbWUnXG4gIHBhdGggPSBwYXRoLnNwbGl0KCcjIycpO1xuXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFVzZSBhIHNpbXBsZSBkaXJlY3QgYWNjZXNzb3IsIGFzIGl0IGlzIHByb2JhYmx5IGZhc3RlciB0aGFuIHRoZSBtb3JlIGdlbmVyYWwgY2FzZVxuICAgIC8vIGFuZCBpdCB3YXMgaW1wbGVtZW50ZWQgYWxyZWFkeVxuICAgIGlmIChmYWNldC5taXN2YWwubGVuZ3RoID4gMCkge1xuICAgICAgYWNjZXNzb3IgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkW3BhdGhbMF1dO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSBpbiBtaXN2YWxzKSB7XG4gICAgICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nlc3NvciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRbcGF0aFswXV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZWN1cnNpdmVseSBmb2xsb3cgdGhlIGNydW1icyB0byB0aGUgZGVzaXJlZCBwcm9wZXJ0eVxuICAgIGFjY2Vzc29yID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB2YWx1ZSA9IGQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVtwYXRoW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtwYXRoW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSBpbiBtaXN2YWxzKSB7XG4gICAgICAgIHZhbHVlID0gbWlzdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gYWNjZXNzb3I7XG59XG5cbi8qKlxuICogQmFzZSB2YWx1ZSBmb3IgZ2l2ZW4gZmFjZXQsIGllLiBjYXN0IHRvIGNvcnJlY3QgdHlwZSBvciBvYmplY3QuXG4gKiBAcGFyYW0ge0ZhY2V0fSBmYWNldFxuICogQHJldHVybnMge3Zhc2VWYWx1ZUNCfSBCYXNlIHZhbHVlIGZ1bmN0aW9uIGZvciB0aGlzIGZhY2V0XG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZUZuIChmYWNldCkge1xuICB2YXIgcmF3VmFsRm4gPSByYXdWYWx1ZUZuKGZhY2V0KTtcblxuICBpZiAoZmFjZXQuaXNDb250aW51b3VzKSB7XG4gICAgLypcbiAgICAgKiBDb250aW51b3VzIGZhY2V0czpcbiAgICAgKiBQYXJzZSBudW1lcmljIHZhbHVlIGZyb20gYmFzZSB2YWx1ZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHZhbCA9IHBhcnNlRmxvYXQocmF3VmFsRm4oZCkpO1xuICAgICAgaWYgKGlzTmFOKHZhbCkgfHwgdmFsID09PSBJbmZpbml0eSB8fCB2YWwgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZhY2V0LmlzQ2F0ZWdvcmlhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHZhbHMgPSByYXdWYWxGbihkKTtcbiAgICAgIGlmICh2YWxzICE9PSBtaXN2YWwpIHtcbiAgICAgICAgaWYgKHZhbHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHZhbHMuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICB2YWxzW2ldID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFscyA9IHZhbHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFscztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmYWNldC5pc0RhdGV0aW1lKSB7XG4gICAgLypcbiAgICAgKiBUaW1lIHBhcnNpbmc6XG4gICAgICogMS4gbW9tZW50IHBhcnNlcyB0aGUgc3RyaW5nIHVzaW5nIHRoZSBnaXZlbiBmb3JtYXQsIGJ1dCBkZWZhdWx0cyB0b1xuICAgICAqICAgIHRoZSBbSVNPIDg2MDEgc3RhbmRhcmRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxKVxuICAgICAqIDIuIE5vdGUgdGhhdCBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIHRpbWV6b25lIGluZm9ybWF0aW9uLCB0aGF0IGlzIHBhcnNlZCB0b28uXG4gICAgICogMy4gVGhlIHRpbWUgaXMgdHJhbnNmb3JtZWQgdG8gcmVxdWVzdGVkIHRpbWV6b25lLCBkZWZhdWx0aW5nIHRoZSBsb2NhbGUgZGVmYXVsdFxuICAgICAqICAgIHdoZW4gbm8gem9uZSBpcyBzZXRcbiAgICAqL1xuICAgIHZhciB0aW1lRm9ybWF0ID0gZmFjZXQuZGF0ZXRpbWVUcmFuc2Zvcm0uZm9ybWF0O1xuICAgIGlmICh0aW1lRm9ybWF0ID09PSAnSVNPODYwMScpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IElTTyBmb3JtYXR0aW5nXG4gICAgICB0aW1lRm9ybWF0ID0gbW9tZW50LklTT184NjAxO1xuICAgIH1cblxuICAgIHZhciB0aW1lWm9uZSA9IGZhY2V0LmRhdGV0aW1lVHJhbnNmb3JtLnpvbmU7XG4gICAgaWYgKHRpbWVab25lID09PSAnSVNPODYwMScpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IGxvY2FsZSB0aW1lem9uZSwgZ2V0IG92ZXJyaWRkZW4gaWYgYSBzdHJpbmcgY29udGFpbnMgYSB0aW1lem9uZVxuICAgICAgdGltZVpvbmUgPSBtb21lbnQudHouZ3Vlc3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZVpvbmUgPSB1dGlsLnRpbWVab25lcy5nZXQodGltZVpvbmUsICdkZXNjcmlwdGlvbicpLmZvcm1hdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJhd1ZhbEZuKGQpO1xuICAgICAgaWYgKHZhbHVlICE9PSBtaXN2YWwpIHtcbiAgICAgICAgdmFyIG0gPSBtb21lbnQudHoodmFsdWUsIHRpbWVGb3JtYXQsIHRpbWVab25lKTtcbiAgICAgICAgaWYgKG0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmYWNldC5pc0R1cmF0aW9uKSB7XG4gICAgLypcbiAgICAgKiBEdXJhdGlvbiBwYXJzaW5nOlxuICAgICAqIDEuIElmIG5vIGZvcm1hdCBpcyBnaXZlbiwgdGhlIHN0cmluZyBwYXJzZWQgdXNpbmdcbiAgICAgKiAgICB0aGUgW0lTTyA4NjAxIHN0YW5kYXJkXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSlcbiAgICAgKiAyLiBJZiBhIGZvcm1hdCBpcyBnaXZlbiwgdGhlIHN0cmluZyBpcyBwYXJzZWQgYXMgZmxvYXQgYW5kIGludGVycHJldGVkIGluIHRoZSBnaXZlbiB1bml0c1xuICAgICAqL1xuICAgIHZhciB1bml0cyA9IGZhY2V0LmR1cmF0aW9uVHJhbnNmb3JtLnVuaXRzO1xuICAgIGlmICh1bml0cyA9PT0gJ0lTTzg2MDEnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmF3VmFsRm4oZCk7XG5cbiAgICAgICAgLy8gcGFyc2Ugc3RyaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAodmFsdWUgIT09IG1pc3ZhbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuICAgICAgICAgIHZhbHVlID0gbW9tZW50LmR1cmF0aW9uKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciB2YWxpZCBkdXJhdGlvblxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gdXRpbC5kdXJhdGlvblVuaXRzLmdldCh1bml0cywgJ2Rlc2NyaXB0aW9uJykubW9tZW50Rm9ybWF0O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJhd1ZhbEZuKGQpO1xuXG4gICAgICAgIC8vIHBhcnNlIHN0cmluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHZhbHVlICE9PSBtaXN2YWwgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIC8vIE5PVEU6IGlzTmFOKCcwJykgaXMgZmFsc2UsIGlmIHRoYXQgZ2l2ZXMgcHJvYmxlbXMsIHdlIGNvdWxkIHVzZTpcbiAgICAgICAgICAvLyB2YWx1ZSA9PSArdmFsdWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICB2YWx1ZSA9IG1vbWVudC5kdXJhdGlvbihwYXJzZUZsb2F0KHZhbHVlKSwgdW5pdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHZhbGlkIGR1cmF0aW9uXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBpc0NhdGVnb3JpYWwsIGlzVGV4dFxuICAvLyBubyBjYXN0aW5nIG9yIGNvbnN0cnVjdGluZyBuZWNlc3NhcnksIHJldHVybiB0aGUgcmF3IHZhbHVlXG4gIHJldHVybiByYXdWYWxGbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBmcm9tIGEgYmFzZSB2YWx1ZVxuICpcbiAqIEBjYWxsYmFjayB2YWx1ZUNCXG4gKiBAcGFyYW0ge09iamVjdH0gZCBCYXNlIHZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUcmFuc2Zvcm1lZCB2YWx1ZVxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBmb3IgdGhpcyBmYWNldFxuICogQHBhcmFtIHtGYWNldH0gZmFjZXRcbiAqIEByZXR1cm5zIHt2YWx1ZUNCfSBWYWx1ZSBmdW5jdGlvbiBmb3IgdGhpcyBmYWNldFxuICovXG5mdW5jdGlvbiB2YWx1ZUZuIChmYWNldCkge1xuICAvLyBnZXQgYmFzZSB2YWx1ZSBmdW5jdGlvblxuICB2YXIgYmFzZVZhbEZuID0gYmFzZVZhbHVlRm4oZmFjZXQpO1xuXG4gIGlmIChmYWNldC5pc0NvbnN0YW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuICcxJzsgfTtcbiAgfSBlbHNlIGlmIChmYWNldC5pc0NvbnRpbnVvdXMpIHtcbiAgICAvLyBkbyB3ZSBoYXZlIGEgY29udGludW91cyB0cmFuc2Zvcm0/XG4gICAgaWYgKGZhY2V0LmNvbnRpbnVvdXNUcmFuc2Zvcm0gJiYgZmFjZXQuY29udGludW91c1RyYW5zZm9ybS50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgIC8vIHllcywgdXNlIGl0XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IGZhY2V0LmNvbnRpbnVvdXNUcmFuc2Zvcm0udHJhbnNmb3JtKHBhcnNlRmxvYXQoYmFzZVZhbEZuKGQpKSk7XG4gICAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA9PT0gSW5maW5pdHkgfHwgdmFsID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gbWlzdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChmYWNldC5pc0NhdGVnb3JpYWwpIHtcbiAgICAvLyBkbyB3ZSBoYXZlIGEgY2F0ZWdvcmlhbCB0cmFuc2Zvcm0/XG4gICAgaWYgKGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0gJiYgZmFjZXQuY2F0ZWdvcmlhbFRyYW5zZm9ybS5ydWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyB5ZXMsIHVzZSBpdFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciB2YWwgPSBiYXNlVmFsRm4oZCk7XG4gICAgICAgIHJldHVybiB2YWwgPT09IG1pc3ZhbCA/IG1pc3ZhbCA6IGZhY2V0LmNhdGVnb3JpYWxUcmFuc2Zvcm0udHJhbnNmb3JtKGJhc2VWYWxGbihkKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChmYWNldC5pc0RhdGV0aW1lKSB7XG4gICAgLy8gYWx3YXlzIHVzZSB0aGUgdHJhbnNmb3JtLCBzbyB3ZSBkbyBub3QgaGF2ZSB0byByZXBlYXQgdGhlIHllcy9ubyB0cmFuc2Zyb20gbG9naWMgaGVyZVxuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIHZhbCA9IGJhc2VWYWxGbihkKTtcbiAgICAgIHJldHVybiB2YWwgPT09IG1pc3ZhbCA/IG1pc3ZhbCA6IGZhY2V0LmRhdGV0aW1lVHJhbnNmb3JtLnRyYW5zZm9ybSh2YWwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZmFjZXQuaXNEdXJhdGlvbikge1xuICAgIC8vIGFsd2F5cyB1c2UgdGhlIHRyYW5zZm9ybSwgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVwZWF0IHRoZSB5ZXMvbm8gdHJhbnNmcm9tIGxvZ2ljIGhlcmVcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciB2YWwgPSBiYXNlVmFsRm4oZCk7XG4gICAgICByZXR1cm4gdmFsID09PSBtaXN2YWwgPyBtaXN2YWwgOiBmYWNldC5kdXJhdGlvblRyYW5zZm9ybS50cmFuc2Zvcm0odmFsKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gbm8gdHJhbnNmcm9tLCByZXR1cm4gYmFzZSB2YWx1ZVxuICByZXR1cm4gYmFzZVZhbEZuO1xufVxuXG5mdW5jdGlvbiBjb250aW51b3VzR3JvdXBGbiAocGFydGl0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIHZhciBuZ3JvdXBzID0gcGFydGl0aW9uLmdyb3Vwcy5sZW5ndGg7XG4gICAgaWYgKGQgPCBwYXJ0aXRpb24ubWludmFsIHx8IGQgPiBwYXJ0aXRpb24ubWF4dmFsKSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cblxuICAgIC8vIGJpbnMgaW5jbHVkZSB0aGVpciBsb3dlciBib3VuZCwgYnV0IG5vdCB0aGVpciB1cHBlciBib3VuZFxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG5ncm91cHMgJiYgZCA+PSBwYXJ0aXRpb24uZ3JvdXBzLm1vZGVsc1tpXS5tYXgpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgLy8gc3BlY2lhbCBjYXNlIGxhc3QgYmluIGluY2x1ZGVzIGFsc28gdXBwZXJib3VuZCBkID09PSBwYXJ0aXRpb24ubWF4dmFsXG4gICAgaWYgKGkgPT09IG5ncm91cHMpIHtcbiAgICAgIHJldHVybiBwYXJ0aXRpb24uZ3JvdXBzLm1vZGVsc1tpIC0gMV0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aXRpb24uZ3JvdXBzLm1vZGVsc1tpXS52YWx1ZTtcbiAgfTtcbn1cblxuLypcbiAqIFJvdW5kIHRoZSBkYXRldGltZSB0byB0aGUgc3BlY2lmaWVkIHJlc29sdXRpb25cbiAqIHNlZTpcbiAqIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL21hbmlwdWxhdGluZy9zdGFydC1vZi9cbiAqIGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvYXMtamF2YXNjcmlwdC1kYXRlL1xuICovXG5mdW5jdGlvbiBkYXRldGltZUdyb3VwRm4gKHBhcnRpdGlvbikge1xuICB2YXIgdGltZVN0ZXAgPSB1dGlsLmdldERhdGV0aW1lUmVzb2x1dGlvbihwYXJ0aXRpb24ubWludmFsLCBwYXJ0aXRpb24ubWF4dmFsKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQgPT09IG1pc3ZhbCkge1xuICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICB9XG4gICAgaWYgKGQuaXNCZWZvcmUocGFydGl0aW9uLm1pbnZhbCkgfHwgZC5pc0FmdGVyKHBhcnRpdGlvbi5tYXh2YWwpKSB7XG4gICAgICByZXR1cm4gbWlzdmFsO1xuICAgIH1cbiAgICB2YXIgZ3JvdXBlZCA9IG1vbWVudChkKS5zdGFydE9mKHRpbWVTdGVwKS5mb3JtYXQoKTtcbiAgICByZXR1cm4gZ3JvdXBlZDtcbiAgfTtcbn1cblxuLypcbiAqIFJvdW5kIHRoZSBkdXJhdGlvbiB0byB0aGUgc3BlY2lmaWVkIHJlc29sdXRpb25cbiAqL1xuZnVuY3Rpb24gZHVyYXRpb25Hcm91cEZuIChwYXJ0aXRpb24pIHtcbiAgdmFyIHRpbWVTdGVwID0gdXRpbC5nZXREdXJhdGlvblJlc29sdXRpb24ocGFydGl0aW9uLm1pbnZhbCwgcGFydGl0aW9uLm1heHZhbCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkID09PSBtaXN2YWwpIHtcbiAgICAgIHJldHVybiBtaXN2YWw7XG4gICAgfVxuICAgIGlmIChkIDwgcGFydGl0aW9uLm1pbnZhbCB8fCBkID4gcGFydGl0aW9uLm1heHZhbCkge1xuICAgICAgcmV0dXJuIG1pc3ZhbDtcbiAgICB9XG4gICAgdmFyIHJvdW5kZWQgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQoZC5hcyh0aW1lU3RlcCkpKTtcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHJvdW5kZWQsIHRpbWVTdGVwKS50b0lTT1N0cmluZygpO1xuICB9O1xufVxuXG4vKlxuICogRG9uJ3QgZG8gYW55IGdyb3VwaW5nOyB0aGF0IGlzIGRvbmUgaW4gdGhlIHN0ZXAgZnJvbSBiYXNlIHZhbHVlIHRvIHZhbHVlLlxuICogTWF0Y2hpbmcgb2YgZmFjZXQgdmFsdWUgYW5kIGdyb3VwIGNvdWxkIGxlYWQgdG8gYSBkaWZmZXJlbnQgb3JkZXJpbmcsXG4gKiB3aGljaCBpcyBub3QgYWxsb3dlZCBieSBjcm9zc2ZpbHRlclxuICovXG5mdW5jdGlvbiBjYXRlZ29yaWFsR3JvdXBGbiAocGFydGl0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZDsgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBncm91cGVkIHZhbHVlIGZvciBhIHRyYW5zZm9ybWVkIHZhbHVlXG4gKlxuICogQGNhbGxiYWNrIGdyb3VwQ0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBkIFRyYW5zZm9ybWVkIHZhbHVlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBHcm91cFxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBncm91cCB2YWx1ZSBmb3IgYSBwYXJ0aXRpb25cbiAqIEBwYXJhbSB7UGFydGl0aW9ufSBwYXJ0aXRpb25cbiAqIEByZXR1cm5zIHtjYn0gR3JvdXAgZnVuY3Rpb24gZm9yIHRoaXMgcGFydGl0aW9uLCB0YWtpbmcgYSBgRGF0YWBcbiAqL1xuZnVuY3Rpb24gZ3JvdXBGbiAocGFydGl0aW9uKSB7XG4gIGlmIChwYXJ0aXRpb24uaXNDb25zdGFudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiAnMSc7IH07XG4gIH0gZWxzZSBpZiAocGFydGl0aW9uLmlzQ29udGludW91cykge1xuICAgIHJldHVybiBjb250aW51b3VzR3JvdXBGbihwYXJ0aXRpb24pO1xuICB9IGVsc2UgaWYgKHBhcnRpdGlvbi5pc0NhdGVnb3JpYWwpIHtcbiAgICByZXR1cm4gY2F0ZWdvcmlhbEdyb3VwRm4ocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNEYXRldGltZSkge1xuICAgIHJldHVybiBkYXRldGltZUdyb3VwRm4ocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNEdXJhdGlvbikge1xuICAgIHJldHVybiBkdXJhdGlvbkdyb3VwRm4ocGFydGl0aW9uKTtcbiAgfSBlbHNlIGlmIChwYXJ0aXRpb24uaXNUZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnRvU3RyaW5nKCk7IH07XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignR3JvdXAgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkIGZvciBwYXJ0aXRpb24nLCBwYXJ0aXRpb24pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByYXdWYWx1ZUZuOiByYXdWYWx1ZUZuLFxuICBiYXNlVmFsdWVGbjogYmFzZVZhbHVlRm4sXG4gIHZhbHVlRm46IHZhbHVlRm4sXG4gIGdyb3VwRm46IGdyb3VwRm4sXG5cbiAgcmVkdWNlRm46IHJlZHVjZUZuXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///adfa\n")},b123:function(module,exports,__webpack_require__){eval("/**\n * DurationTransfrom defines a transformation on duration data\n *\n * @class DurationTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\nvar util = __webpack_require__(/*! ../util/time */ \"d45b\");\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    /**\n     * Units of the duration\n     *\n     * @memberof! DurationTransform\n     * @type {string}\n     */\n    units: ['string', true, 'ISO8601'],\n\n    /**\n     * For durations, transforms duration to these units\n     *\n     * @memberof! DurationTransform\n     * @type {string}\n     */\n    transformedUnits: ['string', true, 'ISO8601'],\n\n    /**\n     * Transform the date to this timezone.\n     *\n     * @memberof! DatetimeTransform\n     * @type {string}\n     */\n    transformedZone: ['string', true, 'ISO8601'],\n\n    /**\n     * Controls conversion to datetime by adding this date\n     *\n     * @memberof! DurationTransform\n     * @type {string}\n     */\n    transformedReference: 'string'\n  },\n  derived: {\n    /**\n     * Reference momentjs for duration <-> datetime conversion\n     *\n     * @type {moment}\n     * @memberof! DurationTransform\n     */\n    referenceMoment: {\n      deps: ['transformedReference', 'transformedZone'],\n      fn: function () {\n        var tz;\n        if (this.transformedZone === 'ISO8601') {\n          tz = moment.tz.guess();\n        } else {\n          var timeZone = util.timeZones.get(this.transformedZone, 'description');\n          if (timeZone && timeZone.format) {\n            tz = timeZone.format;\n          } else {\n            tz = moment.tz.guess();\n          }\n        }\n\n        if (this.transformedReference) {\n          return moment.tz(this.transformedReference, tz);\n        }\n        return null;\n      }\n    },\n    /**\n     * The type of the facet after the transformation has been applied\n     *\n     * @type {string}\n     * @memberof! DurationTransform\n     */\n    transformedType: {\n      deps: ['transformedFormat', 'transformedReference', 'transformedZone'],\n      fn: function () {\n        if (this.referenceMoment) {\n          return 'datetime';\n        } else if (this.transformedUnits !== 'ISO8601') {\n          return 'continuous';\n        } else {\n          return 'duration';\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minium value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMin: {\n      deps: ['transformedType'],\n      fn: function () {\n        var facet = this.parent;\n        if (this.transformedType === 'datetime') {\n          return this.transform(facet.minval);\n        } else if (this.transformedType === 'continuous') {\n          return this.transform(facet.minval);\n        } else {\n          return facet.minval;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMax: {\n      deps: ['transformedType'],\n      fn: function () {\n        var facet = this.parent;\n        if (this.transformedType === 'datetime') {\n          return this.transform(facet.maxval);\n        } else if (this.transformedType === 'continuous') {\n          return this.transform(facet.maxval);\n        } else {\n          return facet.maxval;\n        }\n      },\n      cache: false\n    },\n    /**\n     * The minimum value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMinAsText: {\n      deps: ['transformedMin', 'transformedType'],\n      fn: function () {\n        var minval = this.transformedMin;\n        if (this.transformedType === 'datetime') {\n          return minval.format();\n        } else {\n          return minval.toString();\n        }\n      },\n      cache: false\n    },\n    /**\n     * The maximum value this facet can take, after the transformation has been applied\n     *\n     * @type {number}\n     * @memberof! DurationTransform\n     */\n    transformedMaxAsText: {\n      deps: ['transformedMax', 'transformedType'],\n      fn: function () {\n        var maxval = this.transformedMax;\n        if (this.transformedType === 'datetime') {\n          return maxval.format();\n        } else {\n          return maxval.toString();\n        }\n      },\n      cache: false\n    }\n  },\n\n  /**\n   * Apply the configured transformation to this Facet's value\n   *\n   * @function\n   * @memberof! DurationTransform\n   * @param {Object} inval momentjs duration\n   * @returns {Object} outval momentjs duration or datetime\n   */\n  transform: function transform (inval) {\n    var units;\n    if (this.referenceMoment) {\n      // duration -> datetime\n      return this.referenceMoment.clone().add(inval);\n    } else if (this.transformedUnits !== 'ISO8601') {\n      // duration -> continuous\n      units = util.durationUnits.get(this.transformedUnits, 'description').momentFormat;\n      return inval.as(units);\n    } else {\n      // no change\n      return inval;\n    }\n  },\n  reset: function () {\n    this.unset(['zone', 'transformedFormat', 'transformedZone', 'transformedReference']);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjEyMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvZHVyYXRpb24tdHJhbnNmb3JtLmpzPzJkZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEdXJhdGlvblRyYW5zZnJvbSBkZWZpbmVzIGEgdHJhbnNmb3JtYXRpb24gb24gZHVyYXRpb24gZGF0YVxuICpcbiAqIEBjbGFzcyBEdXJhdGlvblRyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQtdGltZXpvbmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBVbml0cyBvZiB0aGUgZHVyYXRpb25cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25UcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHVuaXRzOiBbJ3N0cmluZycsIHRydWUsICdJU084NjAxJ10sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgZHVyYXRpb25zLCB0cmFuc2Zvcm1zIGR1cmF0aW9uIHRvIHRoZXNlIHVuaXRzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFVuaXRzOiBbJ3N0cmluZycsIHRydWUsICdJU084NjAxJ10sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGRhdGUgdG8gdGhpcyB0aW1lem9uZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiEgRGF0ZXRpbWVUcmFuc2Zvcm1cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkWm9uZTogWydzdHJpbmcnLCB0cnVlLCAnSVNPODYwMSddLFxuXG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgY29udmVyc2lvbiB0byBkYXRldGltZSBieSBhZGRpbmcgdGhpcyBkYXRlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZFJlZmVyZW5jZTogJ3N0cmluZydcbiAgfSxcbiAgZGVyaXZlZDoge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSBtb21lbnRqcyBmb3IgZHVyYXRpb24gPC0+IGRhdGV0aW1lIGNvbnZlcnNpb25cbiAgICAgKlxuICAgICAqIEB0eXBlIHttb21lbnR9XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblRyYW5zZm9ybVxuICAgICAqL1xuICAgIHJlZmVyZW5jZU1vbWVudDoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZFJlZmVyZW5jZScsICd0cmFuc2Zvcm1lZFpvbmUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ejtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRab25lID09PSAnSVNPODYwMScpIHtcbiAgICAgICAgICB0eiA9IG1vbWVudC50ei5ndWVzcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0aW1lWm9uZSA9IHV0aWwudGltZVpvbmVzLmdldCh0aGlzLnRyYW5zZm9ybWVkWm9uZSwgJ2Rlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgaWYgKHRpbWVab25lICYmIHRpbWVab25lLmZvcm1hdCkge1xuICAgICAgICAgICAgdHogPSB0aW1lWm9uZS5mb3JtYXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR6ID0gbW9tZW50LnR6Lmd1ZXNzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50LnR6KHRoaXMudHJhbnNmb3JtZWRSZWZlcmVuY2UsIHR6KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBmYWNldCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRUeXBlOiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkRm9ybWF0JywgJ3RyYW5zZm9ybWVkUmVmZXJlbmNlJywgJ3RyYW5zZm9ybWVkWm9uZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlTW9tZW50KSB7XG4gICAgICAgICAgcmV0dXJuICdkYXRldGltZSc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2Zvcm1lZFVuaXRzICE9PSAnSVNPODYwMScpIHtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVvdXMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnZHVyYXRpb24nO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25UcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1pbjoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZFR5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmYWNldCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oZmFjZXQubWludmFsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2NvbnRpbnVvdXMnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGZhY2V0Lm1pbnZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhY2V0Lm1pbnZhbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdmFsdWUgdGhpcyBmYWNldCBjYW4gdGFrZSwgYWZ0ZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWVkTWF4OiB7XG4gICAgICBkZXBzOiBbJ3RyYW5zZm9ybWVkVHlwZSddLFxuICAgICAgZm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZhY2V0ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybWVkVHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShmYWNldC5tYXh2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNmb3JtZWRUeXBlID09PSAnY29udGludW91cycpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oZmFjZXQubWF4dmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFjZXQubWF4dmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FjaGU6IGZhbHNlXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSB2YWx1ZSB0aGlzIGZhY2V0IGNhbiB0YWtlLCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb24gaGFzIGJlZW4gYXBwbGllZFxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAgICovXG4gICAgdHJhbnNmb3JtZWRNaW5Bc1RleHQ6IHtcbiAgICAgIGRlcHM6IFsndHJhbnNmb3JtZWRNaW4nLCAndHJhbnNmb3JtZWRUeXBlJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWludmFsID0gdGhpcy50cmFuc2Zvcm1lZE1pbjtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtZWRUeXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1pbnZhbC5mb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWludmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWNoZTogZmFsc2VcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlIHRoaXMgZmFjZXQgY2FuIHRha2UsIGFmdGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25UcmFuc2Zvcm1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1lZE1heEFzVGV4dDoge1xuICAgICAgZGVwczogWyd0cmFuc2Zvcm1lZE1heCcsICd0cmFuc2Zvcm1lZFR5cGUnXSxcbiAgICAgIGZuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXh2YWwgPSB0aGlzLnRyYW5zZm9ybWVkTWF4O1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lZFR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICByZXR1cm4gbWF4dmFsLmZvcm1hdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXh2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhY2hlOiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhlIGNvbmZpZ3VyZWQgdHJhbnNmb3JtYXRpb24gdG8gdGhpcyBGYWNldCdzIHZhbHVlXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YhIER1cmF0aW9uVHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnZhbCBtb21lbnRqcyBkdXJhdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvdXR2YWwgbW9tZW50anMgZHVyYXRpb24gb3IgZGF0ZXRpbWVcbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtIChpbnZhbCkge1xuICAgIHZhciB1bml0cztcbiAgICBpZiAodGhpcy5yZWZlcmVuY2VNb21lbnQpIHtcbiAgICAgIC8vIGR1cmF0aW9uIC0+IGRhdGV0aW1lXG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VNb21lbnQuY2xvbmUoKS5hZGQoaW52YWwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2Zvcm1lZFVuaXRzICE9PSAnSVNPODYwMScpIHtcbiAgICAgIC8vIGR1cmF0aW9uIC0+IGNvbnRpbnVvdXNcbiAgICAgIHVuaXRzID0gdXRpbC5kdXJhdGlvblVuaXRzLmdldCh0aGlzLnRyYW5zZm9ybWVkVW5pdHMsICdkZXNjcmlwdGlvbicpLm1vbWVudEZvcm1hdDtcbiAgICAgIHJldHVybiBpbnZhbC5hcyh1bml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGNoYW5nZVxuICAgICAgcmV0dXJuIGludmFsO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVuc2V0KFsnem9uZScsICd0cmFuc2Zvcm1lZEZvcm1hdCcsICd0cmFuc2Zvcm1lZFpvbmUnLCAndHJhbnNmb3JtZWRSZWZlcmVuY2UnXSk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///b123\n")},b28e:function(module,exports,__webpack_require__){eval('var crossfilter_identity = __webpack_require__(/*! ./identity */ "55a3");\nvar xFilterInsertionsort = __webpack_require__(/*! ./insertionsort */ "753f");\n\n// Algorithm designed by Vladimir Yaroslavskiy.\n// Implementation based on the Dart project; see NOTICE and AUTHORS for details.\n\nfunction quicksort_by(f) {\n  var insertionsort = xFilterInsertionsort.by(f);\n\n  function sort(a, lo, hi) {\n    return (hi - lo < quicksort_sizeThreshold\n        ? insertionsort\n        : quicksort)(a, lo, hi);\n  }\n\n  function quicksort(a, lo, hi) {\n    // Compute the two pivots by looking at 5 elements.\n    var sixth = (hi - lo) / 6 | 0,\n        i1 = lo + sixth,\n        i5 = hi - 1 - sixth,\n        i3 = lo + hi - 1 >> 1,  // The midpoint.\n        i2 = i3 - sixth,\n        i4 = i3 + sixth;\n\n    var e1 = a[i1], x1 = f(e1),\n        e2 = a[i2], x2 = f(e2),\n        e3 = a[i3], x3 = f(e3),\n        e4 = a[i4], x4 = f(e4),\n        e5 = a[i5], x5 = f(e5);\n\n    var t;\n\n    // Sort the selected 5 elements using a sorting network.\n    if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n    if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n    if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n    if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n\n    var pivot1 = e2, pivotValue1 = x2,\n        pivot2 = e4, pivotValue2 = x4;\n\n    // e2 and e4 have been saved in the pivot variables. They will be written\n    // back, once the partitioning is finished.\n    a[i1] = e1;\n    a[i2] = a[lo];\n    a[i3] = e3;\n    a[i4] = a[hi - 1];\n    a[i5] = e5;\n\n    var less = lo + 1,   // First element in the middle partition.\n        great = hi - 2;  // Last element in the middle partition.\n\n    // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n    // Object.prototype.valueOf; == and === do not, so in order to be consistent\n    // with natural order (such as for Date objects), we must do two compares.\n    var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n    if (pivotsEqual) {\n\n      // Degenerated case where the partitioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (var k = less; k <= great; ++k) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else if (xk > pivotValue1) {\n\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ek:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          /* eslint no-constant-condition: 0 */\n          while (true) {\n            var greatValue = f(a[great]);\n            if (greatValue > pivotValue1) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (greatValue < pivotValue1) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ek;\n              break;\n            } else {\n              a[k] = a[great];\n              a[great--] = ek;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      (function () { // isolate scope\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else {\n          if (xk > pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue > pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n      })(); // isolate scope\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[lo] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[hi - 1] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don\'t include the pivot values.)\n    sort(a, lo, less - 1);\n    sort(a, great + 2, hi);\n\n    if (pivotsEqual) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return a;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < i1 && great > i5) {\n\n      (function () { // isolate scope\n      var lessValue, greatValue;\n      while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) ++less;\n      while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) --great;\n\n      // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk <= pivotValue1 && xk >= pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          less++;\n        } else {\n          if (xk <= pivotValue2 && xk >= pivotValue2) {\n            /* eslint no-constant-condition: 0 */\n            while (true) {\n              greatValue = f(a[great]);\n              if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n      })(); // isolate scope\n\n    }\n\n    // The second partition has now been cleared of pivot elements and looks\n    // as follows:\n    // [  *  |  > pivot1 && < pivot2  | * ]\n    //        ^                      ^\n    //       less                  great\n    // Sort the second partition using recursive descent.\n\n    // The second partition looks as follows:\n    // [  *  |  >= pivot1 && <= pivot2  | * ]\n    //        ^                        ^\n    //       less                    great\n    // Simply sort it by recursive descent.\n\n    return sort(a, less, great + 1);\n  }\n\n  return sort;\n}\n\nvar quicksort_sizeThreshold = 32;\n\nmodule.exports = quicksort_by(crossfilter_identity);\nmodule.exports.by = quicksort_by;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjI4ZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9xdWlja3NvcnQuanM/NDlkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3Jvc3NmaWx0ZXJfaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG52YXIgeEZpbHRlckluc2VydGlvbnNvcnQgPSByZXF1aXJlKCcuL2luc2VydGlvbnNvcnQnKTtcblxuLy8gQWxnb3JpdGhtIGRlc2lnbmVkIGJ5IFZsYWRpbWlyIFlhcm9zbGF2c2tpeS5cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBEYXJ0IHByb2plY3Q7IHNlZSBOT1RJQ0UgYW5kIEFVVEhPUlMgZm9yIGRldGFpbHMuXG5cbmZ1bmN0aW9uIHF1aWNrc29ydF9ieShmKSB7XG4gIHZhciBpbnNlcnRpb25zb3J0ID0geEZpbHRlckluc2VydGlvbnNvcnQuYnkoZik7XG5cbiAgZnVuY3Rpb24gc29ydChhLCBsbywgaGkpIHtcbiAgICByZXR1cm4gKGhpIC0gbG8gPCBxdWlja3NvcnRfc2l6ZVRocmVzaG9sZFxuICAgICAgICA/IGluc2VydGlvbnNvcnRcbiAgICAgICAgOiBxdWlja3NvcnQpKGEsIGxvLCBoaSk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWlja3NvcnQoYSwgbG8sIGhpKSB7XG4gICAgLy8gQ29tcHV0ZSB0aGUgdHdvIHBpdm90cyBieSBsb29raW5nIGF0IDUgZWxlbWVudHMuXG4gICAgdmFyIHNpeHRoID0gKGhpIC0gbG8pIC8gNiB8IDAsXG4gICAgICAgIGkxID0gbG8gKyBzaXh0aCxcbiAgICAgICAgaTUgPSBoaSAtIDEgLSBzaXh0aCxcbiAgICAgICAgaTMgPSBsbyArIGhpIC0gMSA+PiAxLCAgLy8gVGhlIG1pZHBvaW50LlxuICAgICAgICBpMiA9IGkzIC0gc2l4dGgsXG4gICAgICAgIGk0ID0gaTMgKyBzaXh0aDtcblxuICAgIHZhciBlMSA9IGFbaTFdLCB4MSA9IGYoZTEpLFxuICAgICAgICBlMiA9IGFbaTJdLCB4MiA9IGYoZTIpLFxuICAgICAgICBlMyA9IGFbaTNdLCB4MyA9IGYoZTMpLFxuICAgICAgICBlNCA9IGFbaTRdLCB4NCA9IGYoZTQpLFxuICAgICAgICBlNSA9IGFbaTVdLCB4NSA9IGYoZTUpO1xuXG4gICAgdmFyIHQ7XG5cbiAgICAvLyBTb3J0IHRoZSBzZWxlY3RlZCA1IGVsZW1lbnRzIHVzaW5nIGEgc29ydGluZyBuZXR3b3JrLlxuICAgIGlmICh4MSA+IHgyKSB0ID0gZTEsIGUxID0gZTIsIGUyID0gdCwgdCA9IHgxLCB4MSA9IHgyLCB4MiA9IHQ7XG4gICAgaWYgKHg0ID4geDUpIHQgPSBlNCwgZTQgPSBlNSwgZTUgPSB0LCB0ID0geDQsIHg0ID0geDUsIHg1ID0gdDtcbiAgICBpZiAoeDEgPiB4MykgdCA9IGUxLCBlMSA9IGUzLCBlMyA9IHQsIHQgPSB4MSwgeDEgPSB4MywgeDMgPSB0O1xuICAgIGlmICh4MiA+IHgzKSB0ID0gZTIsIGUyID0gZTMsIGUzID0gdCwgdCA9IHgyLCB4MiA9IHgzLCB4MyA9IHQ7XG4gICAgaWYgKHgxID4geDQpIHQgPSBlMSwgZTEgPSBlNCwgZTQgPSB0LCB0ID0geDEsIHgxID0geDQsIHg0ID0gdDtcbiAgICBpZiAoeDMgPiB4NCkgdCA9IGUzLCBlMyA9IGU0LCBlNCA9IHQsIHQgPSB4MywgeDMgPSB4NCwgeDQgPSB0O1xuICAgIGlmICh4MiA+IHg1KSB0ID0gZTIsIGUyID0gZTUsIGU1ID0gdCwgdCA9IHgyLCB4MiA9IHg1LCB4NSA9IHQ7XG4gICAgaWYgKHgyID4geDMpIHQgPSBlMiwgZTIgPSBlMywgZTMgPSB0LCB0ID0geDIsIHgyID0geDMsIHgzID0gdDtcbiAgICBpZiAoeDQgPiB4NSkgdCA9IGU0LCBlNCA9IGU1LCBlNSA9IHQsIHQgPSB4NCwgeDQgPSB4NSwgeDUgPSB0O1xuXG4gICAgdmFyIHBpdm90MSA9IGUyLCBwaXZvdFZhbHVlMSA9IHgyLFxuICAgICAgICBwaXZvdDIgPSBlNCwgcGl2b3RWYWx1ZTIgPSB4NDtcblxuICAgIC8vIGUyIGFuZCBlNCBoYXZlIGJlZW4gc2F2ZWQgaW4gdGhlIHBpdm90IHZhcmlhYmxlcy4gVGhleSB3aWxsIGJlIHdyaXR0ZW5cbiAgICAvLyBiYWNrLCBvbmNlIHRoZSBwYXJ0aXRpb25pbmcgaXMgZmluaXNoZWQuXG4gICAgYVtpMV0gPSBlMTtcbiAgICBhW2kyXSA9IGFbbG9dO1xuICAgIGFbaTNdID0gZTM7XG4gICAgYVtpNF0gPSBhW2hpIC0gMV07XG4gICAgYVtpNV0gPSBlNTtcblxuICAgIHZhciBsZXNzID0gbG8gKyAxLCAgIC8vIEZpcnN0IGVsZW1lbnQgaW4gdGhlIG1pZGRsZSBwYXJ0aXRpb24uXG4gICAgICAgIGdyZWF0ID0gaGkgLSAyOyAgLy8gTGFzdCBlbGVtZW50IGluIHRoZSBtaWRkbGUgcGFydGl0aW9uLlxuXG4gICAgLy8gTm90ZSB0aGF0IGZvciB2YWx1ZSBjb21wYXJpc29uLCA8LCA8PSwgPj0gYW5kID4gY29lcmNlIHRvIGEgcHJpbWl0aXZlIHZpYVxuICAgIC8vIE9iamVjdC5wcm90b3R5cGUudmFsdWVPZjsgPT0gYW5kID09PSBkbyBub3QsIHNvIGluIG9yZGVyIHRvIGJlIGNvbnNpc3RlbnRcbiAgICAvLyB3aXRoIG5hdHVyYWwgb3JkZXIgKHN1Y2ggYXMgZm9yIERhdGUgb2JqZWN0cyksIHdlIG11c3QgZG8gdHdvIGNvbXBhcmVzLlxuICAgIHZhciBwaXZvdHNFcXVhbCA9IHBpdm90VmFsdWUxIDw9IHBpdm90VmFsdWUyICYmIHBpdm90VmFsdWUxID49IHBpdm90VmFsdWUyO1xuICAgIGlmIChwaXZvdHNFcXVhbCkge1xuXG4gICAgICAvLyBEZWdlbmVyYXRlZCBjYXNlIHdoZXJlIHRoZSBwYXJ0aXRpb25pbmcgYmVjb21lcyBhIGR1dGNoIG5hdGlvbmFsIGZsYWdcbiAgICAgIC8vIHByb2JsZW0uXG4gICAgICAvL1xuICAgICAgLy8gWyB8ICA8IHBpdm90ICB8ID09IHBpdm90IHwgdW5wYXJ0aXRpb25lZCB8ID4gcGl2b3QgIHwgXVxuICAgICAgLy8gIF4gICAgICAgICAgICAgXiAgICAgICAgICBeICAgICAgICAgICAgIF4gICAgICAgICAgICBeXG4gICAgICAvLyBsZWZ0ICAgICAgICAgbGVzcyAgICAgICAgIGsgICAgICAgICAgIGdyZWF0ICAgICAgICAgcmlnaHRcbiAgICAgIC8vXG4gICAgICAvLyBhW2xlZnRdIGFuZCBhW3JpZ2h0XSBhcmUgdW5kZWZpbmVkIGFuZCBhcmUgZmlsbGVkIGFmdGVyIHRoZVxuICAgICAgLy8gcGFydGl0aW9uaW5nLlxuICAgICAgLy9cbiAgICAgIC8vIEludmFyaWFudHM6XG4gICAgICAvLyAgIDEpIGZvciB4IGluIF1sZWZ0LCBsZXNzWyA6IHggPCBwaXZvdC5cbiAgICAgIC8vICAgMikgZm9yIHggaW4gW2xlc3MsIGtbIDogeCA9PSBwaXZvdC5cbiAgICAgIC8vICAgMykgZm9yIHggaW4gXWdyZWF0LCByaWdodFsgOiB4ID4gcGl2b3QuXG4gICAgICBmb3IgKHZhciBrID0gbGVzczsgayA8PSBncmVhdDsgKytrKSB7XG4gICAgICAgIHZhciBlayA9IGFba10sIHhrID0gZihlayk7XG4gICAgICAgIGlmICh4ayA8IHBpdm90VmFsdWUxKSB7XG4gICAgICAgICAgaWYgKGsgIT09IGxlc3MpIHtcbiAgICAgICAgICAgIGFba10gPSBhW2xlc3NdO1xuICAgICAgICAgICAgYVtsZXNzXSA9IGVrO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2xlc3M7XG4gICAgICAgIH0gZWxzZSBpZiAoeGsgPiBwaXZvdFZhbHVlMSkge1xuXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgZWxlbWVudCA8PSBwaXZvdCBpbiB0aGUgcmFuZ2UgW2sgLSAxLCBncmVhdF0gYW5kXG4gICAgICAgICAgLy8gcHV0IFs6ZWs6XSB0aGVyZS4gV2Uga25vdyB0aGF0IHN1Y2ggYW4gZWxlbWVudCBtdXN0IGV4aXN0OlxuICAgICAgICAgIC8vIFdoZW4gayA9PSBsZXNzLCB0aGVuIGVsMyAod2hpY2ggaXMgZXF1YWwgdG8gcGl2b3QpIGxpZXMgaW4gdGhlXG4gICAgICAgICAgLy8gaW50ZXJ2YWwuIE90aGVyd2lzZSBhW2sgLSAxXSA9PSBwaXZvdCBhbmQgdGhlIHNlYXJjaCBzdG9wcyBhdCBrLTEuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IGluIHRoZSBsYXR0ZXIgY2FzZSBpbnZhcmlhbnQgMiB3aWxsIGJlIHZpb2xhdGVkIGZvciBhXG4gICAgICAgICAgLy8gc2hvcnQgYW1vdW50IG9mIHRpbWUuIFRoZSBpbnZhcmlhbnQgd2lsbCBiZSByZXN0b3JlZCB3aGVuIHRoZVxuICAgICAgICAgIC8vIHBpdm90cyBhcmUgcHV0IGludG8gdGhlaXIgZmluYWwgcG9zaXRpb25zLlxuICAgICAgICAgIC8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246IDAgKi9cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGdyZWF0VmFsdWUgPSBmKGFbZ3JlYXRdKTtcbiAgICAgICAgICAgIGlmIChncmVhdFZhbHVlID4gcGl2b3RWYWx1ZTEpIHtcbiAgICAgICAgICAgICAgZ3JlYXQtLTtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBsb2NhdGlvbiBpbiB0aGUgd2hpbGUtbG9vcCB3aGVyZSBhIG5ld1xuICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gaXMgc3RhcnRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyZWF0VmFsdWUgPCBwaXZvdFZhbHVlMSkge1xuICAgICAgICAgICAgICAvLyBUcmlwbGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICAgIGFba10gPSBhW2xlc3NdO1xuICAgICAgICAgICAgICBhW2xlc3MrK10gPSBhW2dyZWF0XTtcbiAgICAgICAgICAgICAgYVtncmVhdC0tXSA9IGVrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFba10gPSBhW2dyZWF0XTtcbiAgICAgICAgICAgICAgYVtncmVhdC0tXSA9IGVrO1xuICAgICAgICAgICAgICAvLyBOb3RlOiBpZiBncmVhdCA8IGsgdGhlbiB3ZSB3aWxsIGV4aXQgdGhlIG91dGVyIGxvb3AgYW5kIGZpeFxuICAgICAgICAgICAgICAvLyBpbnZhcmlhbnQgMiAod2hpY2ggd2UganVzdCB2aW9sYXRlZCkuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIFdlIHBhcnRpdGlvbiB0aGUgbGlzdCBpbnRvIHRocmVlIHBhcnRzOlxuICAgICAgLy8gIDEuIDwgcGl2b3QxXG4gICAgICAvLyAgMi4gPj0gcGl2b3QxICYmIDw9IHBpdm90MlxuICAgICAgLy8gIDMuID4gcGl2b3QyXG4gICAgICAvL1xuICAgICAgLy8gRHVyaW5nIHRoZSBsb29wIHdlIGhhdmU6XG4gICAgICAvLyBbIHwgPCBwaXZvdDEgfCA+PSBwaXZvdDEgJiYgPD0gcGl2b3QyIHwgdW5wYXJ0aXRpb25lZCAgfCA+IHBpdm90MiAgfCBdXG4gICAgICAvLyAgXiAgICAgICAgICAgIF4gICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICBeICAgICAgICAgICAgIF5cbiAgICAgIC8vIGxlZnQgICAgICAgICBsZXNzICAgICAgICAgICAgICAgICAgICAgayAgICAgICAgICAgICAgZ3JlYXQgICAgICAgIHJpZ2h0XG4gICAgICAvL1xuICAgICAgLy8gYVtsZWZ0XSBhbmQgYVtyaWdodF0gYXJlIHVuZGVmaW5lZCBhbmQgYXJlIGZpbGxlZCBhZnRlciB0aGVcbiAgICAgIC8vIHBhcnRpdGlvbmluZy5cbiAgICAgIC8vXG4gICAgICAvLyBJbnZhcmlhbnRzOlxuICAgICAgLy8gICAxLiBmb3IgeCBpbiBdbGVmdCwgbGVzc1sgOiB4IDwgcGl2b3QxXG4gICAgICAvLyAgIDIuIGZvciB4IGluIFtsZXNzLCBrWyA6IHBpdm90MSA8PSB4ICYmIHggPD0gcGl2b3QyXG4gICAgICAvLyAgIDMuIGZvciB4IGluIF1ncmVhdCwgcmlnaHRbIDogeCA+IHBpdm90MlxuICAgICAgKGZ1bmN0aW9uICgpIHsgLy8gaXNvbGF0ZSBzY29wZVxuICAgICAgZm9yICh2YXIgayA9IGxlc3M7IGsgPD0gZ3JlYXQ7IGsrKykge1xuICAgICAgICB2YXIgZWsgPSBhW2tdLCB4ayA9IGYoZWspO1xuICAgICAgICBpZiAoeGsgPCBwaXZvdFZhbHVlMSkge1xuICAgICAgICAgIGlmIChrICE9PSBsZXNzKSB7XG4gICAgICAgICAgICBhW2tdID0gYVtsZXNzXTtcbiAgICAgICAgICAgIGFbbGVzc10gPSBlaztcbiAgICAgICAgICB9XG4gICAgICAgICAgKytsZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh4ayA+IHBpdm90VmFsdWUyKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgZ3JlYXRWYWx1ZSA9IGYoYVtncmVhdF0pO1xuICAgICAgICAgICAgICBpZiAoZ3JlYXRWYWx1ZSA+IHBpdm90VmFsdWUyKSB7XG4gICAgICAgICAgICAgICAgZ3JlYXQtLTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JlYXQgPCBrKSBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IGxvY2F0aW9uIGluc2lkZSB0aGUgbG9vcCB3aGVyZSBhIG5ld1xuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGlvbiBpcyBzdGFydGVkLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFbZ3JlYXRdIDw9IHBpdm90Mi5cbiAgICAgICAgICAgICAgICBpZiAoZ3JlYXRWYWx1ZSA8IHBpdm90VmFsdWUxKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUcmlwbGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICBhW2tdID0gYVtsZXNzXTtcbiAgICAgICAgICAgICAgICAgIGFbbGVzcysrXSA9IGFbZ3JlYXRdO1xuICAgICAgICAgICAgICAgICAgYVtncmVhdC0tXSA9IGVrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBhW2dyZWF0XSA+PSBwaXZvdDEuXG4gICAgICAgICAgICAgICAgICBhW2tdID0gYVtncmVhdF07XG4gICAgICAgICAgICAgICAgICBhW2dyZWF0LS1dID0gZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB9KSgpOyAvLyBpc29sYXRlIHNjb3BlXG4gICAgfVxuXG4gICAgLy8gTW92ZSBwaXZvdHMgaW50byB0aGVpciBmaW5hbCBwb3NpdGlvbnMuXG4gICAgLy8gV2Ugc2hydW5rIHRoZSBsaXN0IGZyb20gYm90aCBzaWRlcyAoYVtsZWZ0XSBhbmQgYVtyaWdodF0gaGF2ZVxuICAgIC8vIG1lYW5pbmdsZXNzIHZhbHVlcyBpbiB0aGVtKSBhbmQgbm93IHdlIG1vdmUgZWxlbWVudHMgZnJvbSB0aGUgZmlyc3RcbiAgICAvLyBhbmQgdGhpcmQgcGFydGl0aW9uIGludG8gdGhlc2UgbG9jYXRpb25zIHNvIHRoYXQgd2UgY2FuIHN0b3JlIHRoZVxuICAgIC8vIHBpdm90cy5cbiAgICBhW2xvXSA9IGFbbGVzcyAtIDFdO1xuICAgIGFbbGVzcyAtIDFdID0gcGl2b3QxO1xuICAgIGFbaGkgLSAxXSA9IGFbZ3JlYXQgKyAxXTtcbiAgICBhW2dyZWF0ICsgMV0gPSBwaXZvdDI7XG5cbiAgICAvLyBUaGUgbGlzdCBpcyBub3cgcGFydGl0aW9uZWQgaW50byB0aHJlZSBwYXJ0aXRpb25zOlxuICAgIC8vIFsgPCBwaXZvdDEgICB8ID49IHBpdm90MSAmJiA8PSBwaXZvdDIgICB8ICA+IHBpdm90MiAgIF1cbiAgICAvLyAgXiAgICAgICAgICAgIF4gICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgIF5cbiAgICAvLyBsZWZ0ICAgICAgICAgbGVzcyAgICAgICAgICAgICAgICAgICAgIGdyZWF0ICAgICAgICByaWdodFxuXG4gICAgLy8gUmVjdXJzaXZlIGRlc2NlbnQuIChEb24ndCBpbmNsdWRlIHRoZSBwaXZvdCB2YWx1ZXMuKVxuICAgIHNvcnQoYSwgbG8sIGxlc3MgLSAxKTtcbiAgICBzb3J0KGEsIGdyZWF0ICsgMiwgaGkpO1xuXG4gICAgaWYgKHBpdm90c0VxdWFsKSB7XG4gICAgICAvLyBBbGwgZWxlbWVudHMgaW4gdGhlIHNlY29uZCBwYXJ0aXRpb24gYXJlIGVxdWFsIHRvIHRoZSBwaXZvdC4gTm9cbiAgICAgIC8vIG5lZWQgdG8gc29ydCB0aGVtLlxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgLy8gSW4gdGhlb3J5IGl0IHNob3VsZCBiZSBlbm91Z2ggdG8gY2FsbCBfZG9Tb3J0IHJlY3Vyc2l2ZWx5IG9uIHRoZSBzZWNvbmRcbiAgICAvLyBwYXJ0aXRpb24uXG4gICAgLy8gVGhlIEFuZHJvaWQgc291cmNlIGhvd2V2ZXIgcmVtb3ZlcyB0aGUgcGl2b3QgZWxlbWVudHMgZnJvbSB0aGUgcmVjdXJzaXZlXG4gICAgLy8gY2FsbCBpZiB0aGUgc2Vjb25kIHBhcnRpdGlvbiBpcyB0b28gbGFyZ2UgKG1vcmUgdGhhbiAyLzMgb2YgdGhlIGxpc3QpLlxuICAgIGlmIChsZXNzIDwgaTEgJiYgZ3JlYXQgPiBpNSkge1xuXG4gICAgICAoZnVuY3Rpb24gKCkgeyAvLyBpc29sYXRlIHNjb3BlXG4gICAgICB2YXIgbGVzc1ZhbHVlLCBncmVhdFZhbHVlO1xuICAgICAgd2hpbGUgKChsZXNzVmFsdWUgPSBmKGFbbGVzc10pKSA8PSBwaXZvdFZhbHVlMSAmJiBsZXNzVmFsdWUgPj0gcGl2b3RWYWx1ZTEpICsrbGVzcztcbiAgICAgIHdoaWxlICgoZ3JlYXRWYWx1ZSA9IGYoYVtncmVhdF0pKSA8PSBwaXZvdFZhbHVlMiAmJiBncmVhdFZhbHVlID49IHBpdm90VmFsdWUyKSAtLWdyZWF0O1xuXG4gICAgICAvLyBDb3B5IHBhc3RlIG9mIHRoZSBwcmV2aW91cyAzLXdheSBwYXJ0aXRpb25pbmcgd2l0aCBhZGFwdGlvbnMuXG4gICAgICAvL1xuICAgICAgLy8gV2UgcGFydGl0aW9uIHRoZSBsaXN0IGludG8gdGhyZWUgcGFydHM6XG4gICAgICAvLyAgMS4gPT0gcGl2b3QxXG4gICAgICAvLyAgMi4gPiBwaXZvdDEgJiYgPCBwaXZvdDJcbiAgICAgIC8vICAzLiA9PSBwaXZvdDJcbiAgICAgIC8vXG4gICAgICAvLyBEdXJpbmcgdGhlIGxvb3Agd2UgaGF2ZTpcbiAgICAgIC8vIFsgPT0gcGl2b3QxIHwgPiBwaXZvdDEgJiYgPCBwaXZvdDIgfCB1bnBhcnRpdGlvbmVkICB8ID09IHBpdm90MiBdXG4gICAgICAvLyAgICAgICAgICAgICAgXiAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICBeXG4gICAgICAvLyAgICAgICAgICAgIGxlc3MgICAgICAgICAgICAgICAgICAgICBrICAgICAgICAgICAgICBncmVhdFxuICAgICAgLy9cbiAgICAgIC8vIEludmFyaWFudHM6XG4gICAgICAvLyAgIDEuIGZvciB4IGluIFsgKiwgbGVzc1sgOiB4ID09IHBpdm90MVxuICAgICAgLy8gICAyLiBmb3IgeCBpbiBbbGVzcywga1sgOiBwaXZvdDEgPCB4ICYmIHggPCBwaXZvdDJcbiAgICAgIC8vICAgMy4gZm9yIHggaW4gXWdyZWF0LCAqIF0gOiB4ID09IHBpdm90MlxuICAgICAgZm9yICh2YXIgayA9IGxlc3M7IGsgPD0gZ3JlYXQ7IGsrKykge1xuICAgICAgICB2YXIgZWsgPSBhW2tdLCB4ayA9IGYoZWspO1xuICAgICAgICBpZiAoeGsgPD0gcGl2b3RWYWx1ZTEgJiYgeGsgPj0gcGl2b3RWYWx1ZTEpIHtcbiAgICAgICAgICBpZiAoayAhPT0gbGVzcykge1xuICAgICAgICAgICAgYVtrXSA9IGFbbGVzc107XG4gICAgICAgICAgICBhW2xlc3NdID0gZWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlc3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoeGsgPD0gcGl2b3RWYWx1ZTIgJiYgeGsgPj0gcGl2b3RWYWx1ZTIpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246IDAgKi9cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGdyZWF0VmFsdWUgPSBmKGFbZ3JlYXRdKTtcbiAgICAgICAgICAgICAgaWYgKGdyZWF0VmFsdWUgPD0gcGl2b3RWYWx1ZTIgJiYgZ3JlYXRWYWx1ZSA+PSBwaXZvdFZhbHVlMikge1xuICAgICAgICAgICAgICAgIGdyZWF0LS07XG4gICAgICAgICAgICAgICAgaWYgKGdyZWF0IDwgaykgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBsb2NhdGlvbiBpbnNpZGUgdGhlIGxvb3Agd2hlcmUgYSBuZXdcbiAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24gaXMgc3RhcnRlZC5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhW2dyZWF0XSA8IHBpdm90Mi5cbiAgICAgICAgICAgICAgICBpZiAoZ3JlYXRWYWx1ZSA8IHBpdm90VmFsdWUxKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUcmlwbGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICBhW2tdID0gYVtsZXNzXTtcbiAgICAgICAgICAgICAgICAgIGFbbGVzcysrXSA9IGFbZ3JlYXRdO1xuICAgICAgICAgICAgICAgICAgYVtncmVhdC0tXSA9IGVrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBhW2dyZWF0XSA9PSBwaXZvdDEuXG4gICAgICAgICAgICAgICAgICBhW2tdID0gYVtncmVhdF07XG4gICAgICAgICAgICAgICAgICBhW2dyZWF0LS1dID0gZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB9KSgpOyAvLyBpc29sYXRlIHNjb3BlXG5cbiAgICB9XG5cbiAgICAvLyBUaGUgc2Vjb25kIHBhcnRpdGlvbiBoYXMgbm93IGJlZW4gY2xlYXJlZCBvZiBwaXZvdCBlbGVtZW50cyBhbmQgbG9va3NcbiAgICAvLyBhcyBmb2xsb3dzOlxuICAgIC8vIFsgICogIHwgID4gcGl2b3QxICYmIDwgcGl2b3QyICB8ICogXVxuICAgIC8vICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICAvLyAgICAgICBsZXNzICAgICAgICAgICAgICAgICAgZ3JlYXRcbiAgICAvLyBTb3J0IHRoZSBzZWNvbmQgcGFydGl0aW9uIHVzaW5nIHJlY3Vyc2l2ZSBkZXNjZW50LlxuXG4gICAgLy8gVGhlIHNlY29uZCBwYXJ0aXRpb24gbG9va3MgYXMgZm9sbG93czpcbiAgICAvLyBbICAqICB8ICA+PSBwaXZvdDEgJiYgPD0gcGl2b3QyICB8ICogXVxuICAgIC8vICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgIC8vICAgICAgIGxlc3MgICAgICAgICAgICAgICAgICAgIGdyZWF0XG4gICAgLy8gU2ltcGx5IHNvcnQgaXQgYnkgcmVjdXJzaXZlIGRlc2NlbnQuXG5cbiAgICByZXR1cm4gc29ydChhLCBsZXNzLCBncmVhdCArIDEpO1xuICB9XG5cbiAgcmV0dXJuIHNvcnQ7XG59XG5cbnZhciBxdWlja3NvcnRfc2l6ZVRocmVzaG9sZCA9IDMyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1aWNrc29ydF9ieShjcm9zc2ZpbHRlcl9pZGVudGl0eSk7XG5tb2R1bGUuZXhwb3J0cy5ieSA9IHF1aWNrc29ydF9ieTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///b28e\n')},b452:function(module,exports,__webpack_require__){eval("\n/**\n * Module dependencies.\n */\n\nvar url = __webpack_require__(/*! ./url */ \"780f\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"6fba\");\nvar Manager = __webpack_require__(/*! ./manager */ \"1e1f\");\nvar debug = __webpack_require__(/*! debug */ \"433b\")('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  } else if (opts && 'object' === typeof opts.query) {\n    opts.query = encodeQueryString(opts.query);\n  }\n  return io.socket(parsed.path, opts);\n}\n/**\n *  Helper method to parse query objects to string.\n * @param {object} query\n * @returns {string}\n */\nfunction encodeQueryString (obj) {\n  var str = [];\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n    }\n  }\n  return str.join('&');\n}\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = __webpack_require__(/*! ./manager */ \"1e1f\");\nexports.Socket = __webpack_require__(/*! ./socket */ \"4c13\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjQ1Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanM/ZjQyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzICYmICdvYmplY3QnID09PSB0eXBlb2Ygb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBlbmNvZGVRdWVyeVN0cmluZyhvcHRzLnF1ZXJ5KTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cbi8qKlxuICogIEhlbHBlciBtZXRob2QgdG8gcGFyc2UgcXVlcnkgb2JqZWN0cyB0byBzdHJpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gcXVlcnlcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVF1ZXJ5U3RyaW5nIChvYmopIHtcbiAgdmFyIHN0ciA9IFtdO1xuICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIHN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbcF0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ci5qb2luKCcmJyk7XG59XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///b452\n")},b730:function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction crossfilter_zero() {\n  return 0;\n}\n\nmodule.exports = crossfilter_zero;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjczMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy96ZXJvLmpzPzRmYTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl96ZXJvKCkge1xuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcm9zc2ZpbHRlcl96ZXJvO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///b730\n")},ba23:function(module,exports,__webpack_require__){eval("/**\n * Categorial Rule abstracts a single matching rule\n *\n * @class CategorialRule\n */\nvar Base = __webpack_require__(/*! ../util/base */ \"3902\");\n\n// Data structure for mapping categorial (and textual) data on groups\nmodule.exports = Base.extend({\n  props: {\n    /**\n     * string or string format of regexp to match data against.\n     * To use a regular expression, start and end the string with a slash, '/'.\n     * Options can be appedended, notably 'i' for case insensitive matching.\n     * The first captured group can be used in the group, see below.\n     * Examples\n     * 1. 'hello' matches 'hello', not 'hello world'\n     * 2. '/hello/' matches 'hello world', but not 'Hello world'\n     * 3. '/hello/i' matches 'I say Hello'\n     * @type {string}\n     * @memberof! CategorialRule\n     */\n    expression: ['string', true, 'Missing'],\n\n    /**\n     * Number of items this transform is used\n     * @type {number}\n     * @memberof! CategorialRule\n     */\n    count: ['number', true, 0],\n\n    /**\n     * Name of the group this is mapped to. The special substring $1 is replaced by the first captured group,\n     * in example 4 above, with group set to 'He says $1', the match results in 'He says goodbye'\n     * @type {string}\n     * @memberof! CategorialRule\n     */\n    group: ['string', true, 'Missing']\n  },\n  derived: {\n\n    /**\n     * Match function\n     * @memberof! CategorialRule\n     * @function\n     * @param {string} text The text to match\n     * @returns {string|false} group The group label if matching, else false\n     */\n    match: {\n      deps: ['expression', 'group'],\n      fn: function () {\n        var that = this;\n\n        var reFormat = new RegExp(/^\\/(.*)\\/([gimuy]*)$/);\n        var match = reFormat.exec(that.expression);\n\n        if (match) {\n          // if the expression is in the form of /<text>/<flags>, it is a regular expression, compile it\n          var exp = RegExp(match[1], match[2]);\n          return function (text) {\n            var m = exp.exec(text);\n            if (m) {\n              return that.group;\n              // return that.group.replace('$1', m[1]);\n            } else {\n              return false;\n            }\n          };\n        } else {\n          // otherwise do matching using '==='\n          return function (text) {\n            if (text === that.expression) {\n              return that.group;\n            } else {\n              return false;\n            }\n          };\n        }\n      }\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmEyMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvY2F0ZWdvcmlhbC1ydWxlLmpzP2UxNzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDYXRlZ29yaWFsIFJ1bGUgYWJzdHJhY3RzIGEgc2luZ2xlIG1hdGNoaW5nIHJ1bGVcbiAqXG4gKiBAY2xhc3MgQ2F0ZWdvcmlhbFJ1bGVcbiAqL1xudmFyIEJhc2UgPSByZXF1aXJlKCcuLi91dGlsL2Jhc2UnKTtcblxuLy8gRGF0YSBzdHJ1Y3R1cmUgZm9yIG1hcHBpbmcgY2F0ZWdvcmlhbCAoYW5kIHRleHR1YWwpIGRhdGEgb24gZ3JvdXBzXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBzdHJpbmcgb3Igc3RyaW5nIGZvcm1hdCBvZiByZWdleHAgdG8gbWF0Y2ggZGF0YSBhZ2FpbnN0LlxuICAgICAqIFRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3RhcnQgYW5kIGVuZCB0aGUgc3RyaW5nIHdpdGggYSBzbGFzaCwgJy8nLlxuICAgICAqIE9wdGlvbnMgY2FuIGJlIGFwcGVkZW5kZWQsIG5vdGFibHkgJ2knIGZvciBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nLlxuICAgICAqIFRoZSBmaXJzdCBjYXB0dXJlZCBncm91cCBjYW4gYmUgdXNlZCBpbiB0aGUgZ3JvdXAsIHNlZSBiZWxvdy5cbiAgICAgKiBFeGFtcGxlc1xuICAgICAqIDEuICdoZWxsbycgbWF0Y2hlcyAnaGVsbG8nLCBub3QgJ2hlbGxvIHdvcmxkJ1xuICAgICAqIDIuICcvaGVsbG8vJyBtYXRjaGVzICdoZWxsbyB3b3JsZCcsIGJ1dCBub3QgJ0hlbGxvIHdvcmxkJ1xuICAgICAqIDMuICcvaGVsbG8vaScgbWF0Y2hlcyAnSSBzYXkgSGVsbG8nXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YhIENhdGVnb3JpYWxSdWxlXG4gICAgICovXG4gICAgZXhwcmVzc2lvbjogWydzdHJpbmcnLCB0cnVlLCAnTWlzc2luZyddLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGl0ZW1zIHRoaXMgdHJhbnNmb3JtIGlzIHVzZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiEgQ2F0ZWdvcmlhbFJ1bGVcbiAgICAgKi9cbiAgICBjb3VudDogWydudW1iZXInLCB0cnVlLCAwXSxcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGdyb3VwIHRoaXMgaXMgbWFwcGVkIHRvLiBUaGUgc3BlY2lhbCBzdWJzdHJpbmcgJDEgaXMgcmVwbGFjZWQgYnkgdGhlIGZpcnN0IGNhcHR1cmVkIGdyb3VwLFxuICAgICAqIGluIGV4YW1wbGUgNCBhYm92ZSwgd2l0aCBncm91cCBzZXQgdG8gJ0hlIHNheXMgJDEnLCB0aGUgbWF0Y2ggcmVzdWx0cyBpbiAnSGUgc2F5cyBnb29kYnllJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mISBDYXRlZ29yaWFsUnVsZVxuICAgICAqL1xuICAgIGdyb3VwOiBbJ3N0cmluZycsIHRydWUsICdNaXNzaW5nJ11cbiAgfSxcbiAgZGVyaXZlZDoge1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2ggZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YhIENhdGVnb3JpYWxSdWxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gbWF0Y2hcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfGZhbHNlfSBncm91cCBUaGUgZ3JvdXAgbGFiZWwgaWYgbWF0Y2hpbmcsIGVsc2UgZmFsc2VcbiAgICAgKi9cbiAgICBtYXRjaDoge1xuICAgICAgZGVwczogWydleHByZXNzaW9uJywgJ2dyb3VwJ10sXG4gICAgICBmbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cCgvXlxcLyguKilcXC8oW2dpbXV5XSopJC8pO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZUZvcm1hdC5leGVjKHRoYXQuZXhwcmVzc2lvbik7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGV4cHJlc3Npb24gaXMgaW4gdGhlIGZvcm0gb2YgLzx0ZXh0Pi88ZmxhZ3M+LCBpdCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgY29tcGlsZSBpdFxuICAgICAgICAgIHZhciBleHAgPSBSZWdFeHAobWF0Y2hbMV0sIG1hdGNoWzJdKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBtID0gZXhwLmV4ZWModGV4dCk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5ncm91cDtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoYXQuZ3JvdXAucmVwbGFjZSgnJDEnLCBtWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBkbyBtYXRjaGluZyB1c2luZyAnPT09J1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgaWYgKHRleHQgPT09IHRoYXQuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5ncm91cDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ba23\n")},bb16:function(module,exports,__webpack_require__){eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"1ed2\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmIxNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanM/NTJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///bb16\n")},bff6:function(module,exports){eval("/**\n * This module defines a single unique missing value indicator.\n * All invalid, absent, or user-indicated missing value is internally set to this value.\n *\n * @example\n * var misval = require('./framework/misval');\n * if ( a === misval ) {\n *   ...\n * }\n * @module client/misval\n */\n\n// module.exports = -Number.MAX_VALUE;\nmodule.exports = 'missing';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmZmNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC9taXN2YWwuanM/YjI3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbW9kdWxlIGRlZmluZXMgYSBzaW5nbGUgdW5pcXVlIG1pc3NpbmcgdmFsdWUgaW5kaWNhdG9yLlxuICogQWxsIGludmFsaWQsIGFic2VudCwgb3IgdXNlci1pbmRpY2F0ZWQgbWlzc2luZyB2YWx1ZSBpcyBpbnRlcm5hbGx5IHNldCB0byB0aGlzIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbWlzdmFsID0gcmVxdWlyZSgnLi9mcmFtZXdvcmsvbWlzdmFsJyk7XG4gKiBpZiAoIGEgPT09IG1pc3ZhbCApIHtcbiAqICAgLi4uXG4gKiB9XG4gKiBAbW9kdWxlIGNsaWVudC9taXN2YWxcbiAqL1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xubW9kdWxlLmV4cG9ydHMgPSAnbWlzc2luZyc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///bff6\n")},c59b:function(module,exports,__webpack_require__){eval('\nmodule.exports = __webpack_require__(/*! ./lib/index */ "58ab");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYzU5Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcz80NmEyIl0sInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///c59b\n')},d45b:function(module,exports,__webpack_require__){eval("var AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\nvar AmpersandColllection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar moment = __webpack_require__(/*! moment-timezone */ \"6c9d\");\n\n/*\n * Time is grouped by truncating; the resolution is determined in util-time.getResolution()\n * See [this table](http://momentjs.com/docs/#/durations/creating/) for accpetable values\n * when using a crossfilter dataset.\n */\nfunction unitsForMilliseconds (milliseconds) {\n  var count = milliseconds;\n  if (count < 10000) { // 10 seconds\n    return 'milliseconds';\n  }\n  count = count / 1000;\n\n  if (count < 15 * 60) { // 15 minutes\n    return 'seconds';\n  }\n  count = count / 60;\n\n  if (count < 3 * 60) { // 3 hours\n    return 'minutes';\n  }\n  count = count / 60;\n\n  if (count < 3 * 24) { // 3 days\n    return 'hours';\n  }\n  count = count / 24;\n\n  if (count < 3 * 7) { // 3 weeks\n    return 'days';\n  }\n  if (count < 7 * 52) { // 52 weeks\n    return 'weeks';\n  }\n  if (count < 2 * 365) { // 2 years\n    return 'months';\n  }\n  return 'years';\n}\n\nfunction getFormat (units) {\n  var fmt;\n  if (units === 'seconds') {\n    fmt = 'mm:ss';\n  } else if (units === 'minutes') {\n    fmt = 'HH:mm';\n  } else if (units === 'hours') {\n    fmt = 'HH:00';\n  } else if (units === 'days') {\n    fmt = 'dddd do';\n  } else if (units === 'weeks') {\n    fmt = 'wo';\n  } else if (units === 'months') {\n    fmt = 'YY MMM';\n  } else if (units === 'years') {\n    fmt = 'YYYY';\n  }\n  return fmt;\n}\n\nfunction getDatetimeResolution (start, end) {\n  var difference = end.diff(start);\n  return unitsForMilliseconds(difference);\n}\n\nfunction getDurationResolution (min, max) {\n  var length = moment.duration(max.as('milliseconds') - min.as('milliseconds'), 'milliseconds');\n  return unitsForMilliseconds(length);\n}\n\nvar TimePart = AmpersandModel.extend({\n  props: {\n    /**\n     * The format string for momentjs\n     * @memberof! TimePart\n     * @type {string}\n     */\n    momentFormat: ['string', true],\n    /**\n     * The format string for postgresql\n     * @memberof! TimePart\n     * @type {string}\n     */\n    postgresFormat: ['string', true],\n    /**\n     * The human readable descprition of the datetime part\n     * @memberof! TimePart\n     * @type {string}\n     */\n    description: ['string', true],\n    /**\n     * Data type after conversion: 'continuous', or 'categorial'\n     * @memberof! TimePart\n     * @type {string}\n     */\n    type: ['string', true],\n    /**\n     * For continuous datetime parts (ie, day-of-year), the minimum value\n     * @memberof! TimePart\n     * @type {number}\n     */\n    min: ['number', true, 0],\n    /**\n     * For continuous datetime parts (ie, day-of-year), the maximum value\n     * @memberof! TimePart\n     * @type {number}\n     */\n    max: ['number', true, 1],\n    /**\n     * When true, calculate the minimum and maximum value from the\n     * original datetime limits. Used for continuous datetime parts (ie, year)\n     * @memberof! TimePart\n     * @type {boolean}\n     */\n    calculate: ['boolean', true, false],\n    /**\n     * For categorial datetime parts (Mon, Tue, ..), the array of possible values\n     * @memberof! TimePart\n     * @type {String[]}\n     */\n    groups: ['array']\n  }\n});\n\nvar TimeParts = AmpersandColllection.extend({\n  model: TimePart,\n  indexes: ['description']\n});\n\nvar timeParts = new TimeParts([\n  { description: 'ISO8601', type: 'datetime', calculate: true },\n  { postgresFormat: 'month', momentFormat: 'M', description: 'Month (1-12)', type: 'continuous', min: 1, max: 12 },\n  { postgresFormat: 'quarter', momentFormat: 'Q', description: 'Quarter (1-4)', type: 'continuous', min: 1, max: 4 },\n  { postgresFormat: 'day', momentFormat: 'D', description: 'Day of Month  (1-31)', type: 'continuous', min: 1, max: 31 },\n  { postgresFormat: 'doy', momentFormat: 'DDD', description: 'Day of Year (1-365)', type: 'continuous', min: 1, max: 365 },\n  { postgresFormat: 'dow', momentFormat: 'd', description: 'Day of Week (0-6)', type: 'continuous', min: 0, max: 6 },\n  { postgresFormat: 'isodow', momentFormat: 'E', description: 'Day of Week ISO (1-7)', type: 'continuous', min: 1, max: 7 },\n  { postgresFormat: 'week', momentFormat: 'W', description: 'Week of Year ISO  (1-53)', type: 'continuous', min: 1, max: 53 },\n  { postgresFormat: 'year', momentFormat: 'Y', description: 'Year', type: 'continuous', calculate: true },\n  { postgresFormat: 'hours', momentFormat: 'H', description: 'Hour (0-23)', type: 'continuous', min: 0, max: 23 },\n  { postgresFormat: 'minute', momentFormat: 'm', description: 'Minute (0-59)', type: 'continuous', min: 0, max: 59 },\n  { postgresFormat: 'second', momentFormat: 's', description: 'Second (0-59)', type: 'continuous', min: 0, max: 59 },\n  { postgresFormat: 'milliseconds', momentFormat: 'SSS', description: 'Milliseconds (0-999)', type: 'continuous', min: 0, max: 999 },\n  { postgresFormat: 'microseconds', momentFormat: 'SSSSSS', description: 'microseconds (0-999999)', type: 'continuous', min: 0, max: 999999 },\n  { postgresFormat: 'epoch', momentFormat: 'X', description: 'Unix Timestamp', type: 'continuous', calculate: true },\n  { postgresFormat: 'Mon', momentFormat: 'MMM', description: 'Month (Jan - Dec)', type: 'categorial', groups: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] },\n  { postgresFormat: 'Month', momentFormat: 'MMMM', description: 'Month (January - December)', type: 'categorial', groups: ['January', 'Feburary', 'March', 'April', 'May', 'June', 'July', 'August', 'Septebmer', 'October', 'November', 'December'] },\n  { postgresFormat: 'Dy', momentFormat: 'ddd', description: 'Day of Week (Sun-Sat)', type: 'categorial', groups: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] },\n  { postgresFormat: 'Day', momentFormat: 'dddd', description: 'Day of Week (Sunday-Saturday)', type: 'categorial', groups: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] },\n  { postgresFormat: 'AM', momentFormat: 'A', description: 'AM/PM', type: 'categorial', groups: ['AM', 'PM'] }\n]);\n\nvar DurationUnit = AmpersandModel.extend({\n  props: {\n    /**\n     * The descriptive name of the time unit\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    description: ['string'],\n    /**\n     * Momentjs parsing format\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    momentFormat: ['string'],\n    /**\n     * Postgres parsing format\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    postgresFormat: ['string'],\n    /**\n     * Conversion factor to seconds\n     * @memberof! DurationUnit\n     * @type {string}\n     */\n    seconds: ['number']\n  }\n});\n\nvar DurationUnits = AmpersandColllection.extend({\n  indexes: ['description'],\n  model: DurationUnit\n});\n\nvar durationUnits = new DurationUnits([\n  {\n    description: 'ISO8601',\n    seconds: 1\n  }, {\n    description: 'millenium',\n    momentFormat: 'millenium',\n    postgresFormat: 'millenium',\n    seconds: 100 * 365.25 * 24 * 60 * 60\n  }, {\n    description: 'century',\n    momentFormat: 'century',\n    postgresFormat: 'century',\n    seconds: 100 * 365.25 * 24 * 60 * 60\n  }, {\n    description: 'decades',\n    momentFormat: 'decades',\n    postgresFormat: 'decade',\n    seconds: 10 * 365.25 * 24 * 60 * 60\n  }, {\n    description: 'years',\n    momentFormat: 'years',\n    postgresFormat: 'year',\n    seconds: 365.25 * 24 * 60 * 60\n  }, {\n    description: 'quarters',\n    momentFormat: '',\n    postgresFormat: 'quarter',\n    seconds: 365.25 * 8 * 60 * 60\n  }, {\n    description: 'months',\n    momentFormat: 'months',\n    postgresFormat: 'month',\n    seconds: 30 * 24 * 60 * 60\n  }, {\n    description: 'weeks',\n    momentFormat: 'weeks',\n    postgresFormat: 'week',\n    seconds: 7 * 24 * 60 * 60\n  }, {\n    description: 'days',\n    momentFormat: 'days',\n    postgresFormat: 'day',\n    seconds: 24 * 60 * 60\n  }, {\n    description: 'hours',\n    momentFormat: 'hours',\n    postgresFormat: 'hour',\n    seconds: 60 * 60\n  }, {\n    description: 'minutes',\n    momentFormat: 'minutes',\n    postgresFormat: 'minute',\n    seconds: 60\n  }, {\n    description: 'seconds',\n    momentFormat: 'seconds',\n    postgresFormat: 'second',\n    seconds: 1\n  }, {\n    description: 'milliseconds',\n    momentFormat: 'milliseconds',\n    postgresFormat: 'milliseconds',\n    seconds: 0.001\n  }, {\n    description: 'microseconds',\n    momentFormat: 'microseconds',\n    postgresFormat: 'microseconds',\n    seconds: 0.000001\n  }\n]);\n\nvar TimeZone = AmpersandModel.extend({\n  props: {\n    /**\n     * The descriptive name of the time zone\n     * @memberof! TimeZone\n     * @type {string}\n     */\n    description: ['string'],\n    /**\n     * The time zone format\n     * @memberof! TimeZone\n     * @type {string}\n     */\n    format: ['string']\n  }\n});\n\nvar TimeZones = AmpersandColllection.extend({\n  indexes: ['description'],\n  model: TimeZone\n});\n\nvar timeZones = new TimeZones();\ntimeZones.add({\n  description: 'ISO8601',\n  format: 'ISO8601'\n});\n\nmoment.tz.names().forEach(function (tz) {\n  timeZones.add({\n    description: tz,\n    format: tz\n  });\n});\n\nmodule.exports = {\n  timeParts: timeParts,\n  timeZones: timeZones,\n  durationUnits: durationUnits,\n  getDatetimeResolution: getDatetimeResolution,\n  getDurationResolution: getDurationResolution,\n  getFormat: getFormat\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZDQ1Yi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvdXRpbC90aW1lLmpzP2ExMzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEFtcGVyc2FuZE1vZGVsID0gcmVxdWlyZSgnYW1wZXJzYW5kLW1vZGVsJyk7XG52YXIgQW1wZXJzYW5kQ29sbGxlY3Rpb24gPSByZXF1aXJlKCdhbXBlcnNhbmQtY29sbGVjdGlvbicpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuXG4vKlxuICogVGltZSBpcyBncm91cGVkIGJ5IHRydW5jYXRpbmc7IHRoZSByZXNvbHV0aW9uIGlzIGRldGVybWluZWQgaW4gdXRpbC10aW1lLmdldFJlc29sdXRpb24oKVxuICogU2VlIFt0aGlzIHRhYmxlXShodHRwOi8vbW9tZW50anMuY29tL2RvY3MvIy9kdXJhdGlvbnMvY3JlYXRpbmcvKSBmb3IgYWNjcGV0YWJsZSB2YWx1ZXNcbiAqIHdoZW4gdXNpbmcgYSBjcm9zc2ZpbHRlciBkYXRhc2V0LlxuICovXG5mdW5jdGlvbiB1bml0c0Zvck1pbGxpc2Vjb25kcyAobWlsbGlzZWNvbmRzKSB7XG4gIHZhciBjb3VudCA9IG1pbGxpc2Vjb25kcztcbiAgaWYgKGNvdW50IDwgMTAwMDApIHsgLy8gMTAgc2Vjb25kc1xuICAgIHJldHVybiAnbWlsbGlzZWNvbmRzJztcbiAgfVxuICBjb3VudCA9IGNvdW50IC8gMTAwMDtcblxuICBpZiAoY291bnQgPCAxNSAqIDYwKSB7IC8vIDE1IG1pbnV0ZXNcbiAgICByZXR1cm4gJ3NlY29uZHMnO1xuICB9XG4gIGNvdW50ID0gY291bnQgLyA2MDtcblxuICBpZiAoY291bnQgPCAzICogNjApIHsgLy8gMyBob3Vyc1xuICAgIHJldHVybiAnbWludXRlcyc7XG4gIH1cbiAgY291bnQgPSBjb3VudCAvIDYwO1xuXG4gIGlmIChjb3VudCA8IDMgKiAyNCkgeyAvLyAzIGRheXNcbiAgICByZXR1cm4gJ2hvdXJzJztcbiAgfVxuICBjb3VudCA9IGNvdW50IC8gMjQ7XG5cbiAgaWYgKGNvdW50IDwgMyAqIDcpIHsgLy8gMyB3ZWVrc1xuICAgIHJldHVybiAnZGF5cyc7XG4gIH1cbiAgaWYgKGNvdW50IDwgNyAqIDUyKSB7IC8vIDUyIHdlZWtzXG4gICAgcmV0dXJuICd3ZWVrcyc7XG4gIH1cbiAgaWYgKGNvdW50IDwgMiAqIDM2NSkgeyAvLyAyIHllYXJzXG4gICAgcmV0dXJuICdtb250aHMnO1xuICB9XG4gIHJldHVybiAneWVhcnMnO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXQgKHVuaXRzKSB7XG4gIHZhciBmbXQ7XG4gIGlmICh1bml0cyA9PT0gJ3NlY29uZHMnKSB7XG4gICAgZm10ID0gJ21tOnNzJztcbiAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ21pbnV0ZXMnKSB7XG4gICAgZm10ID0gJ0hIOm1tJztcbiAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ2hvdXJzJykge1xuICAgIGZtdCA9ICdISDowMCc7XG4gIH0gZWxzZSBpZiAodW5pdHMgPT09ICdkYXlzJykge1xuICAgIGZtdCA9ICdkZGRkIGRvJztcbiAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3dlZWtzJykge1xuICAgIGZtdCA9ICd3byc7XG4gIH0gZWxzZSBpZiAodW5pdHMgPT09ICdtb250aHMnKSB7XG4gICAgZm10ID0gJ1lZIE1NTSc7XG4gIH0gZWxzZSBpZiAodW5pdHMgPT09ICd5ZWFycycpIHtcbiAgICBmbXQgPSAnWVlZWSc7XG4gIH1cbiAgcmV0dXJuIGZtdDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZXRpbWVSZXNvbHV0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBkaWZmZXJlbmNlID0gZW5kLmRpZmYoc3RhcnQpO1xuICByZXR1cm4gdW5pdHNGb3JNaWxsaXNlY29uZHMoZGlmZmVyZW5jZSk7XG59XG5cbmZ1bmN0aW9uIGdldER1cmF0aW9uUmVzb2x1dGlvbiAobWluLCBtYXgpIHtcbiAgdmFyIGxlbmd0aCA9IG1vbWVudC5kdXJhdGlvbihtYXguYXMoJ21pbGxpc2Vjb25kcycpIC0gbWluLmFzKCdtaWxsaXNlY29uZHMnKSwgJ21pbGxpc2Vjb25kcycpO1xuICByZXR1cm4gdW5pdHNGb3JNaWxsaXNlY29uZHMobGVuZ3RoKTtcbn1cblxudmFyIFRpbWVQYXJ0ID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0IHN0cmluZyBmb3IgbW9tZW50anNcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBtb21lbnRGb3JtYXQ6IFsnc3RyaW5nJywgdHJ1ZV0sXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdCBzdHJpbmcgZm9yIHBvc3RncmVzcWxcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBwb3N0Z3Jlc0Zvcm1hdDogWydzdHJpbmcnLCB0cnVlXSxcbiAgICAvKipcbiAgICAgKiBUaGUgaHVtYW4gcmVhZGFibGUgZGVzY3ByaXRpb24gb2YgdGhlIGRhdGV0aW1lIHBhcnRcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbjogWydzdHJpbmcnLCB0cnVlXSxcbiAgICAvKipcbiAgICAgKiBEYXRhIHR5cGUgYWZ0ZXIgY29udmVyc2lvbjogJ2NvbnRpbnVvdXMnLCBvciAnY2F0ZWdvcmlhbCdcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiBbJ3N0cmluZycsIHRydWVdLFxuICAgIC8qKlxuICAgICAqIEZvciBjb250aW51b3VzIGRhdGV0aW1lIHBhcnRzIChpZSwgZGF5LW9mLXllYXIpLCB0aGUgbWluaW11bSB2YWx1ZVxuICAgICAqIEBtZW1iZXJvZiEgVGltZVBhcnRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIG1pbjogWydudW1iZXInLCB0cnVlLCAwXSxcbiAgICAvKipcbiAgICAgKiBGb3IgY29udGludW91cyBkYXRldGltZSBwYXJ0cyAoaWUsIGRheS1vZi15ZWFyKSwgdGhlIG1heGltdW0gdmFsdWVcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVQYXJ0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBtYXg6IFsnbnVtYmVyJywgdHJ1ZSwgMV0sXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBjYWxjdWxhdGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUgZnJvbSB0aGVcbiAgICAgKiBvcmlnaW5hbCBkYXRldGltZSBsaW1pdHMuIFVzZWQgZm9yIGNvbnRpbnVvdXMgZGF0ZXRpbWUgcGFydHMgKGllLCB5ZWFyKVxuICAgICAqIEBtZW1iZXJvZiEgVGltZVBhcnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGU6IFsnYm9vbGVhbicsIHRydWUsIGZhbHNlXSxcbiAgICAvKipcbiAgICAgKiBGb3IgY2F0ZWdvcmlhbCBkYXRldGltZSBwYXJ0cyAoTW9uLCBUdWUsIC4uKSwgdGhlIGFycmF5IG9mIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBtZW1iZXJvZiEgVGltZVBhcnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ3JvdXBzOiBbJ2FycmF5J11cbiAgfVxufSk7XG5cbnZhciBUaW1lUGFydHMgPSBBbXBlcnNhbmRDb2xsbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogVGltZVBhcnQsXG4gIGluZGV4ZXM6IFsnZGVzY3JpcHRpb24nXVxufSk7XG5cbnZhciB0aW1lUGFydHMgPSBuZXcgVGltZVBhcnRzKFtcbiAgeyBkZXNjcmlwdGlvbjogJ0lTTzg2MDEnLCB0eXBlOiAnZGF0ZXRpbWUnLCBjYWxjdWxhdGU6IHRydWUgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ21vbnRoJywgbW9tZW50Rm9ybWF0OiAnTScsIGRlc2NyaXB0aW9uOiAnTW9udGggKDEtMTIpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDEsIG1heDogMTIgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ3F1YXJ0ZXInLCBtb21lbnRGb3JtYXQ6ICdRJywgZGVzY3JpcHRpb246ICdRdWFydGVyICgxLTQpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDEsIG1heDogNCB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnZGF5JywgbW9tZW50Rm9ybWF0OiAnRCcsIGRlc2NyaXB0aW9uOiAnRGF5IG9mIE1vbnRoICAoMS0zMSknLCB0eXBlOiAnY29udGludW91cycsIG1pbjogMSwgbWF4OiAzMSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnZG95JywgbW9tZW50Rm9ybWF0OiAnREREJywgZGVzY3JpcHRpb246ICdEYXkgb2YgWWVhciAoMS0zNjUpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDEsIG1heDogMzY1IH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdkb3cnLCBtb21lbnRGb3JtYXQ6ICdkJywgZGVzY3JpcHRpb246ICdEYXkgb2YgV2VlayAoMC02KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDYgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ2lzb2RvdycsIG1vbWVudEZvcm1hdDogJ0UnLCBkZXNjcmlwdGlvbjogJ0RheSBvZiBXZWVrIElTTyAoMS03KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAxLCBtYXg6IDcgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ3dlZWsnLCBtb21lbnRGb3JtYXQ6ICdXJywgZGVzY3JpcHRpb246ICdXZWVrIG9mIFllYXIgSVNPICAoMS01MyknLCB0eXBlOiAnY29udGludW91cycsIG1pbjogMSwgbWF4OiA1MyB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAneWVhcicsIG1vbWVudEZvcm1hdDogJ1knLCBkZXNjcmlwdGlvbjogJ1llYXInLCB0eXBlOiAnY29udGludW91cycsIGNhbGN1bGF0ZTogdHJ1ZSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnaG91cnMnLCBtb21lbnRGb3JtYXQ6ICdIJywgZGVzY3JpcHRpb246ICdIb3VyICgwLTIzKScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDIzIH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdtaW51dGUnLCBtb21lbnRGb3JtYXQ6ICdtJywgZGVzY3JpcHRpb246ICdNaW51dGUgKDAtNTkpJywgdHlwZTogJ2NvbnRpbnVvdXMnLCBtaW46IDAsIG1heDogNTkgfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ3NlY29uZCcsIG1vbWVudEZvcm1hdDogJ3MnLCBkZXNjcmlwdGlvbjogJ1NlY29uZCAoMC01OSknLCB0eXBlOiAnY29udGludW91cycsIG1pbjogMCwgbWF4OiA1OSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnbWlsbGlzZWNvbmRzJywgbW9tZW50Rm9ybWF0OiAnU1NTJywgZGVzY3JpcHRpb246ICdNaWxsaXNlY29uZHMgKDAtOTk5KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDk5OSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnbWljcm9zZWNvbmRzJywgbW9tZW50Rm9ybWF0OiAnU1NTU1NTJywgZGVzY3JpcHRpb246ICdtaWNyb3NlY29uZHMgKDAtOTk5OTk5KScsIHR5cGU6ICdjb250aW51b3VzJywgbWluOiAwLCBtYXg6IDk5OTk5OSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnZXBvY2gnLCBtb21lbnRGb3JtYXQ6ICdYJywgZGVzY3JpcHRpb246ICdVbml4IFRpbWVzdGFtcCcsIHR5cGU6ICdjb250aW51b3VzJywgY2FsY3VsYXRlOiB0cnVlIH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdNb24nLCBtb21lbnRGb3JtYXQ6ICdNTU0nLCBkZXNjcmlwdGlvbjogJ01vbnRoIChKYW4gLSBEZWMpJywgdHlwZTogJ2NhdGVnb3JpYWwnLCBncm91cHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnTW9udGgnLCBtb21lbnRGb3JtYXQ6ICdNTU1NJywgZGVzY3JpcHRpb246ICdNb250aCAoSmFudWFyeSAtIERlY2VtYmVyKScsIHR5cGU6ICdjYXRlZ29yaWFsJywgZ3JvdXBzOiBbJ0phbnVhcnknLCAnRmVidXJhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVibWVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSB9LFxuICB7IHBvc3RncmVzRm9ybWF0OiAnRHknLCBtb21lbnRGb3JtYXQ6ICdkZGQnLCBkZXNjcmlwdGlvbjogJ0RheSBvZiBXZWVrIChTdW4tU2F0KScsIHR5cGU6ICdjYXRlZ29yaWFsJywgZ3JvdXBzOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddIH0sXG4gIHsgcG9zdGdyZXNGb3JtYXQ6ICdEYXknLCBtb21lbnRGb3JtYXQ6ICdkZGRkJywgZGVzY3JpcHRpb246ICdEYXkgb2YgV2VlayAoU3VuZGF5LVNhdHVyZGF5KScsIHR5cGU6ICdjYXRlZ29yaWFsJywgZ3JvdXBzOiBbJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknLCAnU3VuZGF5J10gfSxcbiAgeyBwb3N0Z3Jlc0Zvcm1hdDogJ0FNJywgbW9tZW50Rm9ybWF0OiAnQScsIGRlc2NyaXB0aW9uOiAnQU0vUE0nLCB0eXBlOiAnY2F0ZWdvcmlhbCcsIGdyb3VwczogWydBTScsICdQTSddIH1cbl0pO1xuXG52YXIgRHVyYXRpb25Vbml0ID0gQW1wZXJzYW5kTW9kZWwuZXh0ZW5kKHtcbiAgcHJvcHM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpdmUgbmFtZSBvZiB0aGUgdGltZSB1bml0XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblVuaXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiBbJ3N0cmluZyddLFxuICAgIC8qKlxuICAgICAqIE1vbWVudGpzIHBhcnNpbmcgZm9ybWF0XG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblVuaXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIG1vbWVudEZvcm1hdDogWydzdHJpbmcnXSxcbiAgICAvKipcbiAgICAgKiBQb3N0Z3JlcyBwYXJzaW5nIGZvcm1hdFxuICAgICAqIEBtZW1iZXJvZiEgRHVyYXRpb25Vbml0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBwb3N0Z3Jlc0Zvcm1hdDogWydzdHJpbmcnXSxcbiAgICAvKipcbiAgICAgKiBDb252ZXJzaW9uIGZhY3RvciB0byBzZWNvbmRzXG4gICAgICogQG1lbWJlcm9mISBEdXJhdGlvblVuaXRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHNlY29uZHM6IFsnbnVtYmVyJ11cbiAgfVxufSk7XG5cbnZhciBEdXJhdGlvblVuaXRzID0gQW1wZXJzYW5kQ29sbGxlY3Rpb24uZXh0ZW5kKHtcbiAgaW5kZXhlczogWydkZXNjcmlwdGlvbiddLFxuICBtb2RlbDogRHVyYXRpb25Vbml0XG59KTtcblxudmFyIGR1cmF0aW9uVW5pdHMgPSBuZXcgRHVyYXRpb25Vbml0cyhbXG4gIHtcbiAgICBkZXNjcmlwdGlvbjogJ0lTTzg2MDEnLFxuICAgIHNlY29uZHM6IDFcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnbWlsbGVuaXVtJyxcbiAgICBtb21lbnRGb3JtYXQ6ICdtaWxsZW5pdW0nLFxuICAgIHBvc3RncmVzRm9ybWF0OiAnbWlsbGVuaXVtJyxcbiAgICBzZWNvbmRzOiAxMDAgKiAzNjUuMjUgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnY2VudHVyeScsXG4gICAgbW9tZW50Rm9ybWF0OiAnY2VudHVyeScsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdjZW50dXJ5JyxcbiAgICBzZWNvbmRzOiAxMDAgKiAzNjUuMjUgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnZGVjYWRlcycsXG4gICAgbW9tZW50Rm9ybWF0OiAnZGVjYWRlcycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdkZWNhZGUnLFxuICAgIHNlY29uZHM6IDEwICogMzY1LjI1ICogMjQgKiA2MCAqIDYwXG4gIH0sIHtcbiAgICBkZXNjcmlwdGlvbjogJ3llYXJzJyxcbiAgICBtb21lbnRGb3JtYXQ6ICd5ZWFycycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICd5ZWFyJyxcbiAgICBzZWNvbmRzOiAzNjUuMjUgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAncXVhcnRlcnMnLFxuICAgIG1vbWVudEZvcm1hdDogJycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdxdWFydGVyJyxcbiAgICBzZWNvbmRzOiAzNjUuMjUgKiA4ICogNjAgKiA2MFxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdtb250aHMnLFxuICAgIG1vbWVudEZvcm1hdDogJ21vbnRocycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdtb250aCcsXG4gICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnd2Vla3MnLFxuICAgIG1vbWVudEZvcm1hdDogJ3dlZWtzJyxcbiAgICBwb3N0Z3Jlc0Zvcm1hdDogJ3dlZWsnLFxuICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnZGF5cycsXG4gICAgbW9tZW50Rm9ybWF0OiAnZGF5cycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdkYXknLFxuICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MFxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdob3VycycsXG4gICAgbW9tZW50Rm9ybWF0OiAnaG91cnMnLFxuICAgIHBvc3RncmVzRm9ybWF0OiAnaG91cicsXG4gICAgc2Vjb25kczogNjAgKiA2MFxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdtaW51dGVzJyxcbiAgICBtb21lbnRGb3JtYXQ6ICdtaW51dGVzJyxcbiAgICBwb3N0Z3Jlc0Zvcm1hdDogJ21pbnV0ZScsXG4gICAgc2Vjb25kczogNjBcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnc2Vjb25kcycsXG4gICAgbW9tZW50Rm9ybWF0OiAnc2Vjb25kcycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdzZWNvbmQnLFxuICAgIHNlY29uZHM6IDFcbiAgfSwge1xuICAgIGRlc2NyaXB0aW9uOiAnbWlsbGlzZWNvbmRzJyxcbiAgICBtb21lbnRGb3JtYXQ6ICdtaWxsaXNlY29uZHMnLFxuICAgIHBvc3RncmVzRm9ybWF0OiAnbWlsbGlzZWNvbmRzJyxcbiAgICBzZWNvbmRzOiAwLjAwMVxuICB9LCB7XG4gICAgZGVzY3JpcHRpb246ICdtaWNyb3NlY29uZHMnLFxuICAgIG1vbWVudEZvcm1hdDogJ21pY3Jvc2Vjb25kcycsXG4gICAgcG9zdGdyZXNGb3JtYXQ6ICdtaWNyb3NlY29uZHMnLFxuICAgIHNlY29uZHM6IDAuMDAwMDAxXG4gIH1cbl0pO1xuXG52YXIgVGltZVpvbmUgPSBBbXBlcnNhbmRNb2RlbC5leHRlbmQoe1xuICBwcm9wczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGl2ZSBuYW1lIG9mIHRoZSB0aW1lIHpvbmVcbiAgICAgKiBAbWVtYmVyb2YhIFRpbWVab25lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbjogWydzdHJpbmcnXSxcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSB6b25lIGZvcm1hdFxuICAgICAqIEBtZW1iZXJvZiEgVGltZVpvbmVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdDogWydzdHJpbmcnXVxuICB9XG59KTtcblxudmFyIFRpbWVab25lcyA9IEFtcGVyc2FuZENvbGxsZWN0aW9uLmV4dGVuZCh7XG4gIGluZGV4ZXM6IFsnZGVzY3JpcHRpb24nXSxcbiAgbW9kZWw6IFRpbWVab25lXG59KTtcblxudmFyIHRpbWVab25lcyA9IG5ldyBUaW1lWm9uZXMoKTtcbnRpbWVab25lcy5hZGQoe1xuICBkZXNjcmlwdGlvbjogJ0lTTzg2MDEnLFxuICBmb3JtYXQ6ICdJU084NjAxJ1xufSk7XG5cbm1vbWVudC50ei5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKHR6KSB7XG4gIHRpbWVab25lcy5hZGQoe1xuICAgIGRlc2NyaXB0aW9uOiB0eixcbiAgICBmb3JtYXQ6IHR6XG4gIH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0aW1lUGFydHM6IHRpbWVQYXJ0cyxcbiAgdGltZVpvbmVzOiB0aW1lWm9uZXMsXG4gIGR1cmF0aW9uVW5pdHM6IGR1cmF0aW9uVW5pdHMsXG4gIGdldERhdGV0aW1lUmVzb2x1dGlvbjogZ2V0RGF0ZXRpbWVSZXNvbHV0aW9uLFxuICBnZXREdXJhdGlvblJlc29sdXRpb246IGdldER1cmF0aW9uUmVzb2x1dGlvbixcbiAgZ2V0Rm9ybWF0OiBnZXRGb3JtYXRcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///d45b\n")},de3f:function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction crossfilter_null() {\n  return null;\n}\n\nmodule.exports = crossfilter_null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGUzZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9udWxsLmpzPzcwYzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjcm9zc2ZpbHRlcl9udWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcm9zc2ZpbHRlcl9udWxsO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///de3f\n")},e59a:function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Partition = __webpack_require__(/*! ../partition */ \"8191\");\n\nmodule.exports = Collection.extend({\n  model: Partition,\n  indexes: ['rank'],\n  comparator: 'rank',\n  initialize: function () {\n    this.on('add', function (newPartition) {\n      newPartition.reset();\n    });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZTU5YS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvcGFydGl0aW9uL2NvbGxlY3Rpb24uanM/YzRiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgUGFydGl0aW9uID0gcmVxdWlyZSgnLi4vcGFydGl0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogUGFydGl0aW9uLFxuICBpbmRleGVzOiBbJ3JhbmsnXSxcbiAgY29tcGFyYXRvcjogJ3JhbmsnLFxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vbignYWRkJywgZnVuY3Rpb24gKG5ld1BhcnRpdGlvbikge1xuICAgICAgbmV3UGFydGl0aW9uLnJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///e59a\n")},e810:function(module,exports,__webpack_require__){eval("/**\n * ContinuousTransfrom defines a transformation on continuous (nummerical) data.\n * Currently linear interpolation between a set of control points is implemented.\n *\n * @class ContinuousTransform\n */\nvar AmpersandModel = __webpack_require__(/*! ampersand-model */ \"3bfc\");\n\nmodule.exports = AmpersandModel.extend({\n  props: {\n    transformedType: {\n      type: 'string',\n      required: true,\n      default: 'text',\n      values: ['text']\n    },\n    transformedMin: {\n      type: 'number',\n      required: true,\n      default: 0\n    },\n    transformedMax: {\n      type: 'number',\n      required: true,\n      default: 100\n    }\n  },\n  reset: function () {\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZTgxMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvZmFjZXQvdGV4dC10cmFuc2Zvcm0uanM/MzQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbnRpbnVvdXNUcmFuc2Zyb20gZGVmaW5lcyBhIHRyYW5zZm9ybWF0aW9uIG9uIGNvbnRpbnVvdXMgKG51bW1lcmljYWwpIGRhdGEuXG4gKiBDdXJyZW50bHkgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBhIHNldCBvZiBjb250cm9sIHBvaW50cyBpcyBpbXBsZW1lbnRlZC5cbiAqXG4gKiBAY2xhc3MgQ29udGludW91c1RyYW5zZm9ybVxuICovXG52YXIgQW1wZXJzYW5kTW9kZWwgPSByZXF1aXJlKCdhbXBlcnNhbmQtbW9kZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbXBlcnNhbmRNb2RlbC5leHRlbmQoe1xuICBwcm9wczoge1xuICAgIHRyYW5zZm9ybWVkVHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6ICd0ZXh0JyxcbiAgICAgIHZhbHVlczogWyd0ZXh0J11cbiAgICB9LFxuICAgIHRyYW5zZm9ybWVkTWluOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgdHJhbnNmb3JtZWRNYXg6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0OiAxMDBcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///e810\n")},e95e:function(module,exports,__webpack_require__){"use strict";eval('\n\nvar crossfilter_identity = __webpack_require__(/*! ./identity */ "55a3");\nvar xFilterHeap = __webpack_require__(/*! ./heap */ "a74f");\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\nmodule.exports = heapselect_by(crossfilter_identity);\nmodule.exports.by = heapselect_by; // assign the raw function to the export as well\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZTk1ZS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvY3Jvc3NmaWx0ZXIyL3NyYy9oZWFwc2VsZWN0LmpzPzk2NGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3Jvc3NmaWx0ZXJfaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG52YXIgeEZpbHRlckhlYXAgPSByZXF1aXJlKCcuL2hlYXAnKTtcblxuZnVuY3Rpb24gaGVhcHNlbGVjdF9ieShmKSB7XG4gIHZhciBoZWFwID0geEZpbHRlckhlYXAuYnkoZik7XG5cbiAgLy8gUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSB0b3AgayBlbGVtZW50cyBpbiB0aGUgYXJyYXkgYVtsbzpoaV0uXG4gIC8vIFRoZSByZXR1cm5lZCBhcnJheSBpcyBub3Qgc29ydGVkLCBidXQgbWFpbnRhaW5zIHRoZSBoZWFwIHByb3BlcnR5LiBJZiBrIGlzXG4gIC8vIGdyZWF0ZXIgdGhhbiBoaSAtIGxvLCB0aGVuIGZld2VyIHRoYW4gayBlbGVtZW50cyB3aWxsIGJlIHJldHVybmVkLiBUaGVcbiAgLy8gb3JkZXIgb2YgZWxlbWVudHMgaW4gYSBpcyB1bmNoYW5nZWQgYnkgdGhpcyBvcGVyYXRpb24uXG4gIGZ1bmN0aW9uIGhlYXBzZWxlY3QoYSwgbG8sIGhpLCBrKSB7XG4gICAgdmFyIHF1ZXVlID0gbmV3IEFycmF5KGsgPSBNYXRoLm1pbihoaSAtIGxvLCBrKSksXG4gICAgICAgIG1pbixcbiAgICAgICAgaSxcbiAgICAgICAgZDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrOyArK2kpIHF1ZXVlW2ldID0gYVtsbysrXTtcbiAgICBoZWFwKHF1ZXVlLCAwLCBrKTtcblxuICAgIGlmIChsbyA8IGhpKSB7XG4gICAgICBtaW4gPSBmKHF1ZXVlWzBdKTtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGYoZCA9IGFbbG9dKSA+IG1pbikge1xuICAgICAgICAgIHF1ZXVlWzBdID0gZDtcbiAgICAgICAgICBtaW4gPSBmKGhlYXAocXVldWUsIDAsIGspWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKytsbyA8IGhpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWU7XG4gIH1cblxuICByZXR1cm4gaGVhcHNlbGVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoZWFwc2VsZWN0X2J5KGNyb3NzZmlsdGVyX2lkZW50aXR5KTtcbm1vZHVsZS5leHBvcnRzLmJ5ID0gaGVhcHNlbGVjdF9ieTsgLy8gYXNzaWduIHRoZSByYXcgZnVuY3Rpb24gdG8gdGhlIGV4cG9ydCBhcyB3ZWxsXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///e95e\n')},ea82:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = __webpack_require__(/*! isarray */ \"6176\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"419b\");\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"698d\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWE4Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanM/ZGQwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG4gIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICAgIGlmIChpc0J1ZihkYXRhKSkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///ea82\n")},ef13:function(module,exports){eval("/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWYxMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanM/NTM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///ef13\n")},faaa:function(module,exports){eval("\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on (obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function () {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFhYS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanM/MTBkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbiAob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///faaa\n")},fbef:function(module,exports,__webpack_require__){eval("var Collection = __webpack_require__(/*! ampersand-collection */ \"7bd3\");\nvar Aggregate = __webpack_require__(/*! ../aggregate */ \"9d63\");\n\nmodule.exports = Collection.extend({\n  model: Aggregate,\n  indexes: ['rank'],\n  comparator: 'rank'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmJlZi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcG90LWZyYW1ld29yay9zcmMvYWdncmVnYXRlL2NvbGxlY3Rpb24uanM/YmJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2FtcGVyc2FuZC1jb2xsZWN0aW9uJyk7XG52YXIgQWdncmVnYXRlID0gcmVxdWlyZSgnLi4vYWdncmVnYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuICBtb2RlbDogQWdncmVnYXRlLFxuICBpbmRleGVzOiBbJ3JhbmsnXSxcbiAgY29tcGFyYXRvcjogJ3JhbmsnXG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///fbef\n")}}]);